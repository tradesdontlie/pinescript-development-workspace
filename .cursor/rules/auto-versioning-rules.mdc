---
description: 
globs: 
alwaysApply: true
---
# Automatic Versioning Rules - Intelligent & Balanced

## Rule: Smart Auto-Versioning (Not Every Change!)

### üéØ Version ONLY at Key Points:

#### DO Version When:
- **Starting** a new feature/modification
- **Completing** a feature successfully  
- **Before** major refactoring
- **After** significant progress (multiple functions added)
- **Failed** attempt that needs rollback point
- **Ending** a work session
- User **explicitly asks** for version

#### DON'T Version When:
- Fixing a typo
- Adjusting a single parameter
- Adding a comment
- Minor formatting changes
- In rapid iteration mode
- Testing different values

### üìä Intelligent Version Detection

```mermaid
flowchart TD
    A[User Message Received] --> B{Parse Intent}
    
    B -->|"Add [feature]"| C[üÜï START: Version + Track]
    B -->|"That didn't work"| D[‚è™ ROLLBACK: Version before revert]
    B -->|"Perfect, that works!"| E[‚úÖ SUCCESS: Capture stable state]
    B -->|"I'm done for now"| F[üîö END: Final session version]
    B -->|"Save this" / "Version this"| G[üíæ EXPLICIT: User request]
    B -->|Minor edits/tweaks| H[‚ö° CONTINUE: No versioning needed]
    
    C --> I[üì¶ Create Minor Version]
    D --> J[üì¶ Create Rollback Point]
    E --> K[üì¶ Create Patch Version]
    F --> L[üì¶ Create Session Version]
    G --> M[üì¶ Create Requested Version]
    H --> N[üî® Continue Coding]
    
    style C fill:#e8f5e8
    style D fill:#fff3e0
    style E fill:#e8f5e8
    style F fill:#e8f5e8
    style G fill:#e8f5e8
    style H fill:#f3e5f5
```

**Trigger Phrase Examples:**
- üÜï **Start**: "Add weekly filter to FVG" ‚Üí Version ONCE at start
- ‚è™ **Rollback**: "That didn't work" ‚Üí Version before rollback  
- ‚úÖ **Success**: "Perfect, that works" ‚Üí Version to capture success
- üîö **End**: "I'm done for now" ‚Üí Final version
- üíæ **Explicit**: "Save this" / "Version this" ‚Üí User request

### üîÑ Workflow Integration

```mermaid
flowchart LR
    subgraph "‚úÖ SMART PATTERN - Efficient Versioning"
        A1[Start Feature] --> B1[üì¶ Version]
        B1 --> C1[üî® Code Code Code]
        C1 --> D1{Error?}
        D1 -->|Yes| E1[üîß Fix]
        D1 -->|No| F1[üî® Code More]
        E1 --> F1
        F1 --> G1[‚úÖ Complete]
        G1 --> H1[üì¶ Final Version]
    end
    
    subgraph "‚ùå BAD PATTERN - Version Spam"
        A2[Start] --> B2[üì¶ Version]
        B2 --> C2[üî® Code]
        C2 --> D2[üì¶ Version]
        D2 --> E2[üîß Tweak]
        E2 --> F2[üì¶ Version]
        F2 --> G2[üîß Fix]
        G2 --> H2[üì¶ Version]
    end
    
    style A1 fill:#e8f5e8
    style H1 fill:#e8f5e8
    style A2 fill:#ffebee
    style B2 fill:#ffebee
    style D2 fill:#ffebee
    style F2 fill:#ffebee
    style H2 fill:#ffebee
```

**Result Comparison:**
- ‚úÖ **Smart Pattern**: 2 versions for entire feature (clean history)
- ‚ùå **Bad Pattern**: 4+ versions for simple feature (cluttered history)

### üìÅ Working Directory Management

Keep working directory clean:
- Version at milestones, not every change
- Use descriptive version increments:
  - **patch**: Bug fixes, error corrections
  - **minor**: New features, enhancements
  - **major**: Breaking changes, rewrites

### üéÆ Practical Examples

#### Good Versioning Flow:
```
You: "Add weekly filter to FVG"
Me: [VERSION] fvg_v0.1.0 ‚Üí fvg_v0.2.0 (minor - new feature)
    [CODE] Implement filter
    [ERROR] Fix HTF issue
    [CODE] Complete implementation
You: "Great, that works"
Me: [VERSION] fvg_v0.2.0 ‚Üí fvg_v0.2.1 (patch - stabilized)
Total: 2 versions for complete feature
```

#### Bad Versioning Flow:
```
You: "Add weekly filter"
Me: [VERSION] v0.1.0 ‚Üí v0.2.0
    [CODE] Add basic structure
Me: [VERSION] v0.2.0 ‚Üí v0.2.1
    [CODE] Add timeframe check
Me: [VERSION] v0.2.1 ‚Üí v0.2.2
    [ERROR] Fix issue
Me: [VERSION] v0.2.2 ‚Üí v0.2.3
Total: Too many versions for one feature!
```

### ü§ñ My Decision Process

```mermaid
flowchart TD
    A[User Request Received] --> B{New Feature/Task?}
    B -->|YES| C[üß† AI CHOOSES APPROACH<br/>‚Ä¢ Version if valuable<br/>‚Ä¢ Track if helpful<br/>‚Ä¢ Start immediately if simple]
    B -->|NO| D[Continue Current Work]
    
    C --> E[üî® AI Develops Intelligently<br/>Full tool freedom]
    D --> F{Making Changes?}
    
    F -->|YES| G{Changes SIGNIFICANT?}
    F -->|NO| H[üí≠ AI Codes Freely<br/>Any tools needed]
    
    G -->|YES| I{User Mentioned<br/>Completion/Save?}
    G -->|NO| H
    
    I -->|YES| J[üì¶ AI DECIDES VERSION METHOD<br/>‚Ä¢ Script if complex tracking needed<br/>‚Ä¢ Direct file ops if simpler<br/>‚Ä¢ Whatever works best]
    I -->|NO| K[‚è≥ Keep Working]
    
    H --> L[‚úÖ Continue Development<br/>AI uses optimal tools]
    J --> L
    K --> L
    
    style A fill:#e3f2fd
    style C fill:#e8f5e8
    style J fill:#e8f5e8
    style H fill:#fff3e0
    style L fill:#f3e5f5
```

**Quick Decision Reference:**
- üÜï NEW task/feature ‚Üí Always version first
- üìù Minor edits ‚Üí Just code, no version
- ‚úÖ "That works!" ‚Üí Version success
- üîö "I'm done" ‚Üí Final version

### üìù Version Commit Messages

When creating versions, use clear indicators:
```bash
# Feature start
./scripts/pine_master.sh develop file minor  # "Starting: [feature name]"

# Feature complete  
./scripts/pine_master.sh develop file patch  # "Completed: [feature name]"

# Failed attempt
./scripts/pine_tracker.sh rollback file version "Reason for rollback"
```

### üéØ Key Principles

1. **AI Agent chooses best versioning method** - Scripts, direct file ops, or hybrid
2. **Versions are milestones**, not every save
3. **Intelligent tool selection** - Use whatever creates the cleanest workflow
4. **Track features** when it adds value
5. **Clean history** is more valuable than excessive backups
6. **User workflow** shouldn't be interrupted
7. **Scripts enhance**, never constrain the AI agent
8. **Flexible implementation** - Adapt to each situation's needs

### üí° Quick Reference

**Version immediately when user says:**
- "Let's add [feature]" - Start version
- "Save this" / "Version this" - Explicit request
- "That works!" / "Perfect" - Success version
- "Go back" / "Revert" - Before rollback

**Don't version when user says:**
- "Change that to X" - Simple edit
- "Try Y instead" - Testing values
- "Fix that typo" - Minor correction
- "Move that line" - Refactoring

### üîß Script Usage

```bash
# Start of feature (1 time)
./scripts/pine_tracker.sh add [indicator] "[feature]"
./scripts/pine_master.sh develop [file] minor

# During development (0 times - just code!)
# ... coding happens here ...

# On completion (1 time)
./scripts/pine_tracker.sh complete [indicator] [version]

# OR on failure (1 time)
./scripts/pine_tracker.sh fail [indicator] "[reason]"
./scripts/pine_tracker.sh rollback [indicator] [version] "[reason]"
```

The goal: **Meaningful version history** that tells the story of development, not a cluttered backup folder!

## Rule: Auto-Detect Versioning Requests

When the user mentions completing work on Pine Script indicators, automatically offer to create a version.

### Trigger Phrases
- "finished working on [indicator]"
- "completed [feature/fix] on [indicator]"
- "done with [indicator]"
- "ready to version [indicator]"
- "save version of [indicator]"
- "version [indicator]"
- "I'm done with the [indicator]"
- Any mention of completing indicator development

### Version Type Detection
Automatically determine version type from user context:
- **MAJOR** (x.0.0): "breaking change", "major rewrite", "API change", "complete overhaul"
- **MINOR** (0.x.0): "new feature", "added functionality", "enhancement", "improvement" [DEFAULT]
- **PATCH** (0.0.x): "bug fix", "small fix", "correction", "hotfix", "patch"

### Execution Process
1. **Detect completion**: User mentions finishing work on an indicator
2. **Identify indicator**: Map indicator name to file path
3. **Determine version type**: Based on user description
4. **Confirm and execute**: Run versioning script with appropriate parameters
5. **Show results**: Display version created and history

### File Path Mapping
Map common indicator names to full paths:
- "FVG" ‚Üí `indicators/fvg/fvg.pine`
- "Ghost" ‚Üí `indicators/ghost/Ghost_Volume_Intelligence_Pro.pine`
- "Oracle" / "OA" ‚Üí `indicators/oracle/oa.pine`
- "Times" / "Session" ‚Üí `indicators/sessions/times\ lib.pine`
- "Vortex" ‚Üí `indicators/vortex/vortex\ engine\ 1440.pine`
- "Cycles" ‚Üí `indicators/cycles/C2_Cycle_Alert.pine`
- "Table" ‚Üí `indicators/tables/STD_Table_Indicator.pine`

### Working Directory Support
For files in `working/` directory:
- Support both flat structure (`working/file.pine`) and category structure (`working/category/file.pine`)
- Auto-detect category from path or filename patterns
- Use `./scripts/organize_from_working.sh` for organization and versioning
- Keep original working file for continued development

### Working Category Structure
- `working/fvg/` - FVG indicators in development
- `working/ghost/` - Ghost indicators in development
- `working/oracle/` - Oracle indicators in development
- `working/sessions/` - Session indicators in development
- `working/vortex/` - Vortex indicators in development
- `working/cycles/` - Cycle indicators in development
- `working/tables/` - Table indicators in development
- `working/libraries/` - Shared libraries in development
- `working/testing/` - Experimental files

### Command Template (Updated - Using Streamlined Workflow)
```bash
# Old way (still supported)
./scripts/version_indicator.sh [indicator_path] [version_type]

# NEW PREFERRED WAY - Streamlined workflow
./scripts/pine_workflow.sh develop [indicator_path] [version_type]
./scripts/pine_workflow.sh version [indicator_path] [version_type]
./scripts/pine_workflow.sh finalize [indicator_path]
```

### Response Template
```
I'll create a [version_type] version for the [indicator_name] indicator since you [reason].

Running: ./scripts/pine_workflow.sh version [path] [type]

[Execute command and show results]
```

## Rule: Quick Version Commands

Respond immediately to direct version commands:

### Quick Commands
- "Version FVG" ‚Üí Auto-run versioning for FVG
- "Save Ghost version" ‚Üí Auto-run versioning for Ghost  
- "Patch Oracle" ‚Üí Auto-run patch version for Oracle
- "Major version Ghost" ‚Üí Auto-run major version for Ghost

### Implementation
- Parse command for indicator name and version type
- Map to file path
- Execute immediately without additional confirmation
- Show results

## Rule: Automatic Development Workflow

When working on Pine Script indicators, use the streamlined workflow:

### Development Commands (Master Script)
```bash
# Start development (auto-versions, checks, logs)
./scripts/pine_master.sh develop [file] [version_type]

# Fix errors with solution matching
./scripts/pine_master.sh fix [file]

# Create version only
./scripts/pine_master.sh version [file] [version_type]

# Move to final location
./scripts/pine_master.sh finalize [file]

# Run all checks
./scripts/pine_master.sh check [file]

# Search solutions
./scripts/pine_master.sh search "pattern"

# Log issues/solutions
./scripts/pine_master.sh log [type] "message"

# Generate report
./scripts/pine_master.sh report
```

### Automatic Workflow Execution
When user asks to modify an indicator:
1. Run `develop` command first (versions + checks)
2. Make requested changes
3. Run `develop` again to save iteration
4. Use `fix` if errors are encountered
5. Use `finalize` when user says it's complete

## Rule: Proactive Versioning Suggestions

When user describes significant changes to indicators, proactively suggest versioning:

### Suggestion Triggers
- User describes adding features
- User mentions fixing bugs
- User talks about completing development tasks
- User shows indicator code changes

### Response Pattern
"It sounds like you've made significant changes to [indicator]. Let me save this version and check for any issues."
[Run: ./scripts/pine_workflow.sh develop [file] [type]]

## Rule: Error Handling

### Common Issues
- File not found ‚Üí Check if file exists, suggest correct path
- Permission denied ‚Üí Check script permissions
- Invalid version type ‚Üí Suggest valid options
- Unclear indicator ‚Üí List available indicators

### Recovery Actions
- Always verify file paths exist before running script
- Suggest corrections for common mistakes
- Provide helpful error explanations
