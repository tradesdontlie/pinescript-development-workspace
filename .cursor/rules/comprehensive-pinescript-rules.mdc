---
description: 
globs: 
alwaysApply: false
---
# Comprehensive Pine Script v6 Rules & Best Practices

*Derived from Pine Script v6 Extension analysis and [TradingView Pine Script v6 Reference](mdc:https:/www.tradingview.com/pine-script-reference/v6)*

---

## üìã Table of Contents

1. [Version & Script Declaration](mdc:#version--script-declaration)
2. [Type System & Keywords](mdc:#type-system--keywords)
3. [Variable Declaration & Assignment](mdc:#variable-declaration--assignment)
4. [Function Definition & Usage](mdc:#function-definition--usage)
5. [Object Lifecycle Management](mdc:#object-lifecycle-management)
6. [Array, Matrix & Map Operations](mdc:#array-matrix--map-operations)
7. [Pine Script v6 Specific Features](mdc:#pine-script-v6-specific-features)
8. [Common Error Patterns & Solutions](mdc:#common-error-patterns--solutions)
9. [Performance & Best Practices](mdc:#performance--best-practices)
10. [Syntax Rules & Line Continuation](mdc:#syntax-rules--line-continuation)

---

## üîñ Version & Script Declaration

### **Rule V1.1: Version Declaration (MANDATORY)**
```pine
//@version=6
indicator("My Indicator", overlay=true)
```

**‚úÖ Supported Versions:** `4`, `5`, `6`  
**üéØ Recommended:** Always use v6 for new scripts  
**üìå Pattern:** `^(\/\/)(@)(version)(=)([456])`

### **Rule V1.2: Script Type Declaration**
```pine
// Choose ONE of these script types:
indicator("Title", overlay=true)    // Technical analysis indicator
strategy("Title", overlay=true)     // Trading strategy with orders
library("Title")                    // Reusable functions for export
```

**üö® Critical:** Script declaration must appear after version and before any code

---

## üè∑Ô∏è Type System & Keywords

### **Rule T1.1: Type Keywords & Forms**

| **Type** | **Usage** | **Example** |
|----------|-----------|-------------|
| `int`, `float`, `bool`, `string`, `color` | Basic types | `int myVar = 10` |
| `line`, `label`, `box`, `table`, `linefill` | Object IDs (always series) | `line myLine = line.new(...)` |
| `polyline`, `chart.point` | v6 Objects | `polyline pl = polyline.new()` |
| `array<type>` or `type[]` | Arrays | `array<float> arr = array.new_float()` |
| `matrix<type>` | Matrices | `matrix<float> mx = matrix.new_float()` |
| `map<keyType, valueType>` | Key-value maps | `map<string, float> m = map.new<string, float>()` |

### **Rule T1.2: Type Forms (Simple vs Series)**
```pine
// In exported library functions:
export emaRight(float source, simple int length) =>  // ‚úÖ Correct
    ta.ema(source, length)

export emaWrong(float source, int length) =>         // ‚ùå Error
    ta.ema(source, length)  // length becomes 'series int', not supported
```

**üéØ Key Point:** Use `simple` for library function parameters that need compile-time constants

### **Rule T1.3: Type Consistency**
```pine
// ‚úÖ Correct - same type in both branches
result = condition ? 1 : 2

// ‚ùå Error - type mismatch
result = condition ? 1 : 1.0  // int vs float
```

---

## üìù Variable Declaration & Assignment

### **Rule V2.1: Assignment Operators**

| **Operator** | **Purpose** | **Usage** |
|--------------|-------------|-----------|
| `=` | Initial declaration | `myVar = 10` |
| `:=` | Reassignment | `myVar := 20` |
| `+=`, `-=`, `*=`, `/=`, `%=` | Compound operations | `myVar += 5` |

### **Rule V2.2: Variable Scope & Declaration**
```pine
// ‚úÖ Correct declaration order
var globalVar = 0       // Global scope with 'var'
myVar = 0              // Declare first
myVar := myVar + 1     // Then reassign

// ‚ùå Error - undeclared identifier
myVar := myVar + 1     // Error: 'myVar' not declared
```

### **Rule V2.3: Explicit Typing Requirements**
```pine
// Required when initializing with 'na'
int myInt = na         // ‚úÖ Explicit type needed
float myFloat = na     // ‚úÖ Explicit type needed

// Optional for normal initialization
myInt = 10             // ‚úÖ Type inferred
myFloat = 3.14         // ‚úÖ Type inferred
```

---

## üîß Function Definition & Usage

### **Rule F1.1: Function Definition Syntax**
```pine
// Standard function definition
myFunction(param1, param2) =>
    result = param1 + param2
    result  // Return value (last expression)

// Function with default parameters
myFunction(param1, param2 = 10) =>
    param1 + param2

// Multi-line function with local variables
complexFunction(x, y) =>
    local1 = x * 2
    local2 = y * 3
    final = local1 + local2
    final
```

### **Rule F1.2: Function Parameter Types**
```pine
// Library export functions - specify type forms
export customTA(series float src, simple int len) =>
    ta.sma(src, len)

// Method definitions
method toString(simple int this) =>
    str.tostring(this)
```

### **Rule F1.3: Built-in Function Usage**
```pine
// ‚úÖ Correct parameter order and types
line.new(x1, y1, x2, y2, color=color.blue, width=2)

// ‚úÖ Check required vs optional parameters
request.security(symbol, timeframe, expression)  // All required

// ‚úÖ Use namespaced functions correctly
ta.sma(close, 20)      // Technical analysis
math.max(high, low)    // Math operations
array.push(arr, val)   // Array operations
```

---

## üóÇÔ∏è Object Lifecycle Management

### **Rule O1.1: Object Creation & Deletion**
```pine
// ‚úÖ Proper object lifecycle
if barstate.isconfirmed
    // Create objects on confirmed bars only
    myLine = line.new(bar_index-1, high, bar_index, high)
    
// ‚úÖ Clean up objects to prevent memory leaks
if barstate.islastconfirmedhistory
    // Delete old objects
    for i = 0 to array.size(lineArray) - 1
        line.delete(array.get(lineArray, i))
    array.clear(lineArray)
```

### **Rule O1.2: Object Types & Memory Management**
```pine
// Objects requiring cleanup:
// line, label, box, table, linefill, polyline

// ‚úÖ Pattern for object arrays
var array<line> lineArray = array.new<line>()

// Add new objects
if condition
    newLine = line.new(...)
    array.push(lineArray, newLine)

// Cleanup when needed
if array.size(lineArray) > maxLines
    oldLine = array.shift(lineArray)
    line.delete(oldLine)
```

---

## üìä Array, Matrix & Map Operations

### **Rule A1.1: Array Operations**
```pine
// ‚úÖ Array creation and type specification
var array<float> prices = array.new_float(0)
var array<string> symbols = array.new_string(0, "DEFAULT")

// ‚úÖ Safe array access - ALWAYS check size first
if array.size(prices) > 0
    lastPrice = array.get(prices, -1)  // v6: negative indices supported!
    
// ‚úÖ Common array operations
array.push(prices, close)
array.pop(prices)
array.sort(prices, order.ascending)
```

### **Rule A1.2: Pine v6 Array Enhancements**
```pine
// ‚úÖ v6 Feature: Negative indices
if array.size(arr) >= 2
    lastValue = array.get(arr, -1)      // Last element
    secondLast = array.get(arr, -2)     // Second to last
    
// ‚úÖ Array bounds checking pattern
safeArrayGet(arr, index) =>
    if array.size(arr) > math.abs(index)
        array.get(arr, index)
    else
        na
```

### **Rule A1.3: Matrix & Map Operations**
```pine
// Matrix creation
var matrix<float> priceMatrix = matrix.new<float>(3, 3, 0.0)

// Matrix operations
matrix.set(priceMatrix, 0, 0, close)
value = matrix.get(priceMatrix, 0, 0)

// Map creation and usage
var map<string, float> symbolPrices = map.new<string, float>()
map.put(symbolPrices, "AAPL", 150.0)
price = map.get(symbolPrices, "AAPL")
```

---

## üÜï Pine Script v6 Specific Features

### **Rule V6.1: Dynamic Requests**
```pine
// ‚úÖ v6 Feature: Variable symbols in requests
symbols = array.from("AAPL", "GOOGL", "MSFT")

for symbol in symbols
    // Dynamic symbol requests - NEW in v6!
    price = request.security(symbol, "1D", close)
    log.info("Price for " + symbol + ": " + str.tostring(price))
```

### **Rule V6.2: Enhanced Text Features**
```pine
// ‚úÖ v6 Feature: Exact point sizes instead of size constants
if barstate.islast
    label.new(bar_index, high, "Bold Text", 
              text_size = 16,  // Exact points instead of size.large
              text_formatting = text.format_bold)
    
    // ‚úÖ v6 Feature: Combined text formatting
    label.new(bar_index, low, "Bold & Italic", 
              text_size = 18,
              text_formatting = text.format_bold + text.format_italic)
```

### **Rule V6.3: Boolean Optimizations**
```pine
// ‚úÖ v6 Feature: Short-circuit evaluation for better performance
if array.size(myArray) > 0 and array.first(myArray) > 0
    // array.first() only evaluated if size > 0
    // More efficient boolean evaluation in v6
```

---

## ‚ùå Common Error Patterns & Solutions

### **Rule E1.1: Series vs Simple Type Errors**
```pine
// ‚ùå Common Error
ta.ema(close, series int length)  // Error: ta functions need simple int

// ‚úÖ Solution
ta.ema(close, simple int length)  // Correct: use simple form

// ‚úÖ Alternative when you can't control the type
length = input.int(20, "Length")  // This returns simple int
ema = ta.ema(close, length)       // Works correctly
```

### **Rule E1.2: Array Bounds Errors**
```pine
// ‚ùå Common Error
value = array.get(myArray, 5)  // May cause runtime error

// ‚úÖ Solution: Always check bounds
if array.size(myArray) > 5
    value = array.get(myArray, 5)
else
    value = na
```

### **Rule E1.3: Version Migration Errors**
```pine
// ‚ùå v4/v5 deprecated syntax
study("My Study")              // Use indicator() instead
security(symbol, tf, src)      // Use request.security() instead

// ‚úÖ v6 updated syntax  
indicator("My Indicator")
request.security(symbol, tf, src)

// ‚ùå v5 text sizing
text_size = size.large         // Use exact points in v6

// ‚úÖ v6 text sizing
text_size = 16                 // Exact point values
```

---

## ‚ö° Performance & Best Practices

### **Rule P1.1: Object Memory Management**
```pine
// ‚úÖ Efficient object cleanup pattern
var MAX_OBJECTS = 100
var array<line> lines = array.new<line>()

addLine(x1, y1, x2, y2) =>
    // Remove oldest if at limit
    if array.size(lines) >= MAX_OBJECTS
        oldest = array.shift(lines)
        line.delete(oldest)
    
    // Add new line
    newLine = line.new(x1, y1, x2, y2)
    array.push(lines, newLine)
```

### **Rule P1.2: Conditional Execution Optimization**
```pine
// ‚úÖ Use barstate conditions for expensive operations
if barstate.isconfirmed
    // Only execute on confirmed bars
    expensiveCalculation()

if barstate.islast
    // Only execute on last bar
    updateLabels()

if barstate.islastconfirmedhistory
    // One-time cleanup
    cleanupAllObjects()
```

### **Rule P1.3: Efficient Data Structures**
```pine
// ‚úÖ Choose appropriate data structure
// For ordered data: arrays
// For key-value pairs: maps  
// For 2D data: matrices

// ‚úÖ Pre-allocate when possible
var array<float> buffer = array.new_float(100, 0.0)  // Pre-allocated

// ‚ùå Avoid frequent resizing
// array.push() repeatedly without size management
```

---

## üìê Syntax Rules & Line Continuation

### **Rule S1.1: Single Line Statements**
```pine
// ‚úÖ Keep statements on single lines (Pine Script doesn't support line continuation)
line.new(bar_index, price1, bar_index+10, price2, color=color.blue, width=2)

// ‚úÖ Complex ternary expressions on single line
bandColor = condition1 ? color.green : condition2 ? color.orange : color.red

// ‚úÖ Function calls with multiple parameters on single line  
box.new(x1, y1, x2, y2, bgcolor=color.blue, border_color=color.black, border_width=1)
```

### **Rule S1.2: Indentation & Code Blocks**
```pine
// ‚úÖ Proper indentation for control structures
if condition
    statement1
    statement2
else if anotherCondition
    statement3
    statement4
else
    statement5
    statement6

// ‚úÖ Function body indentation
myFunction(param1, param2) =>
    localVar = param1 * 2
    result = localVar + param2
    result
```

### **Rule S1.3: Comments & Documentation**
```pine
// Single-line comments
/* 
Multi-line comments
for longer explanations
*/

// ‚úÖ Document function purpose and parameters
/// Calculates exponential moving average with custom smoothing
/// @param source The data series to smooth
/// @param length The number of periods (must be simple int)
/// @returns Smoothed series value
customEMA(series float source, simple int length) =>
    ta.ema(source, length)
```

---

## üéØ Quick Reference Checklist

### **Before Submitting Code:**
- [ ] Script begins with `//@version=6`
- [ ] Correct script type: `indicator()`, `strategy()`, or `library()`  
- [ ] All variables declared before use (`=` then `:=`)
- [ ] Array bounds checked with `array.size()`
- [ ] Object cleanup implemented for memory management
- [ ] Type consistency in ternary operators and expressions
- [ ] Proper use of `simple` vs `series` type forms
- [ ] One statement per line (no line continuation)
- [ ] Proper indentation for code blocks
- [ ] No compilation warnings in Pine Editor

### **Pine v6 Features to Leverage:**
- [ ] Dynamic symbols in `request.security()`
- [ ] Exact point sizes for text (instead of size constants)
- [ ] Text formatting combinations (`text.format_bold + text.format_italic`)
- [ ] Negative array indices (`array.get(arr, -1)`)
- [ ] Short-circuit boolean evaluation optimization

---

## üìö Reference Links

- **Official Documentation:** [Pine Script v6 Reference](mdc:https:/www.tradingview.com/pine-script-reference/v6)
- **Type System:** Focus on `simple` vs `series` forms for library functions
- **Object Management:** Always implement cleanup for `line`, `label`, `box`, `table`, `linefill`, `polyline`
- **Performance:** Use `barstate` conditions to optimize execution timing

*This comprehensive rule set ensures consistent, efficient, and error-free Pine Script v6 development.*
