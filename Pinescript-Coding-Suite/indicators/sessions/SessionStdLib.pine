//@version=5
// @description Utility library to compute IDR-based standard-deviation levels and live session statistics (protraction, distribution, current std-dev distance). Extracted from Ghost 97 indicator logic so it can be reused by other scripts without pulling the entire codebase.
// © 2024 Trades-Dont-Lie


library("STD_dev_lib", overlay=false, dynamic_requests=true)

// ======================================
// EXPORTED CONSTANTS
// ======================================

// Default set of std-dev multipliers used by the original indicator
_makeDefaultLevels() =>
    // Returns a fresh array each call to avoid cross-instance mutation
    array.from(0.5, 1.0, 2.5, 5.0, 7.5,
               8.0, 10.0, 13.0, 17.5,
              -1.5, -2.0, -3.5, -6.0, -8.5,
              -9.0, -11.0, -14.0, -18.5)

export getDefaultStdLevels() => _makeDefaultLevels()

// ======================================
// EXPORTED TYPES
// ======================================

// @type SessionStats holds the evolving statistics for one completed IDR box.
export type SessionStats
    // Immutable base anchors (set once the IDR is closed)
    float baseHigh = na   // Highest BODY price in IDR
    float baseLow  = na   // Lowest BODY price in IDR
    float idrRange = na   // baseHigh ‑ baseLow

    // Dynamic statistics (updated every bar after session close)
    bool  dirSet           = false      // once a breakout happens we freeze the direction
    string direction       = "NA"       // "Long" | "Short"
    float protraction      = 0.0        // Maximum excursion in the breakout direction (signed)
    float distribution     = 0.0        // Maximum excursion in the opposite direction (signed)

    // Helper: live distance for the current bar (signed std-devs)
    float currentStd       = 0.0

// ======================================
// EXPORTED CONSTRUCTORS / HELPERS
// ======================================

// @function newStats
// @brief  Create a new SessionStats object once IDR boundaries are known.
// @param  _hi  Highest BODY of the session
// @param  _lo  Lowest BODY of the session
// @returns     SessionStats instance (range calculated internally)
export newStats(float _hi, float _lo) =>
    SessionStats.new(_hi, _lo, _hi - _lo, false, "NA", 0.0, 0.0, 0.0)

// --------------------------------------
// Internal helper – compute signed distance of a price versus IDR box
// positive when price >= baseHigh; negative when price <= baseLow; 0 otherwise.
// Returned in std-dev units (multiples of `idrRange`).
_signedDist(SessionStats _s, float _price) =>
    if _price >= _s.baseHigh
        (_price - _s.baseHigh) / _s.idrRange
    else if _price <= _s.baseLow
        (_price - _s.baseLow) / _s.idrRange
    else
        0.0

// --------------------------------------
// @function update
// @brief  Feed each new bar to update protraction/distribution & currentStd.
// @param  _s     Existing stats instance (pass by reference)
// @param  _high  Current bar high
// @param  _low   Current bar low
// @param  _close Current bar close
// @returns       The *updated* SessionStats (can be reassigned by caller)
export update(SessionStats _s, float _high, float _low, float _close) =>
    // Guard against unset range
    if na(_s.idrRange) or _s.idrRange == 0
        _s
    else
        float upLvl   = (_high - _s.baseHigh) / _s.idrRange
        float downLvl = (_low  - _s.baseLow ) / _s.idrRange

        // Initialise direction on first breakout
        if not _s.dirSet and (upLvl > 0 or downLvl < 0)
            _s.dirSet   := true
            if math.abs(upLvl) >= math.abs(downLvl)
                _s.direction    := "Long"
                _s.protraction  := upLvl
                _s.distribution := downLvl  // negative or zero
            else
                _s.direction    := "Short"
                _s.protraction  := downLvl
                _s.distribution := upLvl    // positive or zero
        // Already has direction – maintain running extremes
        else if _s.dirSet
            if _s.direction == "Long"
                if upLvl > _s.protraction
                    _s.protraction := upLvl
                if downLvl < _s.distribution
                    _s.distribution := downLvl
            else  // Short
                if downLvl < _s.protraction
                    _s.protraction := downLvl
                if upLvl > _s.distribution
                    _s.distribution := upLvl

        // Live std-dev for the current close
        _s.currentStd := _signedDist(_s, _close)

        _s  // return updated struct

// --------------------------------------
// @function levelPrice
// @brief  Translate a std-dev multiplier to an absolute price.
// @param  _s       Stats instance (range & bases must be set)
// @param  _stdev   Standard-deviation multiplier (e.g., 2.5, ‑1.5)
// @returns Price corresponding to that multiple relative to IDR box.
export levelPrice(SessionStats _s, float _stdev) => _stdev >= 0 ? _s.baseHigh + _s.idrRange * _stdev : _s.baseLow + _s.idrRange * _stdev

// --------------------------------------
// @function formatStd
// @brief Helper to stringify a signed std-dev value. Returns "Inside" when 0.
// @param _val float – signed std multiple
export formatStd(float _val) => _val == 0 ? "Inside" : str.tostring(_val, "#.##")

// ======================================
// END OF LIBRARY 