// ██    ██   ██████   ██████   ███████  ███████  ██   ██
// ██    ██  ██    ██  ██   ██     ██    ██        ██ ██ 
// ██    ██  ██    ██  ██████      ██    ██████     ███  
//  ██  ██   ██    ██  ██  ██      ██    ██        ██ ██ 
//   ████     ██████   ██   ██     ██    ███████  ██   ██

// ███████   ███   ██   ██████   ███████  ███   ██  ███████ 
// ██        ████  ██  ██          ██    ████  ██  ██      
// ██████    ██ ██ ██  ██  ████    ██    ██ ██ ██  ██████  
// ██        ██  ████  ██    ██    ██    ██  ████  ██      
// ███████   ██   ███   ██████   ███████  ██   ███  ███████ 

//---------------------------------------------------------
// Latest update @ 5-26-25 12:31pm:  2nd preset plotting ability 
//---------------------------------------------------------

//---------------------------------------------------------


//@version=5
indicator(("TBR Vortex Engine v1440∞"), overlay=true,max_lines_count = 500,max_labels_count = 500, max_boxes_count = 500)

// { -------- START INPUTS --------

// Add new input group for Sub Base Model Settings
SubBaseModelSettingsGroup = "Sub Base Model Settings"
ShowSubBaseModels = input.bool(true, "Show Sub Base Models", group = SubBaseModelSettingsGroup, inline = "SBM_Show", display = display.none)
EnableSubBaseModelSizeColoring = input.bool(true, "Enable Size-Based Coloring", group = SubBaseModelSettingsGroup, inline = "SBM_Show", display = display.none)

SubBaseModelDefaultColor = input.color(color.new(color.purple, 80), "Default Color", group = SubBaseModelSettingsGroup, inline = "SBM_Color1", tooltip="Used if Size-Based Coloring is disabled or conditions not met.", display = display.none)
SubBaseModelBorderColor = input.color(color.new(#868686, 79), "Border Color", group = SubBaseModelSettingsGroup, inline = "SBM_Color1", display = display.none)
SubBaseModelTextColor = input.color(color.new(#000000, 0), "Text Color", group = SubBaseModelSettingsGroup, inline = "SBM_Color1", display = display.none)

SubBaseModelSmallSizeThresholdPercent = 0.144
SubBaseModelMediumSizeThresholdPercent = 0.721

SubBaseModelSmallColor = input.color(color.new(#fff700, 25), "Small Color", group = SubBaseModelSettingsGroup, inline = "SBM_SizeColors", display = display.none)
SubBaseModelMediumColor = input.color(color.new(#20930e, 85), "Medium Color", group = SubBaseModelSettingsGroup, inline = "SBM_SizeColors", display = display.none)
SubBaseModelLargeColor = input.color(color.new(color.blue, 85), "Large Color", group = SubBaseModelSettingsGroup, inline = "SBM_SizeColors", display = display.none)

// New Inputs for Sub Base Model EQ Line Style
SubBaseModelEqLineColor = input.color(color.new(#940c9b, 34), "EQ Line Color", group = SubBaseModelSettingsGroup, inline = "SBM_EQLine", display = display.none)
SubBaseModelEqLineStyleString = input.string("solid", "EQ Line Style", options = ["solid", "dotted", "dashed"], group = SubBaseModelSettingsGroup, inline = "SBM_EQLine", display = display.none)
ExtendSubBaseModelEqLines = input.bool(false, "Extend EQ Lines", group = SubBaseModelSettingsGroup, inline = "SBM_Extend", display = display.none)

// New Input Group for Sub Base Model Anchor Settings
SubBaseModelAnchorSettingsGroup = "Sub Base Model Anchor Settings"

SubBaseModelAnchorPreset = input.string("Base Open to Base Open", "Anchor Preset", options = ["Base Open to Base Open", "Base Close to Base Close", "Session Open to Session Open", "Session Close to Session Close", "Base Open to Session Open", "Distro Close to Distro Close", "Session Body", "Base Body", "Fractal EQ to Fractal EQ"], group = SubBaseModelAnchorSettingsGroup, inline = "SBM_Preset", display = display.none)

// Second Preset Settings
ShowSecondPreset = input.bool(false, "Enable Second Preset", group = SubBaseModelAnchorSettingsGroup, inline = "SBM_Preset2", display = display.none)
SubBaseModelAnchorPreset2 = input.string("Session Body", "Second Preset", options = ["Base Open to Base Open", "Base Close to Base Close", "Session Open to Session Open", "Session Close to Session Close", "Base Open to Session Open", "Distro Close to Distro Close", "Session Body", "Base Body", "Fractal EQ to Fractal EQ"], group = SubBaseModelAnchorSettingsGroup, inline = "SBM_Preset2", display = display.none)

// Second Preset Colors (defaulted to same as first preset)
SubBaseModelDefaultColor2 = input.color(color.new(color.purple, 80), "Default Color 2", group = SubBaseModelSettingsGroup, inline = "SBM_Color2", tooltip="Colors for second preset", display = display.none)
SubBaseModelBorderColor2 = input.color(color.new(#868686, 79), "Border Color 2", group = SubBaseModelSettingsGroup, inline = "SBM_Color2", display = display.none)
SubBaseModelEqLineColor2 = input.color(color.new(#940c9b, 34), "EQ Line Color 2", group = SubBaseModelSettingsGroup, inline = "SBM_EQLine2", display = display.none)

SubBaseModelSmallColor2 = input.color(color.new(#fff700, 30), "Small Color 2", group = SubBaseModelSettingsGroup, inline = "SBM_SizeColors2", display = display.none)
SubBaseModelMediumColor2 = input.color(color.new(#20930e, 90), "Medium Color 2", group = SubBaseModelSettingsGroup, inline = "SBM_SizeColors2", display = display.none)
SubBaseModelLargeColor2 = input.color(color.new(color.blue, 90), "Large Color 2", group = SubBaseModelSettingsGroup, inline = "SBM_SizeColors2", display = display.none)

// Sub Base Model Table Settings
SubBaseModelTableGroup = "Sub Base Model Table"
ShowSubBaseModelTable = input.bool(true, "Show Sub Base Model Table", group = SubBaseModelTableGroup, inline = "SBMT_Show", display = display.none)
SubBaseModelTableMaxRows = input.int(10, "Regular Table Max Rows", minval = 1, maxval = 50, group = SubBaseModelTableGroup, inline = "SBMT_Show", display = display.none)

SubBaseModelTablePosition = input.string("Top Right", "Table Position", options=["Top Left", "Top Center", "Top Right","Middle Left","Middle Center","Middle Right","Bottom Left","Bottom Center","Bottom Right"], group = SubBaseModelTableGroup, inline = "SBMT_Pos", display = display.none)
SubBaseModelTableTextSize = input.string("Tiny", "Text Size", options=['Tiny', 'Small', 'Normal', 'Large'], group = SubBaseModelTableGroup, inline = "SBMT_Pos", display = display.none)

SubBaseModelTableBgColor = input.color(color.new(#1e1e1e, 0), "Background", group = SubBaseModelTableGroup, inline = "SBMT_Colors", display = display.none)
SubBaseModelTableTextColor = input.color(color.new(#ffffff, 0), "Text", group = SubBaseModelTableGroup, inline = "SBMT_Colors", display = display.none)
SubBaseModelTableBorderColor = input.color(color.new(#444444, 50), "Border", group = SubBaseModelTableGroup, inline = "SBMT_Colors", display = display.none)

// Priority 2 Table Settings
ShowSubBaseModelAdvancedTable = input.bool(false, "Show Advanced Analytics Table", group = SubBaseModelTableGroup, inline = "SBMT_Adv", display = display.none)
SubBaseModelAdvancedTableMaxRows = input.int(50, "Advanced Table Max Rows", minval = 1, maxval = 50, group = SubBaseModelTableGroup, inline = "SBMT_Adv", display = display.none)

SubBaseModelAdvancedTablePosition = input.string("Middle Right", "Advanced Table Position", options=["Top Left", "Top Center", "Top Right","Middle Left","Middle Center","Middle Right","Bottom Left","Bottom Center","Bottom Right"], group = SubBaseModelTableGroup, inline = "SBMT_AdvPos", display = display.none)



// CycleSettings = "Cycle Settings"
// ShowQuantumAsBoxes = input.bool(defval = true, title = "Show ADR/ODR/RDR As Boxes", inline = "1", group = CycleSettings)
ShowQuantumAsBoxes = false
// ShowOtherQuantumAsBoxes = input.bool(defval = true, title = "Show All As Boxes", inline = "1", group = CycleSettings)
ShowOtherQuantumAsBoxes = false
// ShowQuantumLabels = input.bool(defval = true, title = "Show Price Labels", inline = "4", group = CycleSettings)
ShowQuantumLabels = false
// ShowTable = input.bool(defval = true, title = "Show Sample Size", inline = "4", group = CycleSettings)
// ShowOnlyTime = input.bool(defval = false, title = "Show Only Time Lines", inline = "4", group = CycleSettings)
ShowOnlyTime = false
// ShowProjectionLabels = input.bool(defval = true, title = "Show Projection Labels", inline = "4", group = CycleSettings)
ShowProjectionLabels = false
// ShowTable = input.bool(defval = true, title = "Show Projection Table", inline = "4", group = CycleSettings)
ShowTable = false



// AllignFractalsRight = input.bool(defval = true, title = "Allign Fractals Right", inline = "1", group = CycleSettings)

AllignFractalsRight = false
// DeleteMitigated = false
// ExtendFractalLinesInRealtime = false

DrCycles = "DR Distribution Cycles"
// ShowADR = input.bool(defval = true, title = "ADR", inline = "1", group = DrCycles)
ShowADR = false
// ShowODR = input.bool(defval = true, title = "ODR", inline = "1", group = DrCycles)
ShowODR = false
// ShowRDR = input.bool(defval = true, title = "RDR", inline = "1", group = DrCycles)
ShowRDR = false

SessionCycles = "Base Model Distributions"
// ShowADRQ1 = input.bool(defval = false, title = "Alpha", inline = "1", group = SessionCycles)
ShowADRQ1 = false
// ShowADRQ2 = input.bool(defval = false, title = "Bravo", inline = "1", group = SessionCycles)
ShowADRQ2 = false
// ShowADRQ3 = input.bool(defval = false, title = "Charlie", inline = "1", group = SessionCycles)
ShowADRQ3 = false
// ShowADRQ4 = input.bool(defval = false, title = "Delta", inline = "1", group = SessionCycles)
ShowADRQ4 = false

// ShowODRQ1 = input.bool(defval = false, title = "Echo", inline = "2", group = SessionCycles)
ShowODRQ1 = false
// ShowODRQ2 = input.bool(defval = false, title = "Foxtrot", inline = "2", group = SessionCycles)
ShowODRQ2 = false

// ShowRDRQ1 = input.bool(defval = false, title = "Golf", inline = "3", group = SessionCycles)
ShowRDRQ1 = false
// ShowRDRQ2 = input.bool(defval = false, title = "Hotel", inline = "3", group = SessionCycles)
ShowRDRQ2 = false
// ShowRDRQ3 = input.bool(defval = false, title = "India", inline = "3", group = SessionCycles)
ShowRDRQ3 = false
// ShowRDRQ4 = input.bool(defval = false, title = "Juliet", inline = "3", group = SessionCycles)
ShowRDRQ4 = false

HtfCycles = "HTF Base Model Distributions"
// ShowHTF1 = input.bool(defval = false, title = "Kilo", inline = "1", group = HtfCycles)
ShowHTF1 = false
// ShowHTF2 = input.bool(defval = false, title = "Lima", inline = "1", group = HtfCycles)
ShowHTF2 = false

SessionsNormalDr = "DRs"
// ShowADRDr = input.bool(defval = false, title = "ADR", inline = "1", group = SessionsNormalDr)
ShowADRDr = false
// ShowODRDr = input.bool(defval = false, title = "ODR", inline = "1", group = SessionsNormalDr)
ShowODRDr = false
// ShowRDRDr = input.bool(defval = false, title = "RDR", inline = "1", group = SessionsNormalDr)
ShowRDRDr = false

SessionDrs = "Base Models"
// ShowADRQ1Dr = input.bool(defval = true, title = "Alpha", inline = "1", group = SessionDrs)
ShowADRQ1Dr = true
// ShowADRQ2Dr = input.bool(defval = true, title = "Bravo", inline = "1", group = SessionDrs)
ShowADRQ2Dr = true
// ShowADRQ3Dr = input.bool(defval = true, title = "Charlie", inline = "1", group = SessionDrs)
ShowADRQ3Dr = true
// ShowADRQ4Dr = input.bool(defval = true, title = "Delta", inline = "1", group = SessionDrs)
ShowADRQ4Dr = true

// ShowODRQ1Dr = input.bool(defval = true, title = "Echo", inline = "2", group = SessionDrs)
ShowODRQ1Dr = true
// ShowODRQ2Dr = input.bool(defval = true, title = "Foxtrot", inline = "2", group = SessionDrs)
ShowODRQ2Dr = true

// ShowRDRQ1Dr = input.bool(defval = true, title = "Golf", inline = "3", group = SessionDrs)
ShowRDRQ1Dr = true
// ShowRDRQ2Dr = input.bool(defval = true, title = "Hotel", inline = "3", group = SessionDrs)
ShowRDRQ2Dr = true
// ShowRDRQ3Dr = input.bool(defval = true, title = "India", inline = "3", group = SessionDrs)
ShowRDRQ3Dr = true
// ShowRDRQ4Dr = input.bool(defval = true, title = "Juliet", inline = "3", group = SessionDrs)
ShowRDRQ4Dr = true

HtfDrs = "HTF Base Models"
// ShowHTF1Dr = input.bool(defval = false, title = "Kilo", inline = "1", group = HtfDrs)
ShowHTF1Dr = true
// ShowHTF2Dr = input.bool(defval = false, title = "Lima", inline = "1", group = HtfDrs)
ShowHTF2Dr = false

HtfCycleDrs = "HTF Cycles"
ShowCycle1Dr = false
ShowCycle2Dr = false
ShowCycle3Dr = false
ShowCycle4Dr = false
ShowCycle5Dr = false

MatrixProjectionSettings = "Matrix Projection Settings"
// ManualRangeProjection =  input.bool(defval = false, title = "Manual", inline = "1", group = MatrixProjectionSettings)
ManualRangeProjection = false
// RangeStyle = input.string("OC", options= ["OC","IDR", "DR"], inline="1", group=MatrixProjectionSettings, title = "Anchor")
RangeStyle = "OC"
// ShowAllMatrixProjections = input.bool(defval = false, title = "Show All Matrix Projections", inline = "1", group = MatrixProjectionSettings)
ShowAllMatrixProjections = false
// ShowProjectionsAsBoxes  = input.bool(defval = false, title = "Show Projections As Boxes", inline = "1", group = MatrixProjectionSettings)
ShowProjectionsAsBoxes = false
// ShowOnlyRelevantProjections = input.bool(defval = false, title = "Show Only Relevant Projections", inline = "1", group = MatrixProjectionSettings)
ShowOnlyRelevantProjections = false
// ShowProjectionOnFirstCandle = input.bool(defval = true, title = "Anchor Projection on First Candle", inline = "1", group = MatrixProjectionSettings)
ShowProjectionOnFirstCandle = true

DrMatrixProjections = "DR Matrix Projections"
// ShowADRDrProjection = input.bool(defval = false, title = "ADR", inline = "1", group = DrMatrixProjections)
ShowADRDrProjection = false
// ShowODRDrProjection = input.bool(defval = false, title = "ODR", inline = "1", group = DrMatrixProjections)
ShowODRDrProjection = false
// ShowRDRDrProjection = input.bool(defval = false, title = "RDR", inline = "1", group = DrMatrixProjections)
ShowRDRDrProjection = false


SessionMatrixProjections = "Session Matrix Projections"
// ShowADRQ1DrProjection = input.bool(defval = false, title = "Alpha", inline = "1", group = SessionMatrixProjections)
ShowADRQ1DrProjection = false
// ShowADRQ2DrProjection = input.bool(defval = false, title = "Bravo", inline = "1", group = SessionMatrixProjections)
ShowADRQ2DrProjection = false
// ShowADRQ3DrProjection = input.bool(defval = false, title = "Charlie", inline = "1", group = SessionMatrixProjections)
ShowADRQ3DrProjection = false
// ShowADRQ4DrProjection = input.bool(defval = false, title = "Delta", inline = "1", group = SessionMatrixProjections)
ShowADRQ4DrProjection = false

// ShowODRQ1DrProjection = input.bool(defval = false, title = "Echo", inline = "2", group = SessionMatrixProjections)
ShowODRQ1DrProjection = false
// ShowODRQ2DrProjection = input.bool(defval = false, title = "Foxtrot", inline = "2", group = SessionMatrixProjections)
ShowODRQ2DrProjection = false

// ShowRDRQ1DrProjection = input.bool(defval = false, title = "Golf", inline = "3", group = SessionMatrixProjections)
ShowRDRQ1DrProjection = false
// ShowRDRQ2DrProjection = input.bool(defval = false, title = "Hotel", inline = "3", group = SessionMatrixProjections)
ShowRDRQ2DrProjection = false
// ShowRDRQ3DrProjection = input.bool(defval = false, title = "India", inline = "3", group = SessionMatrixProjections)
ShowRDRQ3DrProjection = false
// ShowRDRQ4DrProjection = input.bool(defval = false, title = "Juliet", inline = "3", group = SessionMatrixProjections)
ShowRDRQ4DrProjection = false

ShowHtfMatrixProjections = "HTF Matrix Projections"
// ShowHTF1DrProjection = input.bool(defval = false, title = "Kilo", inline = "1", group = ShowHtfMatrixProjections)
ShowHTF1DrProjection = false
// ShowHTF2DrProjection = input.bool(defval = false, title = "Lima", inline = "1", group = ShowHtfMatrixProjections)
ShowHTF2DrProjection = false

NumberOfHistoricalDrsToShow = 1 

SessionShowLines = "DR Show Lines"
// ShowFractalEqLine = input.bool(defval = false, title = "Show Fractal Eq", inline = "1", group = SessionShowLines, display = display.none)
ShowFractalEqLine = false
// ShowOpenLine = input.bool(defval = false, title = "Show Open Line", inline = "1", group = SessionShowLines, display = display.none)
ShowOpenLine = false
// ShowCloseLine = input.bool(defval = false, title = "Show Close Line", inline = "1", group = SessionShowLines, display = display.none)
ShowCloseLine = false
// ShowCloseBox = input.bool(defval = false, title = "Show Close Box", inline = "1", group = SessionShowLines, display = display.none)
ShowCloseBox = true
// ExtendFractalLinesInRealtime = input.bool(defval = false, title = "Extend Fractal Lines", inline = "1", group = SessionShowLines, display = display.none)
ExtendFractalLinesInRealtime = false


ShowDrLine = false
ShowIdrLine = false
ShowIdrBox = false
ShowIdrMidpoint = false

// ShowDrLine = input.bool(defval = true, title = "Show DR", inline = "1", group = SessionShowLines)
// ShowIdrLine = input.bool(defval = true, title = "Show IDR", inline = "1", group = SessionShowLines)
// ShowIdrBox = input.bool(defval = true, title = "Show IDR Box", inline = "1", group = SessionShowLines)
// ShowIdrMidpoint = input.bool(defval = true, title = "Show IDR Midpoint", inline = "1", group = SessionShowLines)
// DeleteMitigated = input.bool(defval = true, title = "Delete Mitigated Fractals", inline = "1", group = SessionShowLines)

DrClusters = "DR Clusters"
// ShowClusters = input.bool(defval = true, title = "Show All", inline = "1", group = DrClusters, tooltip = "Clusters work only if DR for the Session is On")
ShowClusters = false
// ShowTuesdayCluster = input.bool(defval = false, title = "Show Weekly RDR", inline = "1", group = DrClusters, tooltip = "Clusters work only if DR for the Session is On")
ShowTuesdayCluster = false
// ShowBiggestCluster = input.bool(defval = false, title = "Show Biggest RDR", inline = "1", group = DrClusters, tooltip = "Clusters work only if DR for the Session is On")
ShowBiggestCluster = false
// NumberOfClustersBack = input.int(5, title="Look For Biggest Days Back", minval=0, inline = "4", group = DrClusters)
NumberOfClustersBack = 5



ConfirmationCandles = "Base Candles"
ShowConfirmationCandles = input.bool(defval = true, title = "Show Box", inline = "1", group = ConfirmationCandles)
// ShowConfCandleBullBear = input.bool(defval = true, title = "Mark Triangle", inline = "1", group = ConfirmationCandles)
ShowConfCandleBullBear = true
// ColorConfirmationCandleDirection = input.bool(defval = true, title = "Color Direction", inline = "1", group = ConfirmationCandles)
ColorConfirmationCandleDirection = true

// ExtensionType = input.string("Session", options= ["Realtime","Session", "Manual"], inline="2", group=ConfirmationCandles, title = "Box Extension")
ExtensionType = "Session"
// ExtendConfirmationCandleFor = input.int(18, title="Manual Extend Hours:", minval=0, inline = "2", group = ConfirmationCandles)
ExtendConfirmationCandleFor = 18

// New input for extending base candles by number of sessions
ExtendBaseCandleForward = input.int(0, title="Extend Base Candle Forward (Durations):", minval=0, inline = "2", group = ConfirmationCandles, tooltip="Extends the Base Candle by N of its own original durations. Default: 0 (no extension). Example: 3 extends it by three times its original length.")

// OC Box Settings Group
OCBoxSettings = "OC Box Settings"
ShowOCBox = input.bool(defval = true, title = "Show OC Box", inline = "1", group = OCBoxSettings)
ExtendOCBoxForward = input.int(0, title="Extend OC Box Forward (Durations):", minval=0, inline = "2", group = OCBoxSettings, tooltip="Extends the OC Box by N of its own original durations. Default: 0 (no extension). Example: 3 extends it by three times its original length.")

// Base Candle Color Settings
BaseCandleBullFillColor = input.color(color.new(color.green, 90), "Bull Fill", group = ConfirmationCandles, inline = "3")
BaseCandleBullBorderColor = input.color(color.new(color.green, 50), "Bull Border", group = ConfirmationCandles, inline = "3")
BaseCandleBearFillColor = input.color(color.new(color.red, 90), "Bear Fill", group = ConfirmationCandles, inline = "4")
BaseCandleBearBorderColor = input.color(color.new(color.red, 50), "Bear Border", group = ConfirmationCandles, inline = "4")
BaseCandleInversionFillColor = input.color(color.new(color.purple, 90), "Inversion Fill", group = ConfirmationCandles, inline = "5")
BaseCandleInversionBorderColor = input.color(color.new(color.purple, 50), "Inversion Border", group = ConfirmationCandles, inline = "5")

var bool ExtendConfirmationCandle = false// input.bool(defval = true, title = "Extend Boxes", inline = "1", group = ConfirmationCandles)
var bool ManualConfirmationCandleExtension = false//input.bool(defval = true, title = "Manual Extension", inline = "2", group = ConfirmationCandles)



if ExtensionType == "Session"
    ExtendConfirmationCandle := false
    ManualConfirmationCandleExtension := false
else if ExtensionType == "Realtime"
    ExtendConfirmationCandle := true
    ManualConfirmationCandleExtension := false
else if ExtensionType == "Manual"
    ExtendConfirmationCandle := false
    ManualConfirmationCandleExtension := true 




QuantumBoxColors = "Quantum Distribution Box Colors"
// PremiumBoxColor = input.color(color.rgb(25, 4, 101, 95), title="Premium Box", inline = "1", group = QuantumBoxColors)
PremiumBoxColor = color.rgb(25, 4, 101, 95)
// PremiumBoxBorderColor = input.color(color.rgb(3, 7, 92, 50), title="Premium Border", inline = "1", group = QuantumBoxColors)
PremiumBoxBorderColor = color.rgb(3, 7, 92, 50)
// DiscountBoxColor = input.color(color.new(color.red, 95), title="Discount Box", inline = "2", group = QuantumBoxColors)
DiscountBoxColor = color.new(color.red, 95)
// DiscountBoxBorderColor = input.color(color.new(color.red, 50), title="Discount Border", inline = "2", group = QuantumBoxColors)
DiscountBoxBorderColor = color.new(color.red, 50)
// ManipulationTimeColor = input.color(#5c5c5ccc, title="Manipuliation Line Color", inline = "2", group = QuantumBoxColors)
ManipulationTimeColor = #5c5c5ccc
// DistributionTimeColor = input.color(color.rgb(82, 83, 82, 20), title="Distribution Time Color", inline = "2", group = QuantumBoxColors)
DistributionTimeColor = color.rgb(82, 83, 82, 20)
// VerticalTimeLinesStyleString = input.string(defval = "dotted", title = "Vertical Time Line Style", options = ["solid", "dotted", "dashed"], inline = "1", group = QuantumBoxColors)
VerticalTimeLinesStyleString = "dotted"

ProjectionLabelColor = PremiumBoxBorderColor

MatrixBoxColors = "Matrix Extension Box Colors"
// MatrixBoxUpColor = input.color(color.new(color.blue, 95), title="Matrix Up", inline = "1", group = MatrixBoxColors)
MatrixBoxUpColor = color.new(color.blue, 95)
// MatrixBoxUpBorderColor = input.color(color.new(color.blue, 20), title="Matrix Up Border", inline = "1", group = MatrixBoxColors)
MatrixBoxUpBorderColor = color.new(color.blue, 20)
// MatrixBoxDownColor = input.color(color.new(color.red, 95), title="Matrix Down", inline = "1", group = MatrixBoxColors)
MatrixBoxDownColor = color.new(color.red, 95)
// MatrixBoxDownBorderColor = input.color(color.new(color.red, 20), title="Matrix Down Border", inline = "1", group = MatrixBoxColors)
MatrixBoxDownBorderColor = color.new(color.red, 20)


SessionColors = "DR Line Colors"
// FractalEqLineColor = input.color(color.new(#940c9b, 34), title="Fractal EQ", inline = "1", group = SessionColors, display = display.none)
FractalEqLineColor = color.new(#940c9b, 34)
// MitigatedFractalEqLineColor = input.color(color.new(#ffffff, 100), title="Mitigated Fractal EQ", inline = "1", group = SessionColors, display = display.none)
MitigatedFractalEqLineColor = color.new(#ffffff, 100)
// OpenLineColor = input.color(color.new(#0e523b, 0), title="Open", inline = "1", group = SessionColors, display = display.none)
OpenLineColor = color.new(#0e523b, 0)
// CloseLineColor = input.color(color.new(color.red, 0), title="Close", inline = "1", group = SessionColors, display = display.none)
CloseLineColor = color.new(color.red, 0)

// FractalEqBoxUpColor = input.color(color.new(color.green, 90), title="Fractal Eq Box Up", inline = "1", group = SessionColors, display = display.none)
FractalEqBoxUpColor = color.new(color.green, 90)
// FractalEqBoxUpBorderColor = input.color(color.new(color.green, 50), title="Fractal Eq Box Up Border", inline = "1", group = SessionColors, display = display.none)
FractalEqBoxUpBorderColor = color.new(color.green, 50)
// FractalEqBoxDownColor = input.color(color.new(color.red, 90), title="Fractal Eq Box Down", inline = "1", group = SessionColors, display = display.none)
FractalEqBoxDownColor = color.new(color.red, 90)
// FractalEqBoxDownBorderColor = input.color(color.new(color.red, 50), title="Fractal Eq Box Down Border", inline = "1", group = SessionColors, display = display.none)
FractalEqBoxDownBorderColor = color.new(color.red, 50)

DrLineColor =color.new(color.gray, 0)
IdrLineColor = color.new(color.red, 20)
IdrMidpointLineColor = color.new(color.gray, 20)

// DrLineColor = input.color(color.new(color.gray, 0), title="DR Line", inline = "1", group = SessionColors)
// IdrLineColor = input.color(color.new(color.red, 20), title="IDR Line", inline = "1", group = SessionColors)
// IdrMidpointLineColor = input.color(color.new(color.gray, 20), title="IDR Midpoint", inline = "1", group = SessionColors)

IdrBoxUpColor = color.new(color.green, 90)
IdrBoxUpBorderColor = color.new(color.green, 50)
IdrBoxDownColor = color.new(color.red, 90)
IdrBoxDownBorderColor = color.new(color.red, 50)

MatrixProjectionColors = color.new(color.gray, 0)

// IdrBoxUpColor = input.color(color.new(color.green, 90), title="IDR Box Up", inline = "1", group = SessionColors)
// IdrBoxUpBorderColor = input.color(color.new(color.green, 50), title="IDR Box Up Border", inline = "1", group = SessionColors)
// IdrBoxDownColor = input.color(color.new(color.red, 90), title="IDR Box Down", inline = "1", group = SessionColors)
// IdrBoxDownBorderColor = input.color(color.new(color.red, 50), title="IDR Box Down Border", inline = "1", group = SessionColors)

// MatrixProjectionColors = input.color(color.new(color.gray, 0), title="Matrix Projection Colors", inline = "1", group = SessionColors)



ClusterColors = "Cluster Colors"
// ClusterHighColor = input.color(#022d501a, title="Cluster High Color", inline = "1", group = ClusterColors)
ClusterHighColor = #022d501a
// ClusterHighBorderColor = input.color(#9293eb80, title="Cluster High Border", inline = "1", group = ClusterColors)
ClusterHighBorderColor = #9293eb80
// ClusterLowColor = input.color(#f99d9d1a, title="Cluster Low Color", inline = "1", group = ClusterColors)
ClusterLowColor = #f99d9d1a
// ClusterLowBorderColor = input.color(#f07f7f80, title="Cluster Low Border", inline = "1", group = ClusterColors)
ClusterLowBorderColor = #f07f7f80
// TuesdayClusterHighColor = input.color(color.new(color.aqua, 80), title="Tue Cluster High Color", inline = "2", group = ClusterColors)
TuesdayClusterHighColor = color.new(color.aqua, 80)
// TuesdayClusterHighBorderColor = input.color(color.new(color.blue, 50), title="Tue Cluster High Border Color", inline = "2", group = ClusterColors)
TuesdayClusterHighBorderColor = color.new(color.blue, 50)
// TuesdayClusterLowColor = input.color(color.new(color.aqua, 80), title="Tue Cluster High Color", inline = "2", group = ClusterColors)
TuesdayClusterLowColor = color.new(color.aqua, 80) // Note: Original had "Tue Cluster High Color" as title for this one too
// TuesdayClusterLowBorderColor = input.color(color.new(color.blue, 50), title="Tue Cluster High Border Color", inline = "2", group = ClusterColors)
TuesdayClusterLowBorderColor = color.new(color.blue, 50) // Note: Original had "Tue Cluster High Border Color" as title for this one too
// LargestClusterHighColor = input.color(color.new(color.orange, 80), title="Large Cluster High Color", inline = "3", group = ClusterColors)
LargestClusterHighColor = color.new(color.orange, 80)
// LargestClusterHighBorderColor = input.color(color.new(color.red, 50), title="Large Cluster High Border Color", inline = "3", group = ClusterColors)
LargestClusterHighBorderColor = color.new(color.red, 50)
// LargestClusterLowColor = input.color(color.new(color.orange, 80), title="Large Cluster Low Color", inline = "3", group = ClusterColors)
LargestClusterLowColor = color.new(color.orange, 80)
// LargestClusterLowBorderColor = input.color(color.new(color.red, 50), title="Large Cluster Low Border Color", inline = "3", group = ClusterColors)
LargestClusterLowBorderColor = color.new(color.red, 50)

DrLineStyles = "Line Styles"
// FractalEqLineStyleString = input.string(defval = "solid", title = "Fractal EQ Line Style", options = ["solid", "dotted", "dashed"], inline = "1", group = DrLineStyles, display = display.none)
FractalEqLineStyleString = "solid"
// OpenEqLineStyleString = input.string(defval = "solid", title = "Open Line Style", options = ["solid", "dotted", "dashed"], inline = "1", group = DrLineStyles, display = display.none)
OpenEqLineStyleString = "solid"
// CloseEqLineStyleString = input.string(defval = "solid", title = "Close Line Style", options = ["solid", "dotted", "dashed"], inline = "1", group = DrLineStyles, display = display.none)
CloseEqLineStyleString = "solid"

DrLineLineStyleString = "solid"
IdrLineLineStyleString = "dashed"
IdrMidpointLineStyleString = "dotted"
// DrLineLineStyleString = input.string(defval = "solid", title = "DR Line Style", options = ["solid", "dotted", "dashed"], inline = "1", group = DrLineStyles)
// IdrLineLineStyleString = input.string(defval = "dashed", title = "IDR Line Style", options = ["solid", "dotted", "dashed"], inline = "1", group = DrLineStyles)
// IdrMidpointLineStyleString = input.string(defval = "dotted", title = "IDR Midpoint Line Style", options = ["solid", "dotted", "dashed"], inline = "1", group = DrLineStyles)

KeyCandles = "Key Candles"

ShowKeyCandles = false
ShowNofKeyCandles = 3

HtfLiquidity = "HTF Liquidity"
ShowLiquidityLines = 0
ShowOnlyLastHftLowHigh = false
ShowKeyTfLabels = false
ExtendUnmitigatedHL = false
RemovePurgedHtfLiquidityLine = false
KeyTimeframe = "210"
ShowPurgeLabel = false
PurgedLabelHistory = 100
DaysOfLiquidityForCalculation = 1
// ShowKeyCandles =  input.bool(title="Show Key Candles", defval=false, inline="1", group=KeyCandles, tooltip="Show Key Candles")
// ShowNofKeyCandles = input.int(3, title="Number of Key Candles", minval=0, inline = "1", group = KeyCandles)

// HtfLiquidity = "HTF Liquidity"
// ShowLiquidityLines = input.bool(false, "Show HTF H&L", tooltip = "Show HTF Highs and Lows", inline = "1", group = HtfLiquidity)
// ShowOnlyLastHftLowHigh = input.bool(false, "Show Only Last H&L", tooltip = "Show HTF previous High and Low", inline = "1", group = HtfLiquidity)
// ShowKeyTfLabels = input.bool(false, "Show HTF Labels", tooltip = "Show HTF Labels", inline = "1", group = HtfLiquidity)
// ExtendUnmitigatedHL = input.bool(false, "Extend Unmitigated", tooltip = "Extend Unmitigated", inline = "1", group = HtfLiquidity)
// RemovePurgedHtfLiquidityLine = input.bool(false, "Remove Purged H&L", tooltip = "Remove Purged HTF H&L", inline = "1", group = HtfLiquidity)
// KeyTimeframe = input.timeframe("210", "HTF Liquidity TF", tooltip = "Select which timeframe should be displayed with their highs and lows", inline = "2", group = HtfLiquidity)
// ShowPurgeLabel = input.bool(true, "Show Purge Label", tooltip = "Show Purge Label with Liquidity Time", inline = "1", group = HtfLiquidity)
// PurgedLabelHistory = 100
// DaysOfLiquidityForCalculation = 1


HtfColors = "HTF Colors"
// KeyHighLineColor = input.color(color.new(color.blue, 20), title="High", inline = "1", group = HtfColors)
// KeyCandleHighPurgedLineColor = input.color(color.new(color.blue, 70), title="High Purged", inline = "1", group = HtfColors)
// KeyLowLineColor = input.color(color.new(color.red, 20), title="Low", inline = "1", group = HtfColors)
// KeyCandleLowPurgedLineColor = input.color(color.new(color.red, 70), title="Low Purged", inline = "1", group = HtfColors)

KeyHighLineColor = color.new(color.blue, 20)
KeyCandleHighPurgedLineColor = color.new(color.blue, 70)
KeyLowLineColor = color.new(color.red, 20)
KeyCandleLowPurgedLineColor = color.new(color.red, 70)



// DIBs
ShowDIBs = false



// START Key Candles Hidden Parameters

KeyHighLowStyle = line.style_dashed
KeyHighLowWidth = 1
KeyNumberOfHistoricalHLDaysBack = 9

KeyCandlesBullBorderSize  = 1
KeyCandlesBullBoxColor  = color.new(color.green, 95)
KeyCandlesBullBoxBorderColor  =color.new(color.green, 40)
KeyCandleLineStyleBull = line.style_dotted
KeyCandleLineColorBull = color.new(color.green, 40)

KeyCandlesBearBoxColor  = color.new(color.red, 95)
KeyCandlesBearBoxBorderColor  = color.new(color.red, 40)
KeyCandlesBearBorderSize  = 1

KeyCandleLineStyleBear =line.style_dotted
KeyCandleLineColorBear = color.new(color.red, 40)

KeyCandlesInversionBoxColor  = color.new(color.purple, 95)
KeyCandlesInversionBoxBorderColor  = color.new(color.purple, 40)

ShowKeyCandlesMidpoints = true
ExtendKeyCandlesForNHours = 6
ExtendKeyCandleBoxesInRealtime = true

// END Key Candles Hidden Parameters


// START Confirmation Candle Hidden Parameters
TransparentCollorFill = 90
TransparentColorBorder = 50

var int BoxBull_Border_Size = 1
var color BoxBull_Fill_Color = BaseCandleBullFillColor
var color BoxBull_Border_Color = BaseCandleBullBorderColor
	
var int BoxBear_Border_Size = 1
var color BoxBear_Fill_Color = BaseCandleBearFillColor
var color BoxBear_Border_Color = BaseCandleBearBorderColor

var int BoxPotential_Border_Size = 1
var color BoxPotential_Fill_Color = color.new(color.gray, TransparentCollorFill)
var color BoxPotential_Border_Color = color.new(color.gray, TransparentColorBorder)	


var int BoxInversion_Border_Size = 1
var color BoxInversion_Fill_Color = BaseCandleInversionFillColor
var color BoxInversion_Border_Color = BaseCandleInversionBorderColor

ConfirmationShapeBullColor = color.new(color.green, 0)
ConfirmationShapeBearColor = color.new(color.red, 0)


// Table
// TableBackgroundColor = input.color(color.new(#888a8a, 100), title="Background Color", group = "Table")
TableBackgroundColor = color.new(#888a8a, 100)
// TableTextColor = input.color(color.new(color.gray, 0), title="Text Color", group = "Table")
TableTextColor = color.new(color.gray, 0)
// TableFrameColor = input.color(color.new(color.gray, 75), title="Frame Color", group = "Table")
TableFrameColor = color.new(color.gray, 75)
// TableBorderColor = input.color(color.new(color.gray, 75), title="Frame Color", group = "Table")
TableBorderColor = color.new(color.gray, 75)
// TableBorderWidth = input.int(1, title="Table Border Width", minval=0, group = "Table")
TableBorderWidth = 1
// TableFrameWidth = input.int(1, title="Table Frame Width", minval=0, group = "Table")
TableFrameWidth = 1
// TableTextSizeOptions = input.string(defval="Tiny", title="Font Size", options=['Auto', 'Tiny', 'Small', 'Normal', 'Large', 'HUGE'], tooltip="Select Analysis Table Font Size", inline="3", group="Table")
TableTextSizeOptions = "Tiny"
TableTextSize = TableTextSizeOptions == "Auto" ? size.auto : TableTextSizeOptions == "Tiny" ? size.tiny : TableTextSizeOptions == "Small" ? size.small : TableTextSizeOptions == "Normal" ? size.normal : TableTextSizeOptions == "Large" ? size.large : TableTextSizeOptions == "HUGE" ? size.huge :"End"
// TablePositionRaw = input.string("Bottom Right", options=["Top Left", "Top Center", "Top Right","Middle Left","Middle Center","Middle Right","Bottom Left","Bottom Center","Bottom Right"], inline="3", group="Table", title = "Position")
TablePositionRaw = "Bottom Right"
TablePosition = TablePositionRaw=="Top Left" ? position.top_left : TablePositionRaw=="Top Center" ? position.top_center : TablePositionRaw=="Top Right" ? position.top_right: TablePositionRaw=="Middle Left" ? position.middle_left : TablePositionRaw=="Middle Center" ? position.middle_center : TablePositionRaw=="Middle Right" ? position.middle_right : TablePositionRaw=="Bottom Left" ? position.bottom_left : TablePositionRaw=="Bottom Center" ? position.bottom_center : position.bottom_right

var Table = table.new(columns = 10, rows = 20, bgcolor = TableBackgroundColor,frame_color = TableFrameColor, border_width = TableBorderWidth, position = TablePosition, frame_width = TableFrameWidth, border_color = TableBorderColor)

// Sub Base Model Table Setup
SubBaseModelTablePositionConverted = SubBaseModelTablePosition=="Top Left" ? position.top_left : SubBaseModelTablePosition=="Top Center" ? position.top_center : SubBaseModelTablePosition=="Top Right" ? position.top_right: SubBaseModelTablePosition=="Middle Left" ? position.middle_left : SubBaseModelTablePosition=="Middle Center" ? position.middle_center : SubBaseModelTablePosition=="Middle Right" ? position.middle_right : SubBaseModelTablePosition=="Bottom Left" ? position.bottom_left : SubBaseModelTablePosition=="Bottom Center" ? position.bottom_center : position.bottom_right

SubBaseModelTableTextSizeConverted = SubBaseModelTableTextSize == "Tiny" ? size.tiny : SubBaseModelTableTextSize == "Small" ? size.small : SubBaseModelTableTextSize == "Normal" ? size.normal : SubBaseModelTableTextSize == "Large" ? size.large : size.tiny

var SubBaseModelTable = table.new(columns = 11, rows = SubBaseModelTableMaxRows + 2, bgcolor = SubBaseModelTableBgColor, frame_color = SubBaseModelTableBorderColor, border_width = 1, position = SubBaseModelTablePositionConverted, frame_width = 1, border_color = SubBaseModelTableBorderColor)

// Advanced Analytics Table Setup
SubBaseModelAdvancedTablePositionConverted = SubBaseModelAdvancedTablePosition=="Top Left" ? position.top_left : SubBaseModelAdvancedTablePosition=="Top Center" ? position.top_center : SubBaseModelAdvancedTablePosition=="Top Right" ? position.top_right: SubBaseModelAdvancedTablePosition=="Middle Left" ? position.middle_left : SubBaseModelAdvancedTablePosition=="Middle Center" ? position.middle_center : SubBaseModelAdvancedTablePosition=="Middle Right" ? position.middle_right : SubBaseModelAdvancedTablePosition=="Bottom Left" ? position.bottom_left : SubBaseModelAdvancedTablePosition=="Bottom Center" ? position.bottom_center : position.bottom_right

var SubBaseModelAdvancedTable = table.new(columns = 25, rows = SubBaseModelAdvancedTableMaxRows + 2, bgcolor = SubBaseModelTableBgColor, frame_color = SubBaseModelTableBorderColor, border_width = 1, position = SubBaseModelAdvancedTablePositionConverted, frame_width = 1, border_color = SubBaseModelTableBorderColor)


// END Table


// END Confirmation Candle Hidden Parameters

// Helper functions for Sub Base Model calculations
calculateBoxHeight(startY, endY) =>
    math.abs(endY - startY)

calculateBoxHeightPercent(startY, endY) =>
    if startY > 0
        (math.abs(endY - startY) / startY) * 100
    else
        0.0

getSizeCategory(heightPercent) =>
    if heightPercent <= SubBaseModelSmallSizeThresholdPercent
        "Small"
    else if heightPercent <= SubBaseModelMediumSizeThresholdPercent
        "Medium"
    else
        "Large"

formatTimeElapsed(startTime, currentTime) =>
    elapsedMs = currentTime - startTime
    elapsedHours = elapsedMs / 3600000
    if elapsedHours < 1
        str.tostring(math.round(elapsedMs / 60000)) + "m"
    else if elapsedHours < 24
        str.tostring(math.round(elapsedHours * 10) / 10) + "h"
    else
        str.tostring(math.round(elapsedHours / 24 * 10) / 10) + "d"

abbreviateAnchorType(anchorType) =>
    switch anchorType
        "Base Open to Base Open" => "BOBO"
        "Base Close to Base Close" => "BCBC"
        "Session Open to Session Open" => "SOSO"
        "Session Close to Session Close" => "SCSC"
        "Base Open to Session Open" => "BOSO"
        "Distro Close to Distro Close" => "DCDC"
        "Session Body" => "SB"
        "Base Body" => "BB"
        "Fractal EQ to Fractal EQ" => "FEQ"
        => anchorType // fallback to original if no match

// Priority 2 - Advanced calculation functions
calculateCurrentBoxPosition(subModel) =>
    if not na(subModel.StartY) and not na(subModel.EndY) and subModel.StartY != subModel.EndY
        boxRange = math.abs(subModel.EndY - subModel.StartY)
        boxBottom = math.min(subModel.StartY, subModel.EndY)
        priceFromBottom = close - boxBottom
        math.max(0, math.min(100, (priceFromBottom / boxRange) * 100))
    else
        50.0 // Default to middle if can't calculate

calculateMitigationSpeed(subModel) =>
    if not na(subModel.MitigationTime) and not na(subModel.CreationTime)
        (subModel.MitigationTime - subModel.CreationTime) / 60000 // Convert to minutes
    else
        na

calculateMarketVolatility(subModel) =>
    // Simple volatility calculation using high-low range
    if not na(subModel.HighestPrice) and not na(subModel.LowestPrice) and subModel.LowestPrice > 0
        ((subModel.HighestPrice - subModel.LowestPrice) / subModel.LowestPrice) * 100
    else
        na

calculateEfficiencyRatio(subModel) =>
    // Efficiency = Net movement / Total movement
    if not na(subModel.HighestPrice) and not na(subModel.LowestPrice) and not na(subModel.AveragePrice)
        totalMovement = subModel.HighestPrice - subModel.LowestPrice
        netMovement = math.abs(close - subModel.AveragePrice)
        if totalMovement > 0
            netMovement / totalMovement
        else
            0.0
    else
        na

getSessionNameFromObject(sessionObj) =>
    if not na(sessionObj) and not na(sessionObj.BaseSessionName)
        sessionObj.BaseSessionName
    else
        "Unknown"

getSessionDirectionFromObject(sessionObj) =>
    if not na(sessionObj) and not na(sessionObj.ConfirmationDirectionDr)
        sessionObj.ConfirmationDirectionDr
    else
        "None"

getSessionEqStatusFromObject(sessionObj) =>
    if not na(sessionObj) and not na(sessionObj.BelowAbove)
        sessionObj.BelowAbove
    else
        "Unknown"

calculateDirectionalAgreement(startDirection, endDirection) =>
    if startDirection == "Long" and endDirection == "Long"
        true
    else if startDirection == "Short" and endDirection == "Short"
        true
    else
        false

getDayOfWeekString(timeValue) =>
    dayNum = dayofweek(timeValue)
    switch dayNum
        dayofweek.sunday => "Sun"
        dayofweek.monday => "Mon"
        dayofweek.tuesday => "Tue"
        dayofweek.wednesday => "Wed"
        dayofweek.thursday => "Thu"
        dayofweek.friday => "Fri"
        dayofweek.saturday => "Sat"
        => "Unknown"



calculateOverlapCount(currentSubModel, allSubModels) =>
    overlapCount = 0
    if array.size(allSubModels) > 0
        for i = 0 to array.size(allSubModels) - 1
            otherModel = array.get(allSubModels, i)
            // Compare using unique combination of start time, end time, and preset number
            if not (otherModel.StartTime == currentSubModel.StartTime and otherModel.EndTime == currentSubModel.EndTime and otherModel.PresetNumber == currentSubModel.PresetNumber)
                // Check for time overlap
                if currentSubModel.StartTime <= otherModel.EndTime and currentSubModel.EndTime >= otherModel.StartTime
                    // Check for price overlap
                    currentTop = math.max(currentSubModel.StartY, currentSubModel.EndY)
                    currentBottom = math.min(currentSubModel.StartY, currentSubModel.EndY)
                    otherTop = math.max(otherModel.StartY, otherModel.EndY)
                    otherBottom = math.min(otherModel.StartY, otherModel.EndY)
                    
                    if currentBottom <= otherTop and currentTop >= otherBottom
                        overlapCount := overlapCount + 1
    overlapCount

updateSubBaseModelData(subModel) =>
    // Update real-time tracking data
    if not na(subModel.EqValue)
        // Track highest and lowest prices
        subModel.HighestPrice := math.max(subModel.HighestPrice, high)
        subModel.LowestPrice := math.min(subModel.LowestPrice, low)
        
        // Update average price (running average)
        if na(subModel.AveragePrice)
            subModel.AveragePrice := close
        else
            subModel.AveragePrice := (subModel.AveragePrice + close) / 2
        
        // Track deviations from EQ
        if high > subModel.EqValue
            subModel.MaxDeviationAbove := math.max(subModel.MaxDeviationAbove, high - subModel.EqValue)
            subModel.MaxFavorable := math.max(subModel.MaxFavorable, high - subModel.EqValue)
        if low < subModel.EqValue
            subModel.MaxDeviationBelow := math.max(subModel.MaxDeviationBelow, subModel.EqValue - low)
            subModel.MaxDrawdown := math.max(subModel.MaxDrawdown, subModel.EqValue - low)
        
        // Track EQ touches (within small tolerance)
        tolerance = (subModel.EndY - subModel.StartY) * 0.01 // 1% of box height
        if math.abs(close - subModel.EqValue) <= tolerance
            subModel.EqTouches := subModel.EqTouches + 1
            if na(subModel.TimeToFirstTouch)
                subModel.TimeToFirstTouch := time - subModel.CreationTime
        
        // Track time above/below EQ
        if close > subModel.EqValue
            subModel.TimeAboveEq := subModel.TimeAboveEq + 1
        else if close < subModel.EqValue
            subModel.TimeBelowEq := subModel.TimeBelowEq + 1
        
        // Track mitigation time and retest behavior
        if subModel.BelowAbove == "Mitigated" and na(subModel.MitigationTime)
            subModel.MitigationTime := time
            subModel.MitigationSpeed := calculateMitigationSpeed(subModel)
        
        // Track retests after mitigation
        if not na(subModel.MitigationTime) and math.abs(close - subModel.EqValue) <= tolerance
            if not subModel.HasRetested
                subModel.HasRetested := true
                subModel.RetestCount := 1
            else
                subModel.RetestCount := subModel.RetestCount + 1
            subModel.LastRetestTime := time
        
        // Update current box position
        subModel.CurrentBoxPosition := calculateCurrentBoxPosition(subModel)
        
        // Update market volatility
        subModel.MarketVolatility := calculateMarketVolatility(subModel)
        
        // Update efficiency ratio
        subModel.EfficiencyRatio := calculateEfficiencyRatio(subModel)
        
        // Update price standard deviation (simple calculation)
        if not na(subModel.AveragePrice) and not na(subModel.HighestPrice) and not na(subModel.LowestPrice)
            priceRange = subModel.HighestPrice - subModel.LowestPrice
            subModel.PriceStandardDev := priceRange / 4 // Simplified std dev approximation

FunctionLineStyle(_Style) =>
    switch _Style
        "dotted" => line.style_dotted
        "dashed" => line.style_dashed
        => line.style_solid




FractalEqLineStyle = FunctionLineStyle(FractalEqLineStyleString)
DrLineLineStyle = FunctionLineStyle(DrLineLineStyleString)
IdrLineLineStyle = FunctionLineStyle(IdrLineLineStyleString)
OpenEqLineStyle = FunctionLineStyle(OpenEqLineStyleString)
CloseEqLineStyle = FunctionLineStyle(CloseEqLineStyleString)
IdrMidpointLineStyle = FunctionLineStyle(IdrMidpointLineStyleString)
VerticalTimeLinesStyle = FunctionLineStyle(VerticalTimeLinesStyleString)
SubBaseModelEqLineStyle = FunctionLineStyle(SubBaseModelEqLineStyleString) // New line style for Sub Base Model EQ

// } -------- END INPUTS --------

// { -------- START VARIABLES --------
var string Timezone = na
var bool DST = na
// Rgray => got it from stackoverflow
int HourNY = hour(time, "America/New_York")
int HourUTC = hour(time, "UTC")
DST := HourUTC - HourUTC == 5 ? false : true
DST := HourUTC - HourNY == 5 or HourUTC - HourNY == -19 ? false : HourUTC - HourNY == 4 or HourUTC - HourNY == -20 ? true : na
if DST
    Timezone := "UTC-4:00"    
else
    Timezone := "UTC-5:00"


var string CurrentTicker = na
var bool NeedsOffset = false
var int TickerTimeOffset = na
var int TickerHourOffset = na

if str.startswith(syminfo.ticker, "CL")
    CurrentTicker := "CL"
else if str.startswith(syminfo.ticker, "SPGSCI")
    CurrentTicker := "SPGSCI"
else if str.startswith(syminfo.ticker, "GC")
    CurrentTicker := "GC"
else if str.startswith(syminfo.ticker, "NG")
    CurrentTicker := "NG"
else if str.startswith(syminfo.ticker, "SI")
    CurrentTicker := "SI"
else if str.startswith(syminfo.ticker, "HG")
    CurrentTicker := "HG"
else if str.startswith(syminfo.ticker, "PL")
    CurrentTicker := "PL"
else if str.startswith(syminfo.ticker, "ZW")
    CurrentTicker := "ZW"
else if str.startswith(syminfo.ticker, "ZS")
    CurrentTicker := "ZS"
else if str.startswith(syminfo.ticker, "ZC")
    CurrentTicker := "ZC"
else if str.startswith(syminfo.ticker, "HE")
    CurrentTicker := "HE"
else if str.startswith(syminfo.ticker, "LE")
    CurrentTicker := "LE"
else if str.startswith(syminfo.ticker, "GF")
    CurrentTicker := "GF"
else if str.startswith(syminfo.ticker, "ZB")
    CurrentTicker := "ZB"
else if str.startswith(syminfo.ticker, "ZN")
    CurrentTicker := "ZN"
else if str.startswith(syminfo.ticker, "ZF")
    CurrentTicker := "ZF"
else if str.startswith(syminfo.ticker, "NQ")
    CurrentTicker := "NQ"
else if str.startswith(syminfo.ticker, "ES")
    CurrentTicker := "ES"
else if str.startswith(syminfo.ticker, "YM")
    CurrentTicker := "YM"
else if str.startswith(syminfo.ticker, "RTY")
    CurrentTicker := "RTY"
else if str.contains(syminfo.ticker, "BTC")
    CurrentTicker := "BTC"
else if str.contains(syminfo.ticker, "ETH")
    CurrentTicker := "ETH"

if CurrentTicker == "CL" or CurrentTicker == "SPGSCI" or CurrentTicker == "GC" or CurrentTicker == "NG" or CurrentTicker == "SI" or CurrentTicker == "HG" or CurrentTicker == "PL" or CurrentTicker == "HE" or CurrentTicker == "LE" or CurrentTicker == "GF"
    NeedsOffset := false
    TickerHourOffset := 0
    TickerTimeOffset := 0 
else
    NeedsOffset := true
    TickerHourOffset := 1
    TickerTimeOffset := 3600000


var array<float> ArrayOfMatrixRanges = array.from(1.66,2.67,3.67,4.66,7.14,9.34,14.28,18.68,-0.66,-1.67,-2.67,-3.67,-6.14,-8.34,-13.28,-17.68)

type LineWithLabel
    line Line
    label Label

type BoxWithLines
    array<box> Boxes
    array<line> Lines

type MatrixBox
    float Value
    bool Drawn

type SessionObject
    line Open
    line Close
    line FractalEq
    line DrHigh
    line DrLow
    line IdrHigh
    line IdrLow
    line IdrMidpoint
    box CloseBox 
    box IdrBox   
    float EqValue	
    string BelowAbove
    int OpenTime
    box ConfirmationCandle
    line ConfirmationCandleMidline
    float ConfirmationMidpointValue
    string ConfirmationDirection
    float ConfirmationCandleHighValue
    float ConfirmationCandleLowValue
    float HighFractal
    float LowFractal
    int CycleEndTimeFractal
    bool SessionConfirmedFractal
	string ConfirmationDirectionDr
    string SessionConfirmationFractal
    string AfterSessionState
    box ClusterHigh
    box ClusterLow
    line ClusterHighMidpoint
    line ClusterLowMidpoint
    float CloseHigh
    float CloseLow
    array<MatrixBox> MatrixBoxValuesUp
    array<MatrixBox> MatrixBoxValuesDown
    BoxWithLines ProjectionBoxes
    float OpenValue
    float CloseValue
    float FirstCandleHigh
    float FirstCandleLow
    int ConfirmationTimeValue // New field for storing the exact confirmation time
    string BaseSessionName     // New field for storing the original session name (e.g., "Alpha")
    float ConfirmationCandleOpenValue // NEW
    float ConfirmationCandleCloseValue // NEW
    float DistributionCloseValue // NEW – closing price at distribution end
    int   DistributionTimeValue      // NEW – exact bar time of distribution close
    int   FractalSessionEndTimeActual // NEW - actual end time of the fractal calculation period


type SessionDataObject
    string Name
    string SesionString
    string SessionConfirmation
    string SessionState
    float Open
    float High
    float Low
    float Close
    float CloseHigh
    float CloseLow
    int OpenTime
    int CloseTime
    string ConfirmedDirection
    bool FractalDrawn
    int CycleEndTime
    bool SessionConfirmed = na
	string ConfirmationDirection = na
    bool ShowMatrixProjections
    array<MatrixBox> UpperBoxValue
    array<MatrixBox> LowerBoxValue  
    array<LineWithLabel> MatrixProjections
    float FirstCandleHigh
    float FirstCandleLow

    
    
    
type SubBaseModelObject
    string Name // e.g., "Sub Alpha-Bravo"
    int StartTime
    int EndTime
    float StartY // Price level for the bottom of the box (used as 'bottom' in box.new)
    float EndY   // Price level for the top of the box (used as 'top' in box.new)
    float EqValue // Calculated EQ for this sub-model
    box DisplayBox // For drawing
    line EqLine    // For drawing the EQ line
    string BelowAbove // NEW: Tracks price relative to EqValue ("Above", "Below", "Mitigated")
    int PresetNumber // NEW: 1 for first preset, 2 for second preset
    // Additional fields for table data
    string AnchorType // The preset name used to create this model
    float BoxHeight // Height in price points
    float BoxHeightPercent // Height as percentage of start price
    string SizeCategory // "Small", "Medium", "Large"
    int CreationTime // When this model was created
    float HighestPrice // Highest price reached within timeframe
    float LowestPrice // Lowest price reached within timeframe
    int EqTouches // Number of times price touched EQ line
    float MaxDeviationAbove // Maximum distance above EQ
    float MaxDeviationBelow // Maximum distance below EQ
    int MitigationTime // When EQ was mitigated (if applicable)
    float TimeAboveEq // Time spent above EQ (in bars)
    float TimeBelowEq // Time spent below EQ (in bars)
    // Priority 2 - Extended Analysis Data
    // Performance Tracking
    float MitigationSpeed // Time from creation to mitigation (in bars)
    float CurrentBoxPosition // Current price position within box (0-100%)
    // Source Session Data
    string StartSessionName // Name of the starting session
    string EndSessionName // Name of the ending session
    string StartSessionDirection // Confirmation direction of start session
    string EndSessionDirection // Confirmation direction of end session
    bool DirectionalAgreement // Whether both sessions agree on direction
    string StartSessionEqStatus // EQ mitigation status of start session
    string EndSessionEqStatus // EQ mitigation status of end session
    // Market Context
    string DayOfWeekCreated // Day of week when created
    string SessionOverlapInfo // Information about session overlaps
    float MarketVolatility // Volatility during the period
    float AveragePrice // Average price during timeframe
    float PriceStandardDev // Standard deviation of prices
    // Real-time Metrics
    int RetestCount // Number of times EQ was retested
    float FollowThroughStrength // Strength of follow-through after mitigation
    bool HasRetested // Whether EQ has been retested after mitigation
    float LastRetestTime // Time of last retest
    // Relationship Data
    int OverlapCount // Number of overlapping sub base models
    float ProximityToKeyLevels // Distance to nearest key level
    float MarketCorrelation // Correlation with overall market direction
    // Additional Performance Metrics
    float MaxDrawdown // Maximum adverse movement
    float MaxFavorable // Maximum favorable movement
    float EfficiencyRatio // Price movement efficiency
    float TimeToFirstTouch // Time to first EQ touch
    float AverageReturnToEq // Average time to return to EQ after deviation

type DistributionCloseCandle
    box CandleBox
    line MidpointLine
    float MidpointValue
    float HighValue
    float LowValue
    int TimeValue
    string Direction // "Bull", "Bear", or "Doji"
    string BaseModel // Which base model this candle belongs to

// NEW: Base to Distribution Connection Type
type BaseToDistributionConnection
    box ConnectionBox
    line ConnectionLine
    float HighestHigh // Highest high between base candle and distribution candle
    float LowestLow   // Lowest low between base candle and distribution candle
    float BaseCandleHigh
    float BaseCandleLow
    float DistCandleHigh
    float DistCandleLow
    int BaseCandleTime
    int DistCandleTime
    string BaseModel // Which base model this connection belongs to
    string Direction // "Bull", "Bear", or "Mixed"
    bool IsActive    // Whether this connection is still being tracked

var int NumberOfSessionsToShow = 0 // Corrected: This is now on its own line

var array<SessionObject> ArrayOfFractalObjects = array.new<SessionObject>()
var array<SessionDataObject> ArrayOfSessionDataObjects = array.new<SessionDataObject>()

var array<SubBaseModelObject> ArrayOfSubBaseModels = array.new<SubBaseModelObject>() // New array for Sub Base Models

var array<DistributionCloseCandle> ArrayOfDistributionCloseCandles = array.new<DistributionCloseCandle>()

// NEW: Array for Base to Distribution Connections
var array<BaseToDistributionConnection> ArrayOfBaseToDistConnections = array.new<BaseToDistributionConnection>()

// Sub Base Model AMD (Accumulation, Manipulation, Distribution) Arrays
var array<float> ArraySubBaseModelManipulation = array.new<float>()
var array<float> ArraySubBaseModelDistribution = array.new<float>()
var array<int> ArraySubBaseModelManipulationTime = array.new<int>()
var array<int> ArraySubBaseModelDistributionTime = array.new<int>()
var array<string> ArraySubBaseModelNames = array.new<string>()

// Sub Base Model AMD Calculation Functions
calculateSubBaseModelAMD(subModel) =>
    // Calculate manipulation and distribution based on Sub Base Model range
    float openPrice = (subModel.StartY + subModel.EndY) / 2  // Use EQ as "open"
    float highPrice = subModel.EndY  // Top of box
    float lowPrice = subModel.StartY   // Bottom of box
    float closePrice = close  // Current close
    
    // Calculate manipulation and distribution similar to base sessions
    float manipulation = na
    float distribution = na
    int manipulationTime = na
    int distributionTime = na
    
    if closePrice >= openPrice
        // Bullish: manipulation is downward, distribution is upward
        manipulation := openPrice - lowPrice
        distribution := highPrice - openPrice
        manipulationTime := int((subModel.EndTime - subModel.StartTime) * 0.3) // 30% of timeframe
        distributionTime := int((subModel.EndTime - subModel.StartTime) * 0.7) // 70% of timeframe
    else
        // Bearish: manipulation is upward, distribution is downward
        manipulation := highPrice - openPrice
        distribution := openPrice - lowPrice
        manipulationTime := int((subModel.EndTime - subModel.StartTime) * 0.3) // 30% of timeframe
        distributionTime := int((subModel.EndTime - subModel.StartTime) * 0.7) // 70% of timeframe
    
    [manipulation, distribution, manipulationTime, distributionTime]

// Function to maintain Sub Base Model AMD arrays
maintainSubBaseModelAMDArrays(manipulation, distribution, manipulationTime, distributionTime, modelName) =>
    array.push(ArraySubBaseModelManipulation, manipulation)
    array.push(ArraySubBaseModelDistribution, distribution)
    array.push(ArraySubBaseModelManipulationTime, manipulationTime)
    array.push(ArraySubBaseModelDistributionTime, distributionTime)
    array.push(ArraySubBaseModelNames, modelName)
    
   


// Distribution Close Times mapped to Base Models with correct fractal closing times
// Main sequence: Alpha->Bravo->Delta->Echo->Foxtrot->Golf->Hotel->India->Juliet
// DR sequence: ADR->ODR->RDR->ADR (cycle)  
// HTF sequence: Charlie->Kilo->Lima->Charlie (cycle)
var array<string> DistributionCloseTimes = array.from("2115", "0000", "0245", "0545", "0815", "1115", "1400", "1445", "1645", "0200", "0830", "1600", "0245", "1600", "1645")
var array<string> DistributionCloseBaseModels = array.from("Alpha", "Bravo", "Delta", "Echo", "Foxtrot", "Golf", "Hotel", "India", "Juliet", "ADR", "ODR", "RDR", "Charlie", "Kilo", "Lima")

// Extension times - each candle extends to the fractal closing time of the next session
// Alpha(2115)->Bravo(2220), Bravo(0000)->Delta(0105), Delta(0245)->Echo(0355), Echo(0545)->Foxtrot(0650)
// Foxtrot(0815)->Golf(0935), Golf(1115)->Hotel(1220), Hotel(1400)->1440, India(1445)->Juliet(1505), Juliet(1645)->Alpha(1935)
// ADR(0200)->ODR(0400), ODR(0830)->RDR(1030), RDR(1600)->ADR(2030), Charlie(0245)->Kilo(0935), Kilo(1600)->Lima(1235), Lima(1645)->Charlie(2235)
var array<string> DistributionExtensionTimes = array.from("2220", "0105", "0355", "0650", "0935", "1220", "1440", "1645", "1935", "0400", "1030", "2030", "0935", "1235", "2235")

var array<SessionObject> ArrayOfClusterRdrObjects = array.new<SessionObject>()
// var SessionObject CurrentBiggestRdr = na




var array<MatrixBox> ArrayUpperBoxValue = array.from(MatrixBox.new(74.708, true),MatrixBox.new(37.354, false),MatrixBox.new(18.68, false),MatrixBox.new(9.34, false), MatrixBox.new(4.66, false),MatrixBox.new(-0.66, false),MatrixBox.new(-6.14, na),MatrixBox.new(-13.28, na),MatrixBox.new(-27.5592, na),MatrixBox.new(-55.1184, na))
var array<MatrixBox> ArrayLowerBoxValue = array.from(MatrixBox.new(57.1184, na),MatrixBox.new(28.5592, na),MatrixBox.new(14.28, na), MatrixBox.new(7.14, na),MatrixBox.new(1.66, false),MatrixBox.new(-3.66, false),MatrixBox.new(-8.34, false),MatrixBox.new(-17.68, false),MatrixBox.new(-36.354, false),MatrixBox.new(-73.708, true))


if barstate.isfirst
    if ShowADRQ1Dr  
        array.push(ArrayOfSessionDataObjects, SessionDataObject.new("Alpha","1845-1930","1930-2100","NotInSession",na,na,na,na,na,na,na,na,na,false, timestamp(Timezone, year, month, dayofmonth, 21, 0),false,na,ShowADRQ1DrProjection,na,na,na,na,na)),NumberOfSessionsToShow := NumberOfSessionsToShow+1
    if ShowADRDr
        array.push(ArrayOfSessionDataObjects, SessionDataObject.new("ADR","1930-2130","2130-0200","NotInSession",na,na,na,na,na,na,na,na,na,false, timestamp(Timezone, year, month, dayofmonth, 2, 0),false,na,ShowADRDrProjection,na,na,na,na,na)),NumberOfSessionsToShow := NumberOfSessionsToShow+1
    if ShowADRQ2Dr
        array.push(ArrayOfSessionDataObjects, SessionDataObject.new("Bravo","2130-2230","2230-0000","NotInSession",na,na,na,na,na,na,na,na,na,false, timestamp(Timezone, year, month, dayofmonth, 0, 0),false,na,ShowADRQ2DrProjection,na,na,na,na,na)),NumberOfSessionsToShow := NumberOfSessionsToShow+1
    if ShowADRQ3Dr
        array.push(ArrayOfSessionDataObjects, SessionDataObject.new("Charlie","2230-0030","0030-0245","NotInSession",na,na,na,na,na,na,na,na,na,false, timestamp(Timezone, year, month, dayofmonth, 2, 45),false,na,ShowADRQ3DrProjection,na,na,na,na,na)),NumberOfSessionsToShow := NumberOfSessionsToShow+1
    if ShowADRQ4Dr
        array.push(ArrayOfSessionDataObjects, SessionDataObject.new("Delta","0030-0130","0130-0245","NotInSession",na,na,na,na,na,na,na,na,na,false, timestamp(Timezone, year, month, dayofmonth, 2, 45),false,na,ShowADRQ4DrProjection,na,na,na,na,na)),NumberOfSessionsToShow := NumberOfSessionsToShow+1
    if ShowODRQ1Dr
        array.push(ArrayOfSessionDataObjects, SessionDataObject.new("Echo","0300-0400","0400-0545","NotInSession",na,na,na,na,na,na,na,na,na,false, timestamp(Timezone, year, month, dayofmonth, 5, 45),false,na,ShowODRQ1DrProjection,na,na,na,na,na)),NumberOfSessionsToShow := NumberOfSessionsToShow+1
    if ShowODRDr
        array.push(ArrayOfSessionDataObjects, SessionDataObject.new("ODR","0400-0430","0430-0830","NotInSession",na,na,na,na,na,na,na,na,na,false, timestamp(Timezone, year, month, dayofmonth, 8, 30),false,na,ShowODRDrProjection,na,na,na,na,na)),NumberOfSessionsToShow := NumberOfSessionsToShow+1
    if ShowHTF1Dr
        array.push(ArrayOfSessionDataObjects, SessionDataObject.new("Kilo","0430-0935","0935-1600","NotInSession",na,na,na,na,na,na,na,na,na,false, timestamp(Timezone, year, month, dayofmonth, 16, 0),false,na,ShowHTF1DrProjection,na,na,na,na,na)),NumberOfSessionsToShow := NumberOfSessionsToShow+1
    if ShowODRQ2Dr
        array.push(ArrayOfSessionDataObjects, SessionDataObject.new("Foxtrot","0730-0830","0830-0930","NotInSession",na,na,na,na,na,na,na,na,na,false, timestamp(Timezone, year, month, dayofmonth, 9, 30),false,na,ShowODRQ2DrProjection,na,na,na,na,na)),NumberOfSessionsToShow := NumberOfSessionsToShow+1
    if ShowRDRQ1Dr
        array.push(ArrayOfSessionDataObjects, SessionDataObject.new("Golf","0830-0930","0930-1115","NotInSession",na,na,na,na,na,na,na,na,na,false, timestamp(Timezone, year, month, dayofmonth, 11, 15),false,na,ShowRDRQ1DrProjection,na,na,na,na,na)),NumberOfSessionsToShow := NumberOfSessionsToShow+1
    if ShowRDRDr
        array.push(ArrayOfSessionDataObjects, SessionDataObject.new("RDR","0930-1030","1030-1600","NotInSession",na,na,na,na,na,na,na,na,na,false, timestamp(Timezone, year, month, dayofmonth, 16, 0),false,na,ShowRDRDrProjection,na,na,na,na,na)),NumberOfSessionsToShow := NumberOfSessionsToShow+1
    if ShowRDRQ2Dr
        array.push(ArrayOfSessionDataObjects, SessionDataObject.new("Hotel","1030-1130","1130-1400","NotInSession",na,na,na,na,na,na,na,na,na,false, timestamp(Timezone, year, month, dayofmonth, 14, 0),false,na,ShowRDRQ2DrProjection,na,na,na,na,na)),NumberOfSessionsToShow := NumberOfSessionsToShow+1
    if ShowRDRQ3Dr
        array.push(ArrayOfSessionDataObjects, SessionDataObject.new("India_Lima","1130-1330","1330-1645","NotInSession",na,na,na,na,na,na,na,na,na,false, timestamp(Timezone, year, month, dayofmonth, 16, 45),false,na,ShowRDRQ3DrProjection,na,na,na,na,na)),NumberOfSessionsToShow := NumberOfSessionsToShow+1
    if ShowRDRQ4Dr
        array.push(ArrayOfSessionDataObjects, SessionDataObject.new("Juliet","1415-1505","1505-1645","NotInSession",na,na,na,na,na,na,na,na,na,false, timestamp(Timezone, year, month, dayofmonth, 16, 45),false,na,ShowRDRQ4DrProjection,na,na,na,na,na)),NumberOfSessionsToShow := NumberOfSessionsToShow+1
    
    // Add new Cycle sessions from base new times.pine
    if ShowCycle1Dr
        array.push(ArrayOfSessionDataObjects, SessionDataObject.new("Cycle 1","1845-0130","0130-0800","NotInSession",na,na,na,na,na,na,na,na,na,false, timestamp(Timezone, year, month, dayofmonth, 8, 0),false,na,false,na,na,na,na,na)),NumberOfSessionsToShow := NumberOfSessionsToShow+1
    if ShowCycle2Dr
        array.push(ArrayOfSessionDataObjects, SessionDataObject.new("Cycle 2","0300-0430","0430-0830","NotInSession",na,na,na,na,na,na,na,na,na,false, timestamp(Timezone, year, month, dayofmonth, 8, 30),false,na,false,na,na,na,na,na)),NumberOfSessionsToShow := NumberOfSessionsToShow+1
    if ShowCycle3Dr
        array.push(ArrayOfSessionDataObjects, SessionDataObject.new("Cycle 3","0430-0935","0935-1600","NotInSession",na,na,na,na,na,na,na,na,na,false, timestamp(Timezone, year, month, dayofmonth, 16, 0),false,na,false,na,na,na,na,na)),NumberOfSessionsToShow := NumberOfSessionsToShow+1
    if ShowCycle4Dr
        array.push(ArrayOfSessionDataObjects, SessionDataObject.new("Cycle 4","0930-1330","1330-1645","NotInSession",na,na,na,na,na,na,na,na,na,false, timestamp(Timezone, year, month, dayofmonth, 16, 45),false,na,false,na,na,na,na,na)),NumberOfSessionsToShow := NumberOfSessionsToShow+1
    if ShowCycle5Dr
        array.push(ArrayOfSessionDataObjects, SessionDataObject.new("Cycle 5","1415-1505","1505-1645","NotInSession",na,na,na,na,na,na,na,na,na,false, timestamp(Timezone, year, month, dayofmonth, 16, 45),false,na,false,na,na,na,na,na)),NumberOfSessionsToShow := NumberOfSessionsToShow+1



if ShowAllMatrixProjections
    for i = 0 to array.size(ArrayOfSessionDataObjects)-1
        CurrentObject = array.get(ArrayOfSessionDataObjects, i)
        CurrentObject.ShowMatrixProjections := true





// } -------- END VARIABLES --------





// { --------------------- START QUANTUM DISTRIBUTION CYCLES ---------------------
i_ses_1_toggle = ShowADRQ1
i_ses_2_toggle = ShowADR
i_ses_3_toggle = ShowADRQ2
i_ses_4_toggle = ShowADRQ3
i_ses_5_toggle = ShowADRQ4
i_ses_6_toggle = ShowODRQ1
i_ses_7_toggle = ShowODR
i_ses_8_toggle = ShowHTF1

i_ses_9_toggle = ShowODRQ2
i_ses_10_toggle = ShowRDRQ1
i_ses_11_toggle = ShowRDR
i_ses_12_toggle = ShowRDRQ2
i_ses_13_toggle = ShowRDRQ3
i_ses_14_toggle = ShowRDRQ4
i_ses_15_toggle = ShowCycle1
i_ses_16_toggle = ShowCycle2
i_ses_17_toggle = ShowCycle3
i_ses_18_toggle = ShowCycle4
i_ses_19_toggle = ShowCycle5



// 	Name:	Fractal:	Distribution:
// 	ALPHA => 1845-1930 => 1845-2100		
// ADR => 1930-2130 => 1930-0200
// 	BRAVO => 2130-2230 =>  2130-0000
// 	CHARLIE => 2230-0030 => 2230-0245
// 	DELTA => 0030-0130 => 0030-0245
// 	ECHO => 0300-0400 => 0300-0545
// ODR => 0400-0430 => 0400-0830
// KILO => 0430-0935 => 0430-1600
// 	FOXTROT => 0730-0830 => 0730-0930
// 	GOLF => 0830-0930 => 0830-1115
// RDR => 0930-1030 => 0930-1600
// 	HOTEL => 1030-1130 => 1030-1400
// 	INDIA_LIMA => 1130-1330 => 1130-1645
// 	JULIET => 1415-1505 => 1415-1645
// 	CYCLE 1 => 1845-0130 => 
// 	CYCLE 2 => 0300-0430 => 
// 	CYCLE 3 => 0430-0935 => 
// 	CYCLE 4 => 0930-1330 => 
// 	CYCLE 5 => 1415-1505 => 


i_ses_1 = "1845-1930" // ALPHA - Distribution
i_ses_2 = "1930-2130" // ADR - Distribution
i_ses_3 = "2130-2230" // BRAVO - Distribution
i_ses_4 = "2230-0030" // CHARLIE - Distribution
i_ses_5 = "0030-0130" // DELTA - Distribution
i_ses_6 = "0300-0400" // ECHO - Distribution
i_ses_7 = "0400-0430" // ODR - Distribution
i_ses_8 = "0430-0935" // KILO - Distribution
i_ses_9 = "0730-0830" // FOXTROT - Distribution
i_ses_10 = "0830-0930" // GOLF - Distribution
i_ses_11 = "0930-1030" // RDR - Distribution
i_ses_12 = "1030-1130" // HOTEL - Distribution
i_ses_13 = "1130-1415" // INDIA_LIMA - Distribution
i_ses_14 = "1415-1845" // JULIET - Distribution
i_ses_15 = "1845-0130" // CYCLE 1 - Distribution
i_ses_16 = "0300-0430" // CYCLE 2 - Distribution
i_ses_17 = "0430-0935" // CYCLE 3 - Distribution
i_ses_18 = "0930-1330" // CYCLE 4 - Distribution
i_ses_19 = "1415-1505" // CYCLE 5 - Distribution

ONE_MINUTE = 3600
ONE_HOUR = ONE_MINUTE*1000
ONE_DAY = 24*ONE_HOUR
ONE_WEEK = ONE_DAY*7

i_ses_1_n = 10000,i_ses_2_n = 10000,i_ses_3_n = 10000,i_ses_4_n = 10000,i_ses_5_n = 10000,i_ses_6_n = 10000,i_ses_7_n = 10000,i_ses_8_n = 10000,i_ses_9_n = 10000,i_ses_10_n = 10000,i_ses_11_n = 10000,i_ses_12_n = 10000,i_ses_13_n = 10000,i_ses_14_n = 10000,i_ses_15_n = 10000,i_ses_16_n = 10000,i_ses_17_n = 10000,i_ses_18_n = 10000,i_ses_19_n = 10000

G3 = "Visual Styles"

// i_open_toggle = input.bool(defval = true, title = "", inline = "Open", group = G3)
// i_open_color = input.color(defval = color.yellow, title = "Open", inline = "Open", group = G3)
// i_open_width = input.int(defval = 1, title = "", minval = 0, maxval=5, inline = "Open", group = G3)
// i_open_style = input.string(defval = "dotted", title = "", options = ["solid", "dotted", "dashed"], inline = "Open", group = G3)

i_open_toggle = true
i_open_color =  color.new(color.green, 0)
i_open_width = 1
i_open_style = "dotted"

i_m_toggle = true
i_m_color = color.new(color.red, 0)
i_m_width = 1
i_m_style = "dotted"

i_d_toggle = true
i_d_color = color.new(color.green, 0)
i_d_width = 1
i_d_style = "dotted"

i_t_toggle = true
i_t_color = color.new(color.gray, 0)
i_t_width = 1
i_t_style = "dotted"

i_label_toggle = true
// i_label_size = input.string(defval = "Small", title = "Label Size", options = ["Tiny", "Small", "Normal", "Large", "Huge"], inline = "label size", group = G3)
i_label_size =  "Small"



ses_1 = not na(time("", i_ses_1, "America/New_York"))
ses_1_len = math.round(                                         // Get length of session in minutes
             str.tonumber(str.substring(i_ses_1, 5, 7)) * 60 +  // Session end hour
             str.tonumber(str.substring(i_ses_1, 7)) -          // Session end minute
             str.tonumber(str.substring(i_ses_1, 0, 2)) * 60 -  // Session start hour
             str.tonumber((str.substring(i_ses_1, 2, 4)))       // session start minute
             )
ses_2 = not na(time("", i_ses_2, "America/New_York"))
ses_2_len = math.round(                                         // Get length of session in minutes
             str.tonumber(str.substring(i_ses_2, 5, 7)) * 60 +  // Session end hour
             str.tonumber(str.substring(i_ses_2, 7)) -          // Session end minute
             str.tonumber(str.substring(i_ses_2, 0, 2)) * 60 -  // Session start hour
             str.tonumber((str.substring(i_ses_2, 2, 4)))       // session start minute
             )
ses_3 = not na(time("", i_ses_3, "America/New_York"))
ses_3_len = math.round(                                         // Get length of session in minutes
             str.tonumber(str.substring(i_ses_3, 5, 7)) * 60 +  // Session end hour
             str.tonumber(str.substring(i_ses_3, 7)) -          // Session end minute
             str.tonumber(str.substring(i_ses_3, 0, 2)) * 60 -  // Session start hour
             str.tonumber((str.substring(i_ses_3, 2, 4)))       // session start minute
             )
ses_4 = not na(time("", i_ses_4, "America/New_York"))
ses_4_len = math.round(                                         // Get length of session in minutes
             str.tonumber(str.substring(i_ses_4, 5, 7)) * 60 +  // Session end hour
             str.tonumber(str.substring(i_ses_4, 7)) -          // Session end minute
             str.tonumber(str.substring(i_ses_4, 0, 2)) * 60 -  // Session start hour
             str.tonumber((str.substring(i_ses_4, 2, 4)))       // session start minute
             )
ses_5 = not na(time("", i_ses_5, "America/New_York"))
ses_5_len = math.round(                                         // Get length of session in minutes
             str.tonumber(str.substring(i_ses_5, 5, 7)) * 60 +  // Session end hour
             str.tonumber(str.substring(i_ses_5, 7)) -          // Session end minute
             str.tonumber(str.substring(i_ses_5, 0, 2)) * 60 -  // Session start hour
             str.tonumber((str.substring(i_ses_5, 2, 4)))       // session start minute
             )
ses_6 = not na(time("", i_ses_6, "America/New_York"))
ses_6_len = math.round(                                         // Get length of session in minutes
             str.tonumber(str.substring(i_ses_6, 5, 7)) * 60 +  // Session end hour
             str.tonumber(str.substring(i_ses_6, 7)) -          // Session end minute
             str.tonumber(str.substring(i_ses_6, 0, 2)) * 60 -  // Session start hour
             str.tonumber((str.substring(i_ses_6, 2, 4)))       // session start minute
             )
ses_7 = not na(time("", i_ses_7, "America/New_York"))
ses_7_len = math.round(                                         // Get length of session in minutes
             str.tonumber(str.substring(i_ses_7, 5, 7)) * 60 +  // Session end hour
             str.tonumber(str.substring(i_ses_7, 7)) -          // Session end minute
             str.tonumber(str.substring(i_ses_7, 0, 2)) * 60 -  // Session start hour
             str.tonumber((str.substring(i_ses_7, 2, 4)))       // session start minute
             )
ses_8 = not na(time("", i_ses_8, "America/New_York"))
ses_8_len = math.round(                                         // Get length of session in minutes
             str.tonumber(str.substring(i_ses_8, 5, 7)) * 60 +  // Session end hour
             str.tonumber(str.substring(i_ses_8, 7)) -          // Session end minute
             str.tonumber(str.substring(i_ses_8, 0, 2)) * 60 -  // Session start hour
             str.tonumber((str.substring(i_ses_8, 2, 4)))       // session start minute
             )

ses_9 = not na(time("", i_ses_9, "America/New_York"))
ses_9_len = math.round(                                         // Get length of session in minutes
             str.tonumber(str.substring(i_ses_9, 5, 7)) * 60 +  // Session end hour
             str.tonumber(str.substring(i_ses_9, 7)) -          // Session end minute
             str.tonumber(str.substring(i_ses_9, 0, 2)) * 60 -  // Session start hour
             str.tonumber((str.substring(i_ses_9, 2, 4)))       // session start minute
             )

ses_10 = not na(time("", i_ses_10, "America/New_York"))
ses_10_len = math.round(                                         // Get length of session in minutes
             str.tonumber(str.substring(i_ses_10, 5, 7)) * 60 +  // Session end hour
             str.tonumber(str.substring(i_ses_10, 7)) -          // Session end minute
             str.tonumber(str.substring(i_ses_10, 0, 2)) * 60 -  // Session start hour
             str.tonumber((str.substring(i_ses_10, 2, 4)))       // session start minute
             )

ses_11 = not na(time("", i_ses_11, "America/New_York"))
ses_11_len = math.round(                                         // Get length of session in minutes
             str.tonumber(str.substring(i_ses_11, 5, 7)) * 60 +  // Session end hour
             str.tonumber(str.substring(i_ses_11, 7)) -          // Session end minute
             str.tonumber(str.substring(i_ses_11, 0, 2)) * 60 -  // Session start hour
             str.tonumber((str.substring(i_ses_11, 2, 4)))       // session start minute
             )

ses_12 = not na(time("", i_ses_12, "America/New_York"))
ses_12_len = math.round(                                         // Get length of session in minutes
             str.tonumber(str.substring(i_ses_12, 5, 7)) * 60 +  // Session end hour
             str.tonumber(str.substring(i_ses_12, 7)) -          // Session end minute
             str.tonumber(str.substring(i_ses_12, 0, 2)) * 60 -  // Session start hour
             str.tonumber((str.substring(i_ses_12, 2, 4)))       // session start minute
             )

ses_13 = not na(time("", i_ses_13, "America/New_York"))
ses_13_len = math.round(                                         // Get length of session in minutes
             str.tonumber(str.substring(i_ses_13, 5, 7)) * 60 +  // Session end hour
             str.tonumber(str.substring(i_ses_13, 7)) -          // Session end minute
             str.tonumber(str.substring(i_ses_13, 0, 2)) * 60 -  // Session start hour
             str.tonumber((str.substring(i_ses_13, 2, 4)))       // session start minute
             )

ses_14 = not na(time("", i_ses_14, "America/New_York"))
ses_14_len = math.round(                                         // Get length of session in minutes
             str.tonumber(str.substring(i_ses_14, 5, 7)) * 60 +  // Session end hour
             str.tonumber(str.substring(i_ses_14, 7)) -          // Session end minute
             str.tonumber(str.substring(i_ses_14, 0, 2)) * 60 -  // Session start hour
             str.tonumber((str.substring(i_ses_14, 2, 4)))       // session start minute
             )

ses_15 = not na(time("", i_ses_15, "America/New_York"))
ses_15_len = math.round(                                         // Get length of session in minutes
             str.tonumber(str.substring(i_ses_15, 5, 7)) * 60 +  // Session end hour
             str.tonumber(str.substring(i_ses_15, 7)) -          // Session end minute
             str.tonumber(str.substring(i_ses_15, 0, 2)) * 60 -  // Session start hour
             str.tonumber((str.substring(i_ses_15, 2, 4)))       // session start minute
             )

ses_16 = not na(time("", i_ses_16, "America/New_York"))
ses_16_len = math.round(                                         // Get length of session in minutes
             str.tonumber(str.substring(i_ses_16, 5, 7)) * 60 +  // Session end hour
             str.tonumber(str.substring(i_ses_16, 7)) -          // Session end minute
             str.tonumber(str.substring(i_ses_16, 0, 2)) * 60 -  // Session start hour
             str.tonumber((str.substring(i_ses_16, 2, 4)))       // session start minute
             )

ses_17 = not na(time("", i_ses_17, "America/New_York"))
ses_17_len = math.round(                                         // Get length of session in minutes
             str.tonumber(str.substring(i_ses_17, 5, 7)) * 60 +  // Session end hour
             str.tonumber(str.substring(i_ses_17, 7)) -          // Session end minute
             str.tonumber(str.substring(i_ses_17, 0, 2)) * 60 -  // Session start hour
             str.tonumber((str.substring(i_ses_17, 2, 4)))       // session start minute
             )

ses_18 = not na(time("", i_ses_18, "America/New_York"))
ses_18_len = math.round(                                         // Get length of session in minutes
             str.tonumber(str.substring(i_ses_18, 5, 7)) * 60 +  // Session end hour
             str.tonumber(str.substring(i_ses_18, 7)) -          // Session end minute
             str.tonumber(str.substring(i_ses_18, 0, 2)) * 60 -  // Session start hour
             str.tonumber((str.substring(i_ses_18, 2, 4)))       // session start minute
             )

ses_19 = not na(time("", i_ses_19, "America/New_York"))
ses_19_len = math.round(                                         // Get length of session in minutes
             str.tonumber(str.substring(i_ses_19, 5, 7)) * 60 +  // Session end hour
             str.tonumber(str.substring(i_ses_19, 7)) -          // Session end minute
             str.tonumber(str.substring(i_ses_19, 0, 2)) * 60 -  // Session start hour
             str.tonumber((str.substring(i_ses_19, 2, 4)))       // session start minute
             )

var color blank = #ffffff00                   // Fully transparent

var float[] a_ses_1_m = array.new_float()       // Array of ADRQ1 manipulation prices
var float[] a_ses_1_d = array.new_float()       // Array of ADRQ1 distribution prices
var int[] a_ses_1_mt  = array.new_int()         // Array of ADRQ1 manipulation times
var int[] a_ses_1_dt  = array.new_int()         // Array of ADRQ1 distribution times

var float[] a_ses_2_m = array.new_float()       // Array of ADR manipulation prices
var float[] a_ses_2_d = array.new_float()       // Array of ADR distribution prices
var int[] a_ses_2_mt  = array.new_int()         // Array of ADR manipulation times
var int[] a_ses_2_dt  = array.new_int()         // Array of ADR distribution times

var float[] a_ses_3_m = array.new_float()       // Array of ADRQ2 manipulation prices
var float[] a_ses_3_d = array.new_float()       // Array of ADRQ2 distribution prices
var int[] a_ses_3_mt  = array.new_int()         // Array of ADRQ2 manipulation times
var int[] a_ses_3_dt  = array.new_int()         // Array of ADRQ2 distribution times

var float[] a_ses_4_m = array.new_float()       // Array of ADRQ3 manipulation prices
var float[] a_ses_4_d = array.new_float()       // Array of ADRQ3 distribution prices
var int[] a_ses_4_mt  = array.new_int()         // Array of ADRQ3 manipulation times
var int[] a_ses_4_dt  = array.new_int()         // Array of ADRQ3 distribution times

var float[] a_ses_5_m = array.new_float()       // Array of ADRQ4 manipulation prices
var float[] a_ses_5_d = array.new_float()       // Array of ADRQ4 distribution prices
var int[] a_ses_5_mt  = array.new_int()         // Array of ADRQ4 manipulation times
var int[] a_ses_5_dt  = array.new_int()         // Array of ADRQ4 distribution times

var float[] a_ses_6_m = array.new_float()       // Array of ODRQ1 manipulation prices
var float[] a_ses_6_d = array.new_float()       // Array of ODRQ1 distribution prices
var int[] a_ses_6_mt  = array.new_int()         // Array of ODRQ1 manipulation times
var int[] a_ses_6_dt  = array.new_int()         // Array of ODRQ1 distribution times

var float[] a_ses_7_m = array.new_float()       // Array of ODR manipulation prices
var float[] a_ses_7_d = array.new_float()       // Array of ODR distribution prices
var int[] a_ses_7_mt  = array.new_int()         // Array of ODR manipulation times
var int[] a_ses_7_dt  = array.new_int()         // Array of ODR distribution times

var float[] a_ses_8_m = array.new_float()       // Array of HTF1 manipulation prices
var float[] a_ses_8_d = array.new_float()       // Array of HTF1 distribution prices
var int[] a_ses_8_mt  = array.new_int()         // Array of HTF1 manipulation times
var int[] a_ses_8_dt  = array.new_int()         // Array of HTF1 distribution times

var float[] a_ses_9_m = array.new_float()       // Array of ODRQ2 manipulation prices
var float[] a_ses_9_d = array.new_float()       // Array of ODRQ2 distribution prices
var int[] a_ses_9_mt  = array.new_int()         // Array of ODRQ2 manipulation times
var int[] a_ses_9_dt  = array.new_int()         // Array of ODRQ2 distribution times

var float[] a_ses_10_m = array.new_float()       // Array of RDRQ1 manipulation prices
var float[] a_ses_10_d = array.new_float()       // Array of RDRQ1 distribution prices
var int[] a_ses_10_mt  = array.new_int()         // Array of RDRQ1 manipulation times
var int[] a_ses_10_dt  = array.new_int()         // Array of RDRQ1 distribution times

var float[] a_ses_11_m = array.new_float()       // Array of RDR manipulation prices
var float[] a_ses_11_d = array.new_float()       // Array of RDR distribution prices
var int[] a_ses_11_mt  = array.new_int()         // Array of RDR manipulation times
var int[] a_ses_11_dt  = array.new_int()         // Array of RDR distribution times

var float[] a_ses_12_m = array.new_float()       // Array of RDRQ2 manipulation prices
var float[] a_ses_12_d = array.new_float()       // Array of RDRQ2 distribution prices
var int[] a_ses_12_mt  = array.new_int()         // Array of RDRQ2 manipulation times
var int[] a_ses_12_dt  = array.new_int()         // Array of RDRQ2 distribution times

var float[] a_ses_13_m = array.new_float()       // Array of RDRQ3 manipulation prices
var float[] a_ses_13_d = array.new_float()       // Array of RDRQ3 distribution prices
var int[] a_ses_13_mt  = array.new_int()         // Array of RDRQ3 manipulation times
var int[] a_ses_13_dt  = array.new_int()         // Array of RDRQ3 distribution times

var float[] a_ses_14_m = array.new_float()       // Array of HTF2 manipulation prices
var float[] a_ses_14_d = array.new_float()       // Array of HTF2 distribution prices
var int[] a_ses_14_mt  = array.new_int()         // Array of HTF2 manipulation times
var int[] a_ses_14_dt  = array.new_int()         // Array of HTF2 distribution times

var float[] a_ses_15_m = array.new_float()       // Array of CYCLE 1 manipulation prices
var float[] a_ses_15_d = array.new_float()       // Array of CYCLE 1 distribution prices
var int[] a_ses_15_mt  = array.new_int()         // Array of CYCLE 1 manipulation times
var int[] a_ses_15_dt  = array.new_int()         // Array of CYCLE 1 distribution times

var float[] a_ses_16_m = array.new_float()       // Array of CYCLE 2 manipulation prices
var float[] a_ses_16_d = array.new_float()       // Array of CYCLE 2 distribution prices
var int[] a_ses_16_mt  = array.new_int()         // Array of CYCLE 2 manipulation times
var int[] a_ses_16_dt  = array.new_int()         // Array of CYCLE 2 distribution times

var float[] a_ses_17_m = array.new_float()       // Array of CYCLE 3 manipulation prices
var float[] a_ses_17_d = array.new_float()       // Array of CYCLE 3 distribution prices
var int[] a_ses_17_mt  = array.new_int()         // Array of CYCLE 3 manipulation times
var int[] a_ses_17_dt  = array.new_int()         // Array of CYCLE 3 distribution times

var float[] a_ses_18_m = array.new_float()       // Array of CYCLE 4 manipulation prices
var float[] a_ses_18_d = array.new_float()       // Array of CYCLE 4 distribution prices
var int[] a_ses_18_mt  = array.new_int()         // Array of CYCLE 4 manipulation times
var int[] a_ses_18_dt  = array.new_int()         // Array of CYCLE 4 distribution times

var float[] a_ses_19_m = array.new_float()       // Array of CYCLE 5 manipulation prices
var float[] a_ses_19_d = array.new_float()       // Array of CYCLE 5 distribution prices
var int[] a_ses_19_mt  = array.new_int()         // Array of CYCLE 5 manipulation times
var int[] a_ses_19_dt  = array.new_int()         // Array of CYCLE 5 distribution times

// Function that converts string inputs to line style code:

f_line_style(input_var) =>
    switch input_var
        "dotted" => line.style_dotted
        "dashed" => line.style_dashed
        => line.style_solid

open_style = f_line_style(i_open_style)
m_style = f_line_style(i_m_style)
d_style = f_line_style(i_d_style)
t_style = f_line_style(i_t_style)

// Function that converts string inputs to label size code:

f_label_size(input_var) =>
    switch input_var
        "Tiny" => size.tiny
        "Small" => size.small
        "Normal" => size.normal
        "Large" => size.large
        "Huge" => size.huge

label_size = f_label_size(i_label_size)

// Function for adding an element and maintaining an array:

f_array_maint(a, new_element, array_size) =>
    a.push(new_element)
    if a.size() > array_size
        a.shift()

// Function for extending the line and label to the end of the session:

f_ext_end(int left, int right) =>
    int ext = na
    if timeframe.in_seconds() >= 60
        ext := left + right * 60 * 1000
    else if timeframe.in_seconds() < 60
        ext := left + right * 3600 * 1000
    ext

// Function to determine the manipulation and distribution prices and times:

f_man_dis(bool ses_toggle, bool ses, int ses_len) =>
    var float o = na
    var float h = na
    var float l = na
    var float c = na
    var float m = na
    var float d = na
    var int ht = na
    var int lt = na
    var int mt = na
    var int dt = na
    var int left = na
    var int right = na
    var float m_act = na    // Not in use
    var float d_act = na    // Not in use

    // Collect price and time data for the session:

    if ses_toggle
        if ses and not ses[1]
            o := open, h := high, ht := time, l := low, lt := time, left := time, right := f_ext_end(time, ses_len)

        if ses and ses[1]
            if high >= h
                h := high, ht := time
            if low <= l
                l := low, lt := time

        if ses[1] and not ses
            c := close[1]

    // Determine the manipulation and distribution time and price: 

        if c >= o
            m  := o - l
            d  := h - o
            mt := lt - left
            dt := ht - left
            m_act := l
            d_act := h

        else
            m  := h - o
            d  := o - l
            mt := ht - left
            dt := lt - left
            m_act := h
            d_act := l

        [o, h, l, c, m, d, mt, dt, left, right]

// Function to draw the price lines and labels:
f_price_line_label(bool line_toggle, bool label_toggle, int x1, float y, int x2, color _color, line_style, label_size, int _width, string label_text) =>
    line _line = na
    label _label = na
    if line_toggle
        if  hour(x1) > hour(x2)
            _line := line.new(x1, y, x2+ONE_DAY, y, xloc.bar_time, extend.none, _color, line_style, _width)
        else
            _line := line.new(x1, y, x2, y, xloc.bar_time, extend.none, _color, line_style, _width)
        if label_toggle
            if  hour(x1) > hour(x2)
                _label := label.new(x2+ONE_DAY, y, label_text, xloc.bar_time, yloc.price, blank, label.style_label_left, _color, label_size, text.align_left, str.format("{0,number,#.00}",y))
            else
                _label := label.new(x2, y, label_text, xloc.bar_time, yloc.price, blank, label.style_label_left, _color, label_size, text.align_left, str.format("{0,number,#.00}",y))
    [_line, _label]

// Function to draw the time lines and labels:
f_time_line_label(bool line_toggle, bool label_toggle, int x, float y1, float y2, float y3, color _color, line_style, label_size, int _width, string label_text) =>
    line _line = na
    label _label = na
    if line_toggle
        _line := line.new(x, y1, x, y2, xloc.bar_time, extend.none, _color, line_style, _width)
        if label_toggle
            _label := label.new(x, y3, label_text, xloc.bar_time, yloc.price, blank, label.style_label_up, _color, label_size, text.align_center)
    [_line, _label]


// Function to draw the session AMD map:
f_ses_map(float o, float h, float l, float c, int left, int right,
          array<float> a_ses_m, array<float> a_ses_d, array<int> a_ses_mt, array<int> a_ses_dt) =>

    // Calculate price and time averages:
    m_avg = a_ses_m.avg()
    d_avg = a_ses_d.avg()
    mt_avg = a_ses_mt.avg()
    dt_avg = a_ses_dt.avg()

    // Create the text for the time labels:

    m_time = str.format_time(left + mt_avg, "HH:mm", "America/New_York")
    d_time = str.format_time(left + dt_avg, "HH:mm", "America/New_York")
    // My Label Calculation
    DistributionLabel = ""
    ManipulationLabel = ""
    if ShowQuantumLabels
        DistributionLabel := str.tostring(d_avg, "##.##") + " " + str.tostring((d_avg/o), "#.##%")
        ManipulationLabel := str.tostring(m_avg, "##.##") + " " + str.tostring((m_avg/o), "#.##%")

    SessEnd = right
    if CurrentTicker == "BTC" and hour(left) > hour(right)
        SessEnd := right-ONE_DAY
    else if CurrentTicker == "BTC" and right < left
        SessEnd := right+ONE_DAY

 

    //[o_line, o_label]       = f_price_line_label(i_open_toggle, i_label_toggle, left, o, SessEnd, i_open_color, open_style, label_size, i_open_width, "O")
    if ShowOnlyTime
        [mt_line, mt_label]     = f_time_line_label(i_t_toggle, i_label_toggle, left + mt_avg, o - m_avg, o + m_avg, o - d_avg, ManipulationTimeColor, VerticalTimeLinesStyle, label_size, i_t_width, m_time)
        [dt_line, dt_label]     = f_time_line_label(i_t_toggle, i_label_toggle, left + dt_avg, o - d_avg, o + d_avg, o - d_avg, DistributionTimeColor, VerticalTimeLinesStyle, label_size, i_t_width, d_time)

        line.delete(mt_line[1]), label.delete(mt_label[1])
        line.delete(dt_line[1]), label.delete(dt_label[1])

    else
        // [mt_line, mt_label]     = f_time_line_label(i_t_toggle, i_label_toggle, left + mt_avg, o - m_avg, o + m_avg, o - d_avg, ManipulationTimeColor, t_style, label_size, i_t_width, m_time)
        // [dt_line, dt_label]     = f_time_line_label(i_t_toggle, i_label_toggle, left + dt_avg, o - d_avg, o + d_avg, o - d_avg, DistributionTimeColor, t_style, label_size, i_t_width, d_time)


        [m_up_line, m_up_label] = f_price_line_label(i_m_toggle,    i_label_toggle, left, o + m_avg, SessEnd, i_m_color, m_style, label_size, i_m_width, ManipulationLabel)
        [m_dn_line, m_dn_label] = f_price_line_label(i_m_toggle,    i_label_toggle, left, o - m_avg, SessEnd, i_m_color, m_style, label_size, i_m_width, ManipulationLabel)
        [d_up_line, d_up_label] = f_price_line_label(i_d_toggle,    i_label_toggle, left, o + d_avg, SessEnd, i_d_color, d_style, label_size, i_d_width, DistributionLabel)
        [d_dn_line, d_dn_label] = f_price_line_label(i_d_toggle,    i_label_toggle, left, o - d_avg, SessEnd, i_d_color, d_style, label_size, i_d_width, DistributionLabel)

        [mt_line1, mt_label1]     = f_time_line_label(i_t_toggle, i_label_toggle, left + mt_avg, o - m_avg, o + m_avg, o - d_avg, ManipulationTimeColor, VerticalTimeLinesStyle, label_size, i_t_width, m_time)
        [dt_line1, dt_label1]     = f_time_line_label(i_t_toggle, i_label_toggle, left + dt_avg, o - d_avg, o + d_avg, o - d_avg, DistributionTimeColor, VerticalTimeLinesStyle, label_size, i_t_width, d_time)

        line.delete(m_up_line[1]), label.delete(m_up_label[1])
        line.delete(m_dn_line[1]), label.delete(m_dn_label[1])
        line.delete(d_up_line[1]), label.delete(d_up_label[1])
        line.delete(d_dn_line[1]), label.delete(d_dn_label[1])
        line.delete(mt_line1[1]), label.delete(mt_label1[1])
        line.delete(dt_line1[1]), label.delete(dt_label1[1])

    //line.delete(o_line[1]), label.delete(o_label[1])

    

// Function to draw the time lines and labels:
Function_Draw_As_Boxes(float o, float h, float l, float c, int left, int right,
          array<float> a_ses_m, array<float> a_ses_d, array<int> a_ses_mt, array<int> a_ses_dt, _Name) =>
    


    // Calculate price and time averages:
    m_avg = a_ses_m.avg()
    d_avg = a_ses_d.avg()
    mt_avg = a_ses_mt.avg()
    dt_avg = a_ses_dt.avg()

    string BoxLabel = ""

    if ShowProjectionLabels
        BoxLabel := _Name

    // Create the text for the time labels:

    m_time = str.format_time(left + mt_avg, "HH:mm", "America/New_York")
    d_time = str.format_time(left + dt_avg, "HH:mm", "America/New_York")
    // My Label Calculation
    DistributionLabel = ""
    ManipulationLabel = ""
    if ShowQuantumLabels
        DistributionLabel := str.tostring(d_avg, "##.##") + " " + str.tostring((d_avg/o), "#.##%")
        ManipulationLabel := str.tostring(m_avg, "##.##") + " " + str.tostring((m_avg/o), "#.##%")

    int EndTime = right //+ONE_DAY
    // if hour(left) < 12
    //     EndTime := right

    if left > EndTime
        EndTime := EndTime+ONE_DAY

    BoxMidpointCalc =  (d_avg-m_avg)/2

    if ShowOnlyTime
        [mt_line, mt_label]     = f_time_line_label(i_t_toggle, i_label_toggle, left + mt_avg, o - m_avg, o + m_avg, o - d_avg, ManipulationTimeColor, VerticalTimeLinesStyle, label_size, i_t_width, m_time)
        [dt_line, dt_label]     = f_time_line_label(i_t_toggle, i_label_toggle, left + dt_avg, o - d_avg, o + d_avg, o - d_avg, DistributionTimeColor, VerticalTimeLinesStyle, label_size, i_t_width, d_time)
 
        line.delete(mt_line[1]), label.delete(mt_label[1])
        line.delete(dt_line[1]), label.delete(dt_label[1])
 
        line.delete(mt_line[1])
        label.delete(mt_label[1])
        line.delete(dt_line[1])
        label.delete(dt_label[1])
   // box.delete(PremiumBox[1])
    // box.delete(DiscountBox[1])
    // line.delete(PremiumLine[1])
    // line.delete(DiscountLine[1])

    else
        PremiumBox = box.new(left, o + m_avg, EndTime, o + d_avg, xloc = xloc.bar_time, bgcolor = PremiumBoxColor, border_color = PremiumBoxBorderColor, border_width = 1,text = BoxLabel, text_color = ProjectionLabelColor, text_halign = text.align_left, text_valign = text.align_top, text_size = size.small)
        DiscountBox = box.new(left, o - m_avg, EndTime, o - d_avg, xloc = xloc.bar_time, bgcolor = DiscountBoxColor, border_color = DiscountBoxBorderColor, border_width = 1)
        PremiumLine = line.new(left,o + m_avg + BoxMidpointCalc,EndTime, o + m_avg + BoxMidpointCalc, xloc.bar_time, color = PremiumBoxBorderColor, style = line.style_dashed, width = 1)
        DiscountLine = line.new(left,o - m_avg - BoxMidpointCalc,EndTime, o - m_avg - BoxMidpointCalc, xloc.bar_time, color = DiscountBoxBorderColor, style = line.style_dashed, width = 1)
        [mt_line, mt_label]     = f_time_line_label(i_t_toggle, i_label_toggle, left + mt_avg, o - m_avg, o + m_avg, o - d_avg, ManipulationTimeColor, VerticalTimeLinesStyle, label_size, i_t_width, m_time)
        [dt_line, dt_label]     = f_time_line_label(i_t_toggle, i_label_toggle, left + dt_avg, o - d_avg, o + d_avg, o - d_avg, DistributionTimeColor, VerticalTimeLinesStyle, label_size, i_t_width, d_time)

        box.delete(PremiumBox[1])
        box.delete(DiscountBox[1])
        line.delete(PremiumLine[1])
        line.delete(DiscountLine[1])

        line.delete(mt_line[1])
        label.delete(mt_label[1])
        line.delete(dt_line[1])
        label.delete(dt_label[1])






// Get the values for the current session.  These will be used to update the averages when the sesion closes.

[o_1, h_1, l_1, c_1, m_1, d_1, mt_1, dt_1, left_1, right_1] = f_man_dis(i_ses_1_toggle, ses_1, ses_1_len)
[o_2, h_2, l_2, c_2, m_2, d_2, mt_2, dt_2, left_2, right_2] = f_man_dis(i_ses_2_toggle, ses_2, ses_2_len)
[o_3, h_3, l_3, c_3, m_3, d_3, mt_3, dt_3, left_3, right_3] = f_man_dis(i_ses_3_toggle, ses_3, ses_3_len)
[o_4, h_4, l_4, c_4, m_4, d_4, mt_4, dt_4, left_4, right_4] = f_man_dis(i_ses_4_toggle, ses_4, ses_4_len)
[o_5, h_5, l_5, c_5, m_5, d_5, mt_5, dt_5, left_5, right_5] = f_man_dis(i_ses_5_toggle, ses_5, ses_5_len)
[o_6, h_6, l_6, c_6, m_6, d_6, mt_6, dt_6, left_6, right_6] = f_man_dis(i_ses_6_toggle, ses_6, ses_6_len)
[o_7, h_7, l_7, c_7, m_7, d_7, mt_7, dt_7, left_7, right_7] = f_man_dis(i_ses_7_toggle, ses_7, ses_7_len)
[o_8, h_8, l_8, c_8, m_8, d_8, mt_8, dt_8, left_8, right_8] = f_man_dis(i_ses_8_toggle, ses_8, ses_8_len)
[o_9, h_9, l_9, c_9, m_9, d_9, mt_9, dt_9, left_9, right_9] = f_man_dis(i_ses_9_toggle, ses_9, ses_9_len)
[o_10, h_10, l_10, c_10, m_10, d_10, mt_10, dt_10, left_10, right_10] = f_man_dis(i_ses_10_toggle, ses_10, ses_10_len)
[o_11, h_11, l_11, c_11, m_11, d_11, mt_11, dt_11, left_11, right_11] = f_man_dis(i_ses_11_toggle, ses_11, ses_11_len)
[o_12, h_12, l_12, c_12, m_12, d_12, mt_12, dt_12, left_12, right_12] = f_man_dis(i_ses_12_toggle, ses_12, ses_12_len)
[o_13, h_13, l_13, c_13, m_13, d_13, mt_13, dt_13, left_13, right_13] = f_man_dis(i_ses_13_toggle, ses_13, ses_13_len)
[o_14, h_14, l_14, c_14, m_14, d_14, mt_14, dt_14, left_14, right_14] = f_man_dis(i_ses_14_toggle, ses_14, ses_14_len)
[o_15, h_15, l_15, c_15, m_15, d_15, mt_15, dt_15, left_15, right_15] = f_man_dis(i_ses_15_toggle, ses_15, ses_15_len)
[o_16, h_16, l_16, c_16, m_16, d_16, mt_16, dt_16, left_16, right_16] = f_man_dis(i_ses_16_toggle, ses_16, ses_16_len)
[o_17, h_17, l_17, c_17, m_17, d_17, mt_17, dt_17, left_17, right_17] = f_man_dis(i_ses_17_toggle, ses_17, ses_17_len)
[o_18, h_18, l_18, c_18, m_18, d_18, mt_18, dt_18, left_18, right_18] = f_man_dis(i_ses_18_toggle, ses_18, ses_18_len)
[o_19, h_19, l_19, c_19, m_19, d_19, mt_19, dt_19, left_19, right_19] = f_man_dis(i_ses_19_toggle, ses_19, ses_19_len)



// Draw the session stat maps:

// START Based on Quant Nomad
FunctionRoundFloat(x, n) => 
    mult = 1 
    if n != 0
        for i = 1 to math.abs(n)
            mult := mult * 10
    
    n >= 0 ? math.round(x * mult) / mult : math.round(x / mult) * mult 
// END Based on Quant Nomad

if ses_1 and not ses_1[1]
    Name = "Alpha"
    if ShowOtherQuantumAsBoxes
        Function_Draw_As_Boxes(o_1, h_1, l_1, c_1, left_1, right_1-ONE_DAY, a_ses_1_m, a_ses_1_d, a_ses_1_mt, a_ses_1_dt, Name)
    else
        f_ses_map(o_1, h_1, l_1, c_1, left_1, right_1, a_ses_1_m, a_ses_1_d, a_ses_1_mt, a_ses_1_dt)

    if ShowTable and ShowADRQ1
        m_avg = a_ses_1_m.avg()
        d_avg = a_ses_1_d.avg()
        mt_avg = a_ses_1_mt.avg()
        dt_avg = a_ses_1_dt.avg()

        table.cell(Table, 0, 1, Name, text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 1, 1, str.tostring(FunctionRoundFloat(m_avg, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 2, 1, str.tostring(FunctionRoundFloat(m_avg+(d_avg-m_avg)/2, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 3, 1, str.tostring(FunctionRoundFloat(2*m_avg+2*(d_avg-m_avg)/2, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 4, 1, str.tostring(FunctionRoundFloat(2*d_avg, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 5, 1, str.format_time(left_1 + mt_avg, "HH:mm", Timezone), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 6, 1, str.format_time(left_1 + dt_avg, "HH:mm", Timezone), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)


if ses_2 and not ses_2[1]
    Name = "ADR"
    if ShowQuantumAsBoxes or ShowOtherQuantumAsBoxes
        if CurrentTicker == "BTC" or CurrentTicker == "ETH"
            Function_Draw_As_Boxes(o_2, h_2, l_2, c_2, left_2, right_2, a_ses_2_m, a_ses_2_d, a_ses_2_mt, a_ses_2_dt, Name)
        else
            Function_Draw_As_Boxes(o_2, h_2, l_2, c_2, left_2, right_2, a_ses_2_m, a_ses_2_d, a_ses_2_mt, a_ses_2_dt, Name)
    
    else
        if CurrentTicker == "BTC" or CurrentTicker == "ETH"
            f_ses_map(o_2, h_2, l_2, c_2, left_2, right_2+ONE_DAY, a_ses_2_m, a_ses_2_d, a_ses_2_mt, a_ses_2_dt)

        else
            f_ses_map(o_2, h_2, l_2, c_2, left_2, right_2, a_ses_2_m, a_ses_2_d, a_ses_2_mt, a_ses_2_dt)

    if ShowTable and ShowADR
        m_avg = a_ses_2_m.avg()
        d_avg = a_ses_2_d.avg()
        mt_avg = a_ses_2_mt.avg()
        dt_avg = a_ses_2_dt.avg()

        table.cell(Table, 0, 2, Name, text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 1, 2, str.tostring(FunctionRoundFloat(m_avg, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 2, 2, str.tostring(FunctionRoundFloat(m_avg+(d_avg-m_avg)/2, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 3, 2, str.tostring(FunctionRoundFloat(2*m_avg+2*(d_avg-m_avg)/2, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 4, 2, str.tostring(FunctionRoundFloat(2*d_avg, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 5, 2, str.format_time(left_2 + mt_avg, "HH:mm", Timezone), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 6, 2, str.format_time(left_2 + dt_avg, "HH:mm", Timezone), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)


if ses_3 and not ses_3[1]
    Name = "Bravo"
    if NeedsOffset
        if ShowOtherQuantumAsBoxes
            if CurrentTicker == "BTC" or CurrentTicker == "ETH"
                Function_Draw_As_Boxes(o_3, h_3, l_3, c_3, left_3, right_3+ONE_DAY, a_ses_3_m, a_ses_3_d, a_ses_3_mt, a_ses_3_dt, Name)
            else
                Function_Draw_As_Boxes(o_3, h_3, l_3, c_3, left_3, right_3, a_ses_3_m, a_ses_3_d, a_ses_3_mt, a_ses_3_dt, Name)
        else
            f_ses_map(o_3, h_3, l_3, c_3, left_3, right_3, a_ses_3_m, a_ses_3_d, a_ses_3_mt, a_ses_3_dt)
    else
        if ShowOtherQuantumAsBoxes
            if CurrentTicker == "BTC" or CurrentTicker == "ETH"
                Function_Draw_As_Boxes(o_3, h_3, l_3, c_3, left_3, right_3, a_ses_3_m, a_ses_3_d, a_ses_3_mt, a_ses_3_dt, Name)
            else
                Function_Draw_As_Boxes(o_3, h_3, l_3, c_3, left_3, right_3, a_ses_3_m, a_ses_3_d, a_ses_3_mt, a_ses_3_dt, Name)
        else
            f_ses_map(o_3, h_3, l_3, c_3, left_3, right_3, a_ses_3_m, a_ses_3_d, a_ses_3_mt, a_ses_3_dt)

    if ShowTable and ShowADRQ2
        m_avg = a_ses_3_m.avg()
        d_avg = a_ses_3_d.avg()
        mt_avg = a_ses_3_mt.avg()
        dt_avg = a_ses_3_dt.avg()

        table.cell(Table, 0, 3, Name, text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 1, 3, str.tostring(FunctionRoundFloat(m_avg, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 2, 3, str.tostring(FunctionRoundFloat(m_avg+(d_avg-m_avg)/2, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 3, 3, str.tostring(FunctionRoundFloat(2*m_avg+2*(d_avg-m_avg)/2, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 4, 3, str.tostring(FunctionRoundFloat(2*d_avg, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 5, 3, str.format_time(left_3 + mt_avg, "HH:mm", Timezone), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 6, 3, str.format_time(left_3 + dt_avg, "HH:mm", Timezone), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)


if ses_4 and not ses_4[1]
    Name = "Charlie"
    if NeedsOffset
        if ShowOtherQuantumAsBoxes
            if CurrentTicker == "BTC" or CurrentTicker == "ETH"
                Function_Draw_As_Boxes(o_4, h_4, l_4, c_4, left_4, right_4+ONE_DAY, a_ses_4_m, a_ses_4_d, a_ses_4_mt, a_ses_4_dt, Name)
            else
                Function_Draw_As_Boxes(o_4, h_4, l_4, c_4, left_4, right_4, a_ses_4_m, a_ses_4_d, a_ses_4_mt, a_ses_4_dt, Name)
        else
            f_ses_map(o_4, h_4, l_4, c_4, left_4, right_4-ONE_DAY, a_ses_4_m, a_ses_4_d, a_ses_4_mt, a_ses_4_dt)
    else
        if ShowOtherQuantumAsBoxes
            Function_Draw_As_Boxes(o_4, h_4, l_4, c_4, left_4, right_4, a_ses_4_m, a_ses_4_d, a_ses_4_mt, a_ses_4_dt, Name)
        else
            f_ses_map(o_4, h_4, l_4, c_4, left_4, right_4, a_ses_4_m, a_ses_4_d, a_ses_4_mt, a_ses_4_dt)

    if ShowTable and ShowADRQ3
        m_avg = a_ses_4_m.avg()
        d_avg = a_ses_4_d.avg()
        mt_avg = a_ses_4_mt.avg()
        dt_avg = a_ses_4_dt.avg()

        table.cell(Table, 0, 4, Name, text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 1, 4, str.tostring(FunctionRoundFloat(m_avg, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 2, 4, str.tostring(FunctionRoundFloat(m_avg+(d_avg-m_avg)/2, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 3, 4, str.tostring(FunctionRoundFloat(2*m_avg+2*(d_avg-m_avg)/2, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 4, 4, str.tostring(FunctionRoundFloat(2*d_avg, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 5, 4, str.format_time(left_4 + mt_avg, "HH:mm", Timezone), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 6, 4, str.format_time(left_4 + dt_avg, "HH:mm", Timezone), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)


if ses_5 and not ses_5[1]
	Name = "Delta"
    if NeedsOffset
        if ShowOtherQuantumAsBoxes
            if CurrentTicker == "BTC" or CurrentTicker == "ETH"
                Function_Draw_As_Boxes(o_5, h_5, l_5, c_5, left_5, right_5, a_ses_5_m, a_ses_5_d, a_ses_5_mt, a_ses_5_dt, Name)      
            else
                Function_Draw_As_Boxes(o_5, h_5, l_5, c_5, left_5, right_5-ONE_DAY, a_ses_5_m, a_ses_5_d, a_ses_5_mt, a_ses_5_dt, Name)
        else
            f_ses_map(o_5, h_5, l_5, c_5, left_5, right_5-ONE_DAY, a_ses_5_m, a_ses_5_d, a_ses_5_mt, a_ses_5_dt)
    else
        if ShowOtherQuantumAsBoxes
            Function_Draw_As_Boxes(o_5, h_5, l_5, c_5, left_5, right_5, a_ses_5_m, a_ses_5_d, a_ses_5_mt, a_ses_5_dt, Name)
        else
            f_ses_map(o_5, h_5, l_5, c_5, left_5, right_5, a_ses_5_m, a_ses_5_d, a_ses_5_mt, a_ses_5_dt)

    if ShowTable and ShowADRQ4
        m_avg = a_ses_5_m.avg()
        d_avg = a_ses_5_d.avg()
        mt_avg = a_ses_5_mt.avg()
        dt_avg = a_ses_5_dt.avg()

        table.cell(Table, 0, 5, Name, text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 1, 5, str.tostring(FunctionRoundFloat(m_avg, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 2, 5, str.tostring(FunctionRoundFloat(m_avg+(d_avg-m_avg)/2, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 3, 5, str.tostring(FunctionRoundFloat(2*m_avg+2*(d_avg-m_avg)/2, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 4, 5, str.tostring(FunctionRoundFloat(2*d_avg, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 5, 5, str.format_time(left_5 + mt_avg, "HH:mm", Timezone), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 6, 5, str.format_time(left_5 + dt_avg, "HH:mm", Timezone), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)


if ses_6 and not ses_6[1]
	Name = "Echo"
    if ShowQuantumAsBoxes or ShowOtherQuantumAsBoxes
        Function_Draw_As_Boxes(o_6, h_6, l_6, c_6, left_6, right_6, a_ses_6_m, a_ses_6_d, a_ses_6_mt, a_ses_6_dt, Name)
    else
        f_ses_map(o_6, h_6, l_6, c_6, left_6, right_6, a_ses_6_m, a_ses_6_d, a_ses_6_mt, a_ses_6_dt)

    if ShowTable and ShowODRQ1
        m_avg = a_ses_6_m.avg()
        d_avg = a_ses_6_d.avg()
        mt_avg = a_ses_6_mt.avg()
        dt_avg = a_ses_6_dt.avg()

        table.cell(Table, 0, 6, Name, text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 1, 6, str.tostring(FunctionRoundFloat(m_avg, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 2, 6, str.tostring(FunctionRoundFloat(m_avg+(d_avg-m_avg)/2, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 3, 6, str.tostring(FunctionRoundFloat(2*m_avg+2*(d_avg-m_avg)/2, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 4, 6, str.tostring(FunctionRoundFloat(2*d_avg, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 5, 6, str.format_time(left_6 + mt_avg, "HH:mm", Timezone), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 6, 6, str.format_time(left_6 + dt_avg, "HH:mm", Timezone), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)


if ses_7 and not ses_7[1]
	Name = "ODR"
    if ShowQuantumAsBoxes or ShowOtherQuantumAsBoxes
        Function_Draw_As_Boxes(o_7, h_7, l_7, c_7, left_7, right_7, a_ses_7_m, a_ses_7_d, a_ses_7_mt, a_ses_7_dt, Name)
    else
        f_ses_map(o_7, h_7, l_7, c_7, left_7, right_7, a_ses_7_m, a_ses_7_d, a_ses_7_mt, a_ses_7_dt)

    if ShowTable and ShowODR
        m_avg = a_ses_7_m.avg()
        d_avg = a_ses_7_d.avg()
        mt_avg = a_ses_7_mt.avg()
        dt_avg = a_ses_7_dt.avg()

        table.cell(Table, 0, 7, Name, text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 1, 7, str.tostring(FunctionRoundFloat(m_avg, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 2, 7, str.tostring(FunctionRoundFloat(m_avg+(d_avg-m_avg)/2, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 3, 7, str.tostring(FunctionRoundFloat(2*m_avg+2*(d_avg-m_avg)/2, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 4, 7, str.tostring(FunctionRoundFloat(2*d_avg, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 5, 7, str.format_time(left_7 + mt_avg, "HH:mm", Timezone), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 6, 7, str.format_time(left_7 + dt_avg, "HH:mm", Timezone), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)


if ses_8 and not ses_8[1]
	Name = "Kilo"
    if ShowOtherQuantumAsBoxes
        Function_Draw_As_Boxes(o_8, h_8, l_8, c_8, left_8, right_8, a_ses_8_m, a_ses_8_d, a_ses_8_mt, a_ses_8_dt, Name)
    else
        f_ses_map(o_8, h_8, l_8, c_8, left_8, right_8, a_ses_8_m, a_ses_8_d, a_ses_8_mt, a_ses_8_dt)

    if ShowTable and ShowHTF1
        m_avg = a_ses_8_m.avg()
        d_avg = a_ses_8_d.avg()
        mt_avg = a_ses_8_mt.avg()
        dt_avg = a_ses_8_dt.avg()

        table.cell(Table, 0, 8, Name, text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 1, 8, str.tostring(FunctionRoundFloat(m_avg, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 2, 8, str.tostring(FunctionRoundFloat(m_avg+(d_avg-m_avg)/2, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 3, 8, str.tostring(FunctionRoundFloat(2*m_avg+2*(d_avg-m_avg)/2, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 4, 8, str.tostring(FunctionRoundFloat(2*d_avg, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 5, 8, str.format_time(left_8 + mt_avg, "HH:mm", Timezone), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 6, 8, str.format_time(left_8 + dt_avg, "HH:mm", Timezone), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)


if ses_9 and not ses_9[1]
	Name = "Foxtrot"
    if ShowOtherQuantumAsBoxes
        Function_Draw_As_Boxes(o_9, h_9, l_9, c_9, left_9, right_9, a_ses_9_m, a_ses_9_d, a_ses_9_mt, a_ses_9_dt, Name)
    else
        f_ses_map(o_9, h_9, l_9, c_9, left_9, right_9, a_ses_9_m, a_ses_9_d, a_ses_9_mt, a_ses_9_dt)

    if ShowTable and ShowODRQ2
        m_avg9 = a_ses_9_m.avg()
        d_avg9 = a_ses_9_d.avg()
        mt_avg9 = a_ses_9_mt.avg()
        dt_avg9 = a_ses_9_dt.avg()

        table.cell(Table, 0, 9, Name, text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 1, 9, str.tostring(FunctionRoundFloat(m_avg9, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 2, 9, str.tostring(FunctionRoundFloat(m_avg9+(d_avg9-m_avg9)/2, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 3, 9, str.tostring(FunctionRoundFloat(2*m_avg9+2*(d_avg9-m_avg9)/2, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 4, 9, str.tostring(FunctionRoundFloat(2*d_avg9, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 5, 9, str.format_time(left_9 + mt_avg9, "HH:mm", Timezone), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 6, 9, str.format_time(left_9 + dt_avg9, "HH:mm", Timezone), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)


if ses_10 and not ses_10[1]
	Name = "Golf"
    if ShowOtherQuantumAsBoxes
        if CurrentTicker == "BTC"or CurrentTicker == "ETH"
            Function_Draw_As_Boxes(o_10, h_10, l_10, c_10, left_10, right_10-ONE_DAY, a_ses_10_m, a_ses_10_d, a_ses_10_mt, a_ses_10_dt, Name)
        else
            Function_Draw_As_Boxes(o_10, h_10, l_10, c_10, left_10, right_10, a_ses_10_m, a_ses_10_d, a_ses_10_mt, a_ses_10_dt, Name)
    else
        f_ses_map(o_10, h_10, l_10, c_10, left_10, right_10, a_ses_10_m, a_ses_10_d, a_ses_10_mt, a_ses_10_dt)

    if ShowTable and ShowRDRQ1
        m_avg = a_ses_10_m.avg()
        d_avg = a_ses_10_d.avg()
        mt_avg = a_ses_10_mt.avg()
        dt_avg = a_ses_10_dt.avg()

        table.cell(Table, 0, 10, Name, text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 1, 10, str.tostring(FunctionRoundFloat(m_avg, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 2, 10, str.tostring(FunctionRoundFloat(m_avg+(d_avg-m_avg)/2, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 3, 10, str.tostring(FunctionRoundFloat(2*m_avg+2*(d_avg-m_avg)/2, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 4, 10, str.tostring(FunctionRoundFloat(2*d_avg, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 5, 10, str.format_time(left_10 + mt_avg, "HH:mm", Timezone), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 6, 10, str.format_time(left_10 + dt_avg, "HH:mm", Timezone), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)


if ses_11 and not ses_11[1]
	Name = "RDR"
    if ShowQuantumAsBoxes or ShowOtherQuantumAsBoxes
        if CurrentTicker == "BTC" or CurrentTicker == "ETH"
            Function_Draw_As_Boxes(o_11, h_11, l_11, c_11, left_11, right_11-ONE_DAY, a_ses_11_m, a_ses_11_d, a_ses_11_mt, a_ses_11_dt, Name)
        else
            Function_Draw_As_Boxes(o_11, h_11, l_11, c_11, left_11, right_11, a_ses_11_m, a_ses_11_d, a_ses_11_mt, a_ses_11_dt, Name)
    else
        f_ses_map(o_11, h_11, l_11, c_11, left_11, right_11, a_ses_11_m, a_ses_11_d, a_ses_11_mt, a_ses_11_dt)

    if ShowTable and ShowRDR
        m_avg = a_ses_11_m.avg()
        d_avg = a_ses_11_d.avg()
        mt_avg = a_ses_11_mt.avg()
        dt_avg = a_ses_11_dt.avg()

        table.cell(Table, 0, 11, Name, text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 1, 11, str.tostring(FunctionRoundFloat(m_avg, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 2, 11, str.tostring(FunctionRoundFloat(m_avg+(d_avg-m_avg)/2, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 3, 11, str.tostring(FunctionRoundFloat(2*m_avg+2*(d_avg-m_avg)/2, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 4, 11, str.tostring(FunctionRoundFloat(2*d_avg, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 5, 11, str.format_time(left_11 + mt_avg, "HH:mm", Timezone), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 6, 11, str.format_time(left_11 + dt_avg, "HH:mm", Timezone), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)


if ses_12 and not ses_12[1]
	Name = "Hotel"
    if ShowOtherQuantumAsBoxes
        if CurrentTicker == "BTC" or CurrentTicker == "ETH"
            Function_Draw_As_Boxes(o_12, h_12, l_12, c_12, left_12, right_12-ONE_DAY, a_ses_12_m, a_ses_12_d, a_ses_12_mt, a_ses_12_dt, Name)       
        else
            Function_Draw_As_Boxes(o_12, h_12, l_12, c_12, left_12, right_12, a_ses_12_m, a_ses_12_d, a_ses_12_mt, a_ses_12_dt, Name)
    else
        f_ses_map(o_12, h_12, l_12, c_12, left_12, right_12, a_ses_12_m, a_ses_12_d, a_ses_12_mt, a_ses_12_dt)

    if ShowTable and ShowRDRQ2
        m_avg = a_ses_12_m.avg()
        d_avg = a_ses_12_d.avg()
        mt_avg = a_ses_12_mt.avg()
        dt_avg = a_ses_12_dt.avg()

        table.cell(Table, 0, 12, Name, text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 1, 12, str.tostring(FunctionRoundFloat(m_avg, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 2, 12, str.tostring(FunctionRoundFloat(m_avg+(d_avg-m_avg)/2, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 3, 12, str.tostring(FunctionRoundFloat(2*m_avg+2*(d_avg-m_avg)/2, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 4, 12, str.tostring(FunctionRoundFloat(2*d_avg, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 5, 12, str.format_time(left_12 + mt_avg, "HH:mm", Timezone), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 6, 12, str.format_time(left_12 + dt_avg, "HH:mm", Timezone), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)


if ses_13 and not ses_13[1]
	Name = "India_Lima"
    if ShowOtherQuantumAsBoxes
        if CurrentTicker == "BTC" or CurrentTicker == "ETH"
            Function_Draw_As_Boxes(o_13, h_13, l_13, c_13, left_13, right_13-ONE_DAY, a_ses_13_m, a_ses_13_d, a_ses_13_mt, a_ses_13_dt, Name)        
        else
            Function_Draw_As_Boxes(o_13, h_13, l_13, c_13, left_13, right_13, a_ses_13_m, a_ses_13_d, a_ses_13_mt, a_ses_13_dt, Name)
    else
        f_ses_map(o_13, h_13, l_13, c_13, left_13, right_13, a_ses_13_m, a_ses_13_d, a_ses_13_mt, a_ses_13_dt)

    if ShowTable and ShowRDRQ3
        m_avg = a_ses_13_m.avg()
        d_avg = a_ses_13_d.avg()
        mt_avg = a_ses_13_mt.avg()
        dt_avg = a_ses_13_dt.avg()

        table.cell(Table, 0, 13, Name, text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 1, 13, str.tostring(FunctionRoundFloat(m_avg, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 2, 13, str.tostring(FunctionRoundFloat(m_avg+(d_avg-m_avg)/2, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 3, 13, str.tostring(FunctionRoundFloat(2*m_avg+2*(d_avg-m_avg)/2, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 4, 13, str.tostring(FunctionRoundFloat(2*d_avg, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 5, 13, str.format_time(left_13 + mt_avg, "HH:mm", Timezone), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 6, 13, str.format_time(left_13 + dt_avg, "HH:mm", Timezone), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)


if ses_14 and not ses_14[1]
	Name = "Juliet"
    if ShowOtherQuantumAsBoxes
        Function_Draw_As_Boxes(o_14, h_14, l_14, c_14, left_14, right_14-ONE_DAY, a_ses_14_m, a_ses_14_d, a_ses_14_mt, a_ses_14_dt, Name)
    else
        f_ses_map(o_14, h_14, l_14, c_14, left_14, right_14, a_ses_14_m, a_ses_14_d, a_ses_14_mt, a_ses_14_dt)

    if ShowTable and ShowRDRQ4
        m_avg = a_ses_14_m.avg()
        d_avg = a_ses_14_d.avg()
        mt_avg = a_ses_14_mt.avg()
        dt_avg = a_ses_14_dt.avg()

        table.cell(Table, 0, 14, Name, text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 1, 14, str.tostring(FunctionRoundFloat(m_avg, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 2, 14, str.tostring(FunctionRoundFloat(m_avg+(d_avg-m_avg)/2, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 3, 14, str.tostring(FunctionRoundFloat(2*m_avg+2*(d_avg-m_avg)/2, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 4, 14, str.tostring(FunctionRoundFloat(2*d_avg, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 5, 14, str.format_time(left_14 + mt_avg, "HH:mm", Timezone), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 6, 14, str.format_time(left_14 + dt_avg, "HH:mm", Timezone), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)


if ses_15 and not ses_15[1]
	Name = "Cycle 1"
    if ShowOtherQuantumAsBoxes
        if CurrentTicker == "BTC" or CurrentTicker == "ETH"
            Function_Draw_As_Boxes(o_15, h_15, l_15, c_15, left_15, right_15+ONE_DAY, a_ses_15_m, a_ses_15_d, a_ses_15_mt, a_ses_15_dt, Name)
        else
            Function_Draw_As_Boxes(o_15, h_15, l_15, c_15, left_15, right_15, a_ses_15_m, a_ses_15_d, a_ses_15_mt, a_ses_15_dt, Name)
    else
        f_ses_map(o_15, h_15, l_15, c_15, left_15, right_15, a_ses_15_m, a_ses_15_d, a_ses_15_mt, a_ses_15_dt)

    if ShowTable and ShowCycle1
        m_avg = a_ses_15_m.avg()
        d_avg = a_ses_15_d.avg()
        mt_avg = a_ses_15_mt.avg()
        dt_avg = a_ses_15_dt.avg()

        table.cell(Table, 0, 15, Name, text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 1, 15, str.tostring(FunctionRoundFloat(m_avg, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 2, 15, str.tostring(FunctionRoundFloat(m_avg+(d_avg-m_avg)/2, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 3, 15, str.tostring(FunctionRoundFloat(2*m_avg+2*(d_avg-m_avg)/2, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 4, 15, str.tostring(FunctionRoundFloat(2*d_avg, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 5, 15, str.format_time(left_15 + mt_avg, "HH:mm", Timezone), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 6, 15, str.format_time(left_15 + dt_avg, "HH:mm", Timezone), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)


if ses_16 and not ses_16[1]
	Name = "Cycle 2"
    if ShowOtherQuantumAsBoxes
        Function_Draw_As_Boxes(o_16, h_16, l_16, c_16, left_16, right_16, a_ses_16_m, a_ses_16_d, a_ses_16_mt, a_ses_16_dt, Name)
    else
        f_ses_map(o_16, h_16, l_16, c_16, left_16, right_16, a_ses_16_m, a_ses_16_d, a_ses_16_mt, a_ses_16_dt)

    if ShowTable and ShowCycle2
        m_avg = a_ses_16_m.avg()
        d_avg = a_ses_16_d.avg()
        mt_avg = a_ses_16_mt.avg()
        dt_avg = a_ses_16_dt.avg()

        table.cell(Table, 0, 16, Name, text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 1, 16, str.tostring(FunctionRoundFloat(m_avg, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 2, 16, str.tostring(FunctionRoundFloat(m_avg+(d_avg-m_avg)/2, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 3, 16, str.tostring(FunctionRoundFloat(2*m_avg+2*(d_avg-m_avg)/2, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 4, 16, str.tostring(FunctionRoundFloat(2*d_avg, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 5, 16, str.format_time(left_16 + mt_avg, "HH:mm", Timezone), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 6, 16, str.format_time(left_16 + dt_avg, "HH:mm", Timezone), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)


if ses_17 and not ses_17[1]
	Name = "Cycle 3"
    if ShowOtherQuantumAsBoxes
        Function_Draw_As_Boxes(o_17, h_17, l_17, c_17, left_17, right_17, a_ses_17_m, a_ses_17_d, a_ses_17_mt, a_ses_17_dt, Name)
    else
        f_ses_map(o_17, h_17, l_17, c_17, left_17, right_17, a_ses_17_m, a_ses_17_d, a_ses_17_mt, a_ses_17_dt)

    if ShowTable and ShowCycle3
        m_avg = a_ses_17_m.avg()
        d_avg = a_ses_17_d.avg()
        mt_avg = a_ses_17_mt.avg()
        dt_avg = a_ses_17_dt.avg()

        table.cell(Table, 0, 17, Name, text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 1, 17, str.tostring(FunctionRoundFloat(m_avg, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 2, 17, str.tostring(FunctionRoundFloat(m_avg+(d_avg-m_avg)/2, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 3, 17, str.tostring(FunctionRoundFloat(2*m_avg+2*(d_avg-m_avg)/2, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 4, 17, str.tostring(FunctionRoundFloat(2*d_avg, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 5, 17, str.format_time(left_17 + mt_avg, "HH:mm", Timezone), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 6, 17, str.format_time(left_17 + dt_avg, "HH:mm", Timezone), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)


if ses_18 and not ses_18[1]
	Name = "Cycle 4"
    if ShowOtherQuantumAsBoxes
        Function_Draw_As_Boxes(o_18, h_18, l_18, c_18, left_18, right_18, a_ses_18_m, a_ses_18_d, a_ses_18_mt, a_ses_18_dt, Name)
    else
        f_ses_map(o_18, h_18, l_18, c_18, left_18, right_18, a_ses_18_m, a_ses_18_d, a_ses_18_mt, a_ses_18_dt)

    if ShowTable and ShowCycle4
        m_avg = a_ses_18_m.avg()
        d_avg = a_ses_18_d.avg()
        mt_avg = a_ses_18_mt.avg()
        dt_avg = a_ses_18_dt.avg()

        table.cell(Table, 0, 18, Name, text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 1, 18, str.tostring(FunctionRoundFloat(m_avg, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 2, 18, str.tostring(FunctionRoundFloat(m_avg+(d_avg-m_avg)/2, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 3, 18, str.tostring(FunctionRoundFloat(2*m_avg+2*(d_avg-m_avg)/2, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 4, 18, str.tostring(FunctionRoundFloat(2*d_avg, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 5, 18, str.format_time(left_18 + mt_avg, "HH:mm", Timezone), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 6, 18, str.format_time(left_18 + dt_avg, "HH:mm", Timezone), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)


if ses_19 and not ses_19[1]
	Name = "Cycle 5"
    if ShowOtherQuantumAsBoxes
        Function_Draw_As_Boxes(o_19, h_19, l_19, c_19, left_19, right_19-ONE_DAY, a_ses_19_m, a_ses_19_d, a_ses_19_mt, a_ses_19_dt, Name)
    else
        f_ses_map(o_19, h_19, l_19, c_19, left_19, right_19, a_ses_19_m, a_ses_19_d, a_ses_19_mt, a_ses_19_dt)

    if ShowTable and ShowCycle5
        m_avg = a_ses_19_m.avg()
        d_avg = a_ses_19_d.avg()
        mt_avg = a_ses_19_mt.avg()
        dt_avg = a_ses_19_dt.avg()

        table.cell(Table, 0, 19, Name, text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 1, 19, str.tostring(FunctionRoundFloat(m_avg, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 2, 19, str.tostring(FunctionRoundFloat(m_avg+(d_avg-m_avg)/2, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 3, 19, str.tostring(FunctionRoundFloat(2*m_avg+2*(d_avg-m_avg)/2, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 4, 19, str.tostring(FunctionRoundFloat(2*d_avg, 2)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 5, 19, str.format_time(left_19 + mt_avg, "HH:mm", Timezone), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
        table.cell(Table, 6, 19, str.format_time(left_19 + dt_avg, "HH:mm", Timezone), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)


// Update the session averages:

if ses_1[1] and not ses_1
    f_array_maint(a_ses_1_m, m_1, i_ses_1_n)
    f_array_maint(a_ses_1_d, d_1, i_ses_1_n)
    f_array_maint(a_ses_1_mt, mt_1, i_ses_1_n)
    f_array_maint(a_ses_1_dt, dt_1, i_ses_1_n)
if ses_2[1] and not ses_2
    f_array_maint(a_ses_2_m, m_2, i_ses_2_n)
    f_array_maint(a_ses_2_d, d_2, i_ses_2_n)
    f_array_maint(a_ses_2_mt, mt_2, i_ses_2_n)
    f_array_maint(a_ses_2_dt, dt_2, i_ses_2_n)
if ses_3[1] and not ses_3
    f_array_maint(a_ses_3_m, m_3, i_ses_3_n)
    f_array_maint(a_ses_3_d, d_3, i_ses_3_n)
    f_array_maint(a_ses_3_mt, mt_3, i_ses_3_n)
    f_array_maint(a_ses_3_dt, dt_3, i_ses_3_n)
if ses_4[1] and not ses_4
    f_array_maint(a_ses_4_m, m_4, i_ses_4_n)
    f_array_maint(a_ses_4_d, d_4, i_ses_4_n)
    f_array_maint(a_ses_4_mt, mt_4, i_ses_4_n)
    f_array_maint(a_ses_4_dt, dt_4, i_ses_4_n)
if ses_5[1] and not ses_5
    f_array_maint(a_ses_5_m, m_5, i_ses_5_n)
    f_array_maint(a_ses_5_d, d_5, i_ses_5_n)
    f_array_maint(a_ses_5_mt, mt_5, i_ses_5_n)
    f_array_maint(a_ses_5_dt, dt_5, i_ses_5_n)
if ses_6[1] and not ses_6
    f_array_maint(a_ses_6_m, m_6, i_ses_6_n)
    f_array_maint(a_ses_6_d, d_6, i_ses_6_n)
    f_array_maint(a_ses_6_mt, mt_6, i_ses_6_n)
    f_array_maint(a_ses_6_dt, dt_6, i_ses_6_n)
if ses_7[1] and not ses_7
    f_array_maint(a_ses_7_m, m_7, i_ses_7_n)
    f_array_maint(a_ses_7_d, d_7, i_ses_7_n)
    f_array_maint(a_ses_7_mt, mt_7, i_ses_7_n)
    f_array_maint(a_ses_7_dt, dt_7, i_ses_7_n)
if ses_8[1] and not ses_8
    f_array_maint(a_ses_8_m, m_8, i_ses_8_n)
    f_array_maint(a_ses_8_d, d_8, i_ses_8_n)
    f_array_maint(a_ses_8_mt, mt_8, i_ses_8_n)
    f_array_maint(a_ses_8_dt, dt_8, i_ses_8_n)
if ses_9[1] and not ses_9
    f_array_maint(a_ses_9_m, m_9, i_ses_9_n)
    f_array_maint(a_ses_9_d, d_9, i_ses_9_n)
    f_array_maint(a_ses_9_mt, mt_9, i_ses_9_n)
    f_array_maint(a_ses_9_dt, dt_9, i_ses_9_n)
if ses_10[1] and not ses_10
    f_array_maint(a_ses_10_m, m_10, i_ses_10_n)
    f_array_maint(a_ses_10_d, d_10, i_ses_10_n)
    f_array_maint(a_ses_10_mt, mt_10, i_ses_10_n)
    f_array_maint(a_ses_10_dt, dt_10, i_ses_10_n)
if ses_10[1] and not ses_10
    f_array_maint(a_ses_10_m, m_10, i_ses_10_n)
    f_array_maint(a_ses_10_d, d_10, i_ses_10_n)
    f_array_maint(a_ses_10_mt, mt_10, i_ses_10_n)
    f_array_maint(a_ses_10_dt, dt_10, i_ses_10_n)
if ses_11[1] and not ses_11
    f_array_maint(a_ses_11_m, m_11, i_ses_11_n)
    f_array_maint(a_ses_11_d, d_11, i_ses_11_n)
    f_array_maint(a_ses_11_mt, mt_11, i_ses_11_n)
    f_array_maint(a_ses_11_dt, dt_11, i_ses_11_n)	
if ses_12[1] and not ses_12
    f_array_maint(a_ses_12_m, m_12, i_ses_12_n)
    f_array_maint(a_ses_12_d, d_12, i_ses_12_n)
    f_array_maint(a_ses_12_mt, mt_12, i_ses_12_n)
    f_array_maint(a_ses_12_dt, dt_12, i_ses_12_n)
if ses_13[1] and not ses_13
    f_array_maint(a_ses_13_m, m_13, i_ses_13_n)
    f_array_maint(a_ses_13_d, d_13, i_ses_13_n)
    f_array_maint(a_ses_13_mt, mt_13, i_ses_13_n)
    f_array_maint(a_ses_13_dt, dt_13, i_ses_13_n)
if ses_14[1] and not ses_14
    f_array_maint(a_ses_14_m, m_14, i_ses_14_n)
    f_array_maint(a_ses_14_d, d_14, i_ses_14_n)
    f_array_maint(a_ses_14_mt, mt_14, i_ses_14_n)
    f_array_maint(a_ses_14_dt, dt_14, i_ses_14_n)
if ses_15[1] and not ses_15
    f_array_maint(a_ses_15_m, m_15, i_ses_15_n)
    f_array_maint(a_ses_15_d, d_15, i_ses_15_n)
    f_array_maint(a_ses_15_mt, mt_15, i_ses_15_n)
    f_array_maint(a_ses_15_dt, dt_15, i_ses_15_n)
if ses_16[1] and not ses_16
    f_array_maint(a_ses_16_m, m_16, i_ses_16_n)
    f_array_maint(a_ses_16_d, d_16, i_ses_16_n)
    f_array_maint(a_ses_16_mt, mt_16, i_ses_16_n)
    f_array_maint(a_ses_16_dt, dt_16, i_ses_16_n)
if ses_17[1] and not ses_17
    f_array_maint(a_ses_17_m, m_17, i_ses_17_n)
    f_array_maint(a_ses_17_d, d_17, i_ses_17_n)
    f_array_maint(a_ses_17_mt, mt_17, i_ses_17_n)
    f_array_maint(a_ses_17_dt, dt_17, i_ses_17_n)
if ses_18[1] and not ses_18
    f_array_maint(a_ses_18_m, m_18, i_ses_18_n)
    f_array_maint(a_ses_18_d, d_18, i_ses_18_n)
    f_array_maint(a_ses_18_mt, mt_18, i_ses_18_n)
    f_array_maint(a_ses_18_dt, dt_18, i_ses_18_n)
if ses_19[1] and not ses_19
    f_array_maint(a_ses_19_m, m_19, i_ses_19_n)
    f_array_maint(a_ses_19_d, d_19, i_ses_19_n)
    f_array_maint(a_ses_19_mt, mt_19, i_ses_19_n)
    f_array_maint(a_ses_19_dt, dt_19, i_ses_19_n)
		
// } --------------------- END QUANTUM DISTRIBUTION CYCLES ---------------------




// { --------------------- START QUANTUM DR CYCLE Ranges ---------------------

CreateLineWithLabel(_LineX1, _LineY1,_LineX2, _Color, _Style, _Width, _Label) =>
    Line = line.new(_LineX1, _LineY1, _LineX2,_LineY1, xloc.bar_time, color = _Color, style = _Style, width = _Width)
    Label = label.new(_LineX2, _LineY1,_Label, xloc.bar_time, style = label.style_label_left, color =color.new(color.green, 100), textcolor = _Color, size = size.small)
    LineWithLabel.new(Line, Label)

session(_session) => 
    not na(time(timeframe.period, _session, Timezone))

IsSessionOver(_Session) =>
    inSess = not na(time(timeframe.period, _Session, Timezone))
    not inSess and inSess[1]

CalculatePoiMidpoint(_Open,_Close) =>
    OcDiffMid = math.abs(_Open-_Close)/2
    if _Open > _Close
        _Close+OcDiffMid
    else
        _Open+OcDiffMid


CreateNewSession(_OpenTime,_OpenPrice,_CloseTime,_ClosePrice,_CycleEndTime, _High, _Low, _CloseHigh, _CloseLow, _SessionConfirmation, _CurrentArtefact,_MatrixBoxObject) =>
    line OpenLine = na
    line CloseLine = na
    line FractalEqLine = na
    line DrHighLine = na
    line DrLowLine = na
    line IdrHighLine = na
    line IdrLowLine = na
    line IdrMidpointLine = na
    box CloseBoxCurrent = na
    box IdrBoxCurrent = na

    box ClusterHigh = na
    line ClusterHighMidpoint = na
    box ClusterLow = na
    line ClusterLowMidpoint = na
    BoxWithLines MatrixBoxObject = BoxWithLines.new(array.new<box>(), array.new<line>())

    CycleEnd = timestamp(Timezone, year, month, dayofmonth, hour(_CycleEndTime), minute(_CycleEndTime))+TickerTimeOffset 


    if ShowClusters
        if (ShowTuesdayCluster) and str.contains ("Tue", str.format_time(time, "E")) and _CurrentArtefact.SesionString == "0930-1030"
            ClusterHigh := box.new(_OpenTime,_High,CycleEnd,_CloseHigh, xloc = xloc.bar_time,border_color = TuesdayClusterHighBorderColor, bgcolor = TuesdayClusterHighColor, border_width = 1,text = "Tue", text_size = size.auto, text_halign = text.align_right, text_valign = text.align_center, text_color = TuesdayClusterHighBorderColor)
            ClusterHighMidpoint := line.new(_OpenTime, _CloseHigh+(_High-_CloseHigh)/2, CycleEnd, _CloseHigh+(_High-_CloseHigh)/2, xloc.bar_time, color = TuesdayClusterHighBorderColor, style = line.style_dashed, width = 1)
            ClusterLow := box.new(_OpenTime,_Low,CycleEnd,_CloseLow, xloc = xloc.bar_time,border_color = TuesdayClusterLowBorderColor, bgcolor = TuesdayClusterLowColor, border_width = 1,text = "Tue", text_size = size.auto, text_halign = text.align_right, text_valign = text.align_center, text_color = TuesdayClusterLowBorderColor)
            ClusterLowMidpoint := line.new(_OpenTime, _CloseLow+(_Low-_CloseLow)/2, CycleEnd, _CloseLow+(_Low-_CloseLow)/2, xloc.bar_time, color = TuesdayClusterLowBorderColor, style = line.style_dashed, width = 1)
        else
            ClusterHigh := box.new(_OpenTime,_High,CycleEnd,_CloseHigh, xloc = xloc.bar_time,border_color = ClusterHighBorderColor, bgcolor = ClusterHighColor, border_width = 1, text_size = size.auto, text_halign = text.align_right, text_valign = text.align_center)
            ClusterHighMidpoint := line.new(_OpenTime, _CloseHigh+(_High-_CloseHigh)/2, CycleEnd, _CloseHigh+(_High-_CloseHigh)/2, xloc.bar_time, color = ClusterHighBorderColor, style = line.style_dashed, width = 1)
            ClusterLow := box.new(_OpenTime,_Low,CycleEnd,_CloseLow, xloc = xloc.bar_time,border_color = ClusterLowBorderColor, bgcolor = ClusterLowColor, border_width = 1, text_size = size.auto, text_halign = text.align_right, text_valign = text.align_center)
            ClusterLowMidpoint := line.new(_OpenTime, _CloseLow+(_Low-_CloseLow)/2, CycleEnd, _CloseLow+(_Low-_CloseLow)/2, xloc.bar_time, color = ClusterLowBorderColor, style = line.style_dashed, width = 1)
                    
    if ShowTuesdayCluster and not ShowClusters and str.contains ("Tue", str.format_time(time, "E")) and _CurrentArtefact.SesionString == "0930-1030"
        ClusterHigh := box.new(_OpenTime,_High,CycleEnd,_CloseHigh, xloc = xloc.bar_time,border_color = TuesdayClusterHighBorderColor, bgcolor = TuesdayClusterHighColor, border_width = 1,text = "Tue", text_size = size.auto, text_halign = text.align_right, text_valign = text.align_center, text_color = TuesdayClusterHighBorderColor)
        ClusterHighMidpoint := line.new(_OpenTime, _CloseHigh+(_High-_CloseHigh)/2, CycleEnd, _CloseHigh+(_High-_CloseHigh)/2, xloc.bar_time, color = TuesdayClusterHighBorderColor, style = line.style_dashed, width = 1)
        ClusterLow := box.new(_OpenTime,_Low,CycleEnd,_CloseLow, xloc = xloc.bar_time,border_color = TuesdayClusterLowBorderColor, bgcolor = TuesdayClusterLowColor, border_width = 1,text = "Tue", text_size = size.auto, text_halign = text.align_right, text_valign = text.align_center, text_color = TuesdayClusterLowBorderColor)
        ClusterLowMidpoint := line.new(_OpenTime, _CloseLow+(_Low-_CloseLow)/2, CycleEnd, _CloseLow+(_Low-_CloseLow)/2, xloc.bar_time, color = TuesdayClusterLowBorderColor, style = line.style_dashed, width = 1)



    if _OpenTime >  CycleEnd
        CycleEnd := CycleEnd+ONE_DAY
    else if CurrentTicker == "BTC" or CurrentTicker == "ETH"
        CycleEnd := CycleEnd-(ONE_HOUR*5)

    if ShowOpenLine
        OpenLine := line.new(_OpenTime, _OpenPrice, CycleEnd, _OpenPrice, xloc.bar_time, color = OpenLineColor, style = OpenEqLineStyle, width = 1)
    if ShowCloseLine
        CloseLine := line.new(_OpenTime, _ClosePrice, CycleEnd, _ClosePrice, xloc.bar_time, color = CloseLineColor, style = CloseEqLineStyle, width = 1)

    Eq = CalculatePoiMidpoint(_OpenPrice, _ClosePrice)    
    if ShowFractalEqLine        
        FractalEqLine := line.new(_OpenTime, Eq, _CloseTime, Eq, xloc.bar_time, color = FractalEqLineColor, style = FractalEqLineStyle, width = 2)

    if ShowDrLine
        DrHighLine := line.new(_OpenTime, _High, CycleEnd, _High, xloc = xloc.bar_time, color = DrLineColor, style = DrLineLineStyle, width = 1)
        DrLowLine := line.new(_OpenTime, _Low, CycleEnd, _Low, xloc = xloc.bar_time, color = DrLineColor, style = DrLineLineStyle, width = 1)
    if ShowIdrLine
        IdrHighLine := line.new(_OpenTime, _CloseHigh, CycleEnd, _CloseHigh, xloc = xloc.bar_time, color = IdrLineColor, style = IdrLineLineStyle, width = 1)
        IdrLowLine := line.new(_OpenTime, _CloseLow, CycleEnd, _CloseLow, xloc = xloc.bar_time, color = IdrLineColor, style = IdrLineLineStyle, width = 1)
    if ShowIdrMidpoint
        Midpoint = _CloseLow + (_CloseHigh-_CloseLow)/2
        IdrMidpointLine := line.new(_OpenTime, Midpoint, CycleEnd, Midpoint, xloc = xloc.bar_time, color = IdrMidpointLineColor, style = IdrMidpointLineStyle, width = 1)

    color BoxColor = na
    color BoxBorder = na

    color IdrBoxColor = na
    color IdrBoxBorder = na

    if _OpenPrice < _ClosePrice
        BoxColor := FractalEqBoxUpColor
        BoxBorder := FractalEqBoxUpBorderColor
        IdrBoxColor := IdrBoxUpColor
        IdrBoxBorder := IdrBoxUpBorderColor
    else if _OpenPrice > _ClosePrice
        BoxColor := FractalEqBoxDownColor
        BoxBorder := FractalEqBoxDownBorderColor
        IdrBoxColor := IdrBoxDownColor
        IdrBoxBorder := IdrBoxDownBorderColor
    else
        BoxColor := color.new(color.gray, 90)
        BoxBorder := color.new(color.gray, 50)
        IdrBoxColor := color.new(color.gray, 90)
        IdrBoxBorder := color.new(color.gray, 50)

    if ShowOCBox
        // Calculate extended end time for OC box if extension is enabled
        OCBoxEndTime = _CloseTime
        if ExtendOCBoxForward > 0
            // Calculate the original session duration
            sessionDuration = _CloseTime - _OpenTime
            // Extend by N times the original duration
            OCBoxEndTime := _CloseTime + (sessionDuration * ExtendOCBoxForward)
        
        CloseBoxCurrent :=  box.new(_OpenTime,_OpenPrice, OCBoxEndTime,_ClosePrice, xloc = xloc.bar_time, bgcolor = BoxColor, border_color = BoxBorder, border_width = 1)
    if ShowIdrBox
        IdrBoxCurrent := box.new(_OpenTime,_CloseHigh, _CloseTime,_CloseLow, xloc = xloc.bar_time, bgcolor = BoxColor, border_color = BoxBorder, border_width = 1)

    string BelowAboveString = na

    if close > Eq
        BelowAboveString := "Above"
    else if close < Eq
        BelowAboveString := "Below"
    else
        BelowAboveString := "Mitigated"


    array<LineWithLabel> AllMatrixProjections = array.new<LineWithLabel>()
    if _CurrentArtefact.ShowMatrixProjections and not ShowProjectionsAsBoxes                 
        float MatrixRangeLow = na
        float MatrixRange = na

        if RangeStyle == "OC" and ManualRangeProjection
            if _OpenPrice < _ClosePrice
                MatrixRangeLow := _OpenPrice
                MatrixRange := math.abs(_ClosePrice-_OpenPrice)
            else
                MatrixRangeLow := _ClosePrice
                MatrixRange := math.abs(_ClosePrice-_OpenPrice)
        else if RangeStyle == "IDR" and ManualRangeProjection
            MatrixRangeLow := _CloseLow
            MatrixRange := (_CloseHigh-_CloseLow)

        else if RangeStyle == "DR" and ManualRangeProjection
            MatrixRangeLow := _Low
            MatrixRange := (_High-_Low)
        else 
            if math.abs(_ClosePrice-_OpenPrice)*0.4 > (_CloseHigh-_CloseLow)
                if _OpenPrice < _ClosePrice
                    MatrixRangeLow := _OpenPrice
                    MatrixRange := math.abs(_ClosePrice-_OpenPrice)
                else
                    MatrixRangeLow := _ClosePrice
                    MatrixRange := math.abs(_ClosePrice-_OpenPrice)
            else
                MatrixRangeLow := _CloseLow
                MatrixRange := (_CloseHigh-_CloseLow)        


        for i = 0 to array.size(ArrayOfMatrixRanges)-1
            CurrentMatrixRange = array.get(ArrayOfMatrixRanges, i)
            Range = MatrixRangeLow+MatrixRange*CurrentMatrixRange
            array.push(AllMatrixProjections, CreateLineWithLabel(_OpenTime,Range,CycleEnd,MatrixProjectionColors, line.style_dotted,1,str.tostring(CurrentMatrixRange)))
    else if _CurrentArtefact.ShowMatrixProjections and ShowProjectionsAsBoxes and not ShowOnlyRelevantProjections
        float MatrixRangeLow = na
        float MatrixRange = na
        array<box> MatrixBoxes = array.new<box>()
        array<line> MatrixLines = array.new<line>()

        if RangeStyle == "OC" and ManualRangeProjection
            if _OpenPrice < _ClosePrice
                MatrixRangeLow := _OpenPrice
                MatrixRange := math.abs(_ClosePrice-_OpenPrice)
            else
                MatrixRangeLow := _ClosePrice
                MatrixRange := math.abs(_ClosePrice-_OpenPrice)
        else if RangeStyle == "IDR" and ManualRangeProjection
            MatrixRangeLow := _CloseLow
            MatrixRange := (_CloseHigh-_CloseLow)

        else if RangeStyle == "DR" and ManualRangeProjection
            MatrixRangeLow := _Low
            MatrixRange := (_High-_Low)
        else 
            if math.abs(_ClosePrice-_OpenPrice)*0.4 > (_CloseHigh-_CloseLow)
                if _OpenPrice < _ClosePrice
                    MatrixRangeLow := _OpenPrice
                    MatrixRange := math.abs(_ClosePrice-_OpenPrice)
                else
                    MatrixRangeLow := _ClosePrice
                    MatrixRange := math.abs(_ClosePrice-_OpenPrice)
            else
                MatrixRangeLow := _CloseLow
                MatrixRange := (_CloseHigh-_CloseLow)

    if ShowProjectionOnFirstCandle
        MatrixBoxObject := _MatrixBoxObject

    CurrentSessionObject = SessionObject.new(OpenLine, CloseLine, FractalEqLine, DrHighLine, DrLowLine, IdrHighLine, IdrLowLine, IdrMidpointLine, CloseBoxCurrent, IdrBoxCurrent, Eq, BelowAboveString, _OpenTime, na, na, na, na, na, na, _High, _Low, CycleEnd,false,na,_SessionConfirmation,"NotInSession", ClusterHigh, ClusterLow, ClusterHighMidpoint, ClusterLowMidpoint,_CloseHigh, _CloseLow,ArrayUpperBoxValue,ArrayLowerBoxValue,MatrixBoxObject,_CurrentArtefact.Open,_CurrentArtefact.Close,_CurrentArtefact.FirstCandleHigh,_CurrentArtefact.FirstCandleLow, na, _CurrentArtefact.Name, na, na, na, na, _CloseTime) // Pass _CurrentArtefact.Name here // Pass _CloseTime
    array.push(ArrayOfFractalObjects, CurrentSessionObject)


    ClusterArrayChanged = false

    if ShowBiggestCluster and _CurrentArtefact.SesionString == "0930-1030"
        array.push(ArrayOfClusterRdrObjects, CurrentSessionObject)
        ClusterArrayChanged := true
        if array.size(ArrayOfClusterRdrObjects) > NumberOfClustersBack 
            CurrentCluster = array.shift(ArrayOfClusterRdrObjects)

    [CurrentSessionObject,ClusterArrayChanged]


if ShowTable
    table.cell(Table, 0, 0, "N: " + str.tostring(array.size(a_ses_1_m)), text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
    table.cell(Table, 1, 0, "A", text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
    table.cell(Table, 2, 0, "M", text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
    table.cell(Table, 3, 0, "D1", text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
    table.cell(Table, 4, 0, "D2", text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
    table.cell(Table, 5, 0, "T1", text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)
    table.cell(Table, 6, 0, "T2", text_color = TableTextColor , text_size = TableTextSize,text_halign = text.align_left)


var bool BullConfirmationMark = false
var bool BearConfirmationMark = false



GetSessionTimes(_Session, _GetStartTime) =>
    ArrayOfTimes = str.split(_Session, "-")
    StringStartTime = array.get((ArrayOfTimes), 0)
    StringEndTime = array.get((ArrayOfTimes), 1)  
    SessionStartHour = int(str.tonumber(str.substring(StringStartTime, 0, 2)))
    SessionStartMinute = int(str.tonumber(str.substring(StringStartTime, 2, 4)))
    SessionEndHour = int(str.tonumber(str.substring(StringEndTime, 0, 2)))
    SessionEndMinute = int(str.tonumber(str.substring(StringEndTime, 2, 4)))
    if _GetStartTime
        timestamp(Timezone, year, month, dayofmonth, SessionStartHour, SessionStartMinute, 0)
    else
        timestamp(Timezone, year, month, dayofmonth, SessionEndHour, SessionEndMinute, 0)

SessionCalculation(_SessionString,_PreviousSessionState) => 

    SessionState = _PreviousSessionState
    SessionStartTime = GetSessionTimes(_SessionString, true)
    SessionEndTime = GetSessionTimes(_SessionString, false)

    if SessionState == "NotInSession" and hour(time) == hour(SessionStartTime) and minute(time) == minute(SessionStartTime)
        SessionState := "SessionStart"
    else if SessionState == "SessionStart"
        SessionState := "InSession"
    else if SessionState == "InSession" and hour(time) == hour(SessionEndTime) and minute(time) == minute(SessionEndTime)
        SessionState := "EndOfSession"
    else if SessionState == "EndOfSession"
        SessionState := "NotInSession"
   
    SessionState


[M5_Close] = request.security(syminfo.tickerid, '5', [close], lookahead = barmerge.lookahead_on)
Use_M5 = timeframe.in_seconds() < 300
Close = Use_M5 ? M5_Close : close

var bool ClusterArrayHasChanged = false
var BoxWithLines MatrixBoxObject = BoxWithLines.new(array.new<box>(), array.new<line>())

if array.size(ArrayOfSessionDataObjects) > 0

    for i = 0 to array.size(ArrayOfSessionDataObjects)-1
        CurrentArtefact = array.get(ArrayOfSessionDataObjects, i)

        SessionState = SessionCalculation(CurrentArtefact.SesionString, CurrentArtefact.SessionState)
        CurrentArtefact.SessionState := SessionState

        if SessionState == "SessionStart"
            CurrentArtefact.FractalDrawn := false
            CurrentArtefact.Open := open
            CurrentArtefact.High := open
            CurrentArtefact.Low := open
            CurrentArtefact.Close := open
            CurrentArtefact.CloseHigh := open
            CurrentArtefact.CloseLow := open
            CurrentArtefact.OpenTime := time
            CurrentArtefact.FirstCandleHigh := high
            CurrentArtefact.FirstCandleLow := low

            if CurrentArtefact.ShowMatrixProjections and ShowProjectionOnFirstCandle and ShowProjectionsAsBoxes and not ShowOnlyRelevantProjections
                MatrixRangeLow = low
                MatrixRange = high-low
                array<box> MatrixBoxes = array.new<box>()
                array<line> MatrixLines = array.new<line>()
                CycleEnd = timestamp(Timezone, year, month, dayofmonth, hour(CurrentArtefact.CycleEndTime), minute(CurrentArtefact.CycleEndTime))+TickerTimeOffset 

                for j = 0 to array.size(ArrayUpperBoxValue)-1
                    BoxUp = array.get(ArrayUpperBoxValue, j)
                    BoxDown = array.get(ArrayLowerBoxValue,j)
                    color Color = na
                    color ColorBorder = na

                    if BoxUp.Value > 0
                        Color := MatrixBoxUpColor
                        ColorBorder := MatrixBoxUpBorderColor
                    else
                        Color := MatrixBoxDownColor
                        ColorBorder := MatrixBoxDownBorderColor

                    array.push(MatrixBoxes, box.new(time,MatrixRangeLow+(MatrixRange*BoxUp.Value), CycleEnd, MatrixRangeLow+(MatrixRange*BoxDown.Value), xloc = xloc.bar_time, bgcolor = Color, border_color = ColorBorder, border_width = 1))
                    array.push(MatrixLines, line.new(time,MatrixRangeLow+(MatrixRange*2.5),CycleEnd, MatrixRangeLow+(MatrixRange*2.5),color = MatrixBoxUpBorderColor, style = line.style_solid, width = 1, xloc = xloc.bar_time))
                    array.push(MatrixLines, line.new(time,MatrixRangeLow+(MatrixRange*3.6),CycleEnd, MatrixRangeLow+(MatrixRange*3.6),color = MatrixBoxUpBorderColor, style = line.style_solid, width = 1, xloc = xloc.bar_time))
                    array.push(MatrixLines, line.new(time,MatrixRangeLow+(MatrixRange*-1.5),CycleEnd, MatrixRangeLow+(MatrixRange*-1.5),color = MatrixBoxDownBorderColor, style = line.style_solid, width = 1, xloc = xloc.bar_time))
                    array.push(MatrixLines, line.new(time,MatrixRangeLow+(MatrixRange*-2.6),CycleEnd, MatrixRangeLow+(MatrixRange*-2.6),color = MatrixBoxDownBorderColor, style = line.style_solid, width = 1, xloc = xloc.bar_time))

                MatrixBoxObject := BoxWithLines.new(MatrixBoxes,MatrixLines)        

        else if SessionState == "InSession"         
            CurrentArtefact.High := math.max(CurrentArtefact.High, high)
            CurrentArtefact.Low := math.min(CurrentArtefact.Low, low)
            CurrentArtefact.CloseHigh := math.max(CurrentArtefact.CloseHigh, Close)
            CurrentArtefact.CloseLow := math.min(CurrentArtefact.CloseLow, Close)
            CurrentArtefact.CloseTime := time
            CurrentArtefact.Close := Close
        else
            if ShowFractalEqLine and array.size(ArrayOfFractalObjects) > 0   
                for j = 0 to array.size(ArrayOfFractalObjects)-1
                    CurArtefact = array.get(ArrayOfFractalObjects, j)
                    if CurArtefact.BelowAbove == "Above"
                        if low < CurArtefact.EqValue
                            line.set_color(CurArtefact.FractalEq, MitigatedFractalEqLineColor)
                    else if CurArtefact.BelowAbove == "Below"
                        if high > CurArtefact.EqValue
                            line.set_color(CurArtefact.FractalEq, MitigatedFractalEqLineColor)
                    else if CurArtefact.BelowAbove == "Mitigated"
                        line.set_color(CurArtefact.FractalEq, MitigatedFractalEqLineColor)

        if  SessionState == "EndOfSession" //and not CurrentArtefact.FractalDrawn        
            CurrentArtefact.FractalDrawn := true
            CurrentArtefact.ConfirmedDirection := na
          
            [CurrentObject,ClusterArrayChanged] = CreateNewSession(CurrentArtefact.OpenTime,CurrentArtefact.Open,CurrentArtefact.CloseTime,CurrentArtefact.Close, CurrentArtefact.CycleEndTime, CurrentArtefact.High, CurrentArtefact.Low, CurrentArtefact.CloseHigh, CurrentArtefact.CloseLow,CurrentArtefact.SessionConfirmation, CurrentArtefact,MatrixBoxObject)

            ClusterArrayHasChanged := ClusterArrayChanged    

            // if na(CurrentBiggestRdr)
            //     CurrentBiggestRdr := CurrentObject                



if array.size(ArrayOfFractalObjects) > 0        
    for i = 0 to array.size(ArrayOfFractalObjects)-1
        CurrentArtefact = array.get(ArrayOfFractalObjects, i)
        if not CurrentArtefact.SessionConfirmedFractal
            var int TempCounter = na
            CurrentSessionState = SessionCalculation( CurrentArtefact.SessionConfirmationFractal, CurrentArtefact.AfterSessionState)
            CurrentArtefact.AfterSessionState := CurrentSessionState
                
            if CurrentSessionState == "SessionStart"
                CurrentArtefact.SessionConfirmedFractal := false
                CurrentArtefact.ConfirmationDirectionDr := na

                CurrentArtefact.MatrixBoxValuesUp := ArrayUpperBoxValue
                CurrentArtefact.MatrixBoxValuesDown := ArrayLowerBoxValue
                CurrentArtefact.MatrixBoxValuesUp := array.from(MatrixBox.new(74.708, true),MatrixBox.new(37.354, false),MatrixBox.new(18.68, false),MatrixBox.new(9.34, false), MatrixBox.new(4.66, false),MatrixBox.new(-0.66, false),MatrixBox.new(-6.14, na),MatrixBox.new(-13.28, na),MatrixBox.new(-27.5592, na),MatrixBox.new(-55.1184, na))
                CurrentArtefact.MatrixBoxValuesDown := array.from(MatrixBox.new(57.1184, na),MatrixBox.new(28.5592, na),MatrixBox.new(14.28, na), MatrixBox.new(7.14, na),MatrixBox.new(1.66, false),MatrixBox.new(-3.66, false),MatrixBox.new(-8.34, false),MatrixBox.new(-17.68, false),MatrixBox.new(-36.354, false),MatrixBox.new(-73.708, true))
                // CurrentArtefact.ProjectionBoxes.Boxes := array.new<box>()
                // CurrentArtefact.ProjectionBoxes.Lines := array.new<line>()
            if CurrentSessionState == "InSession" or CurrentSessionState == "SessionStart"
                if ShowProjectionsAsBoxes and ShowOnlyRelevantProjections //and CurrentArtefact.ShowMatrixProjections 
                    float MatrixRange = na
                    float MatrixRangeLow = na
                    // array<box> MatrixBoxes = array.new<box>()
                    // array<line> MatrixLines = array.new<line>()
                    OpenPrice = CurrentArtefact.OpenValue
                    ClosePrice = CurrentArtefact.CloseValue
                    CloseHigh = CurrentArtefact.CloseHigh
                    CloseLow = CurrentArtefact.CloseLow
                    OpenTime = CurrentArtefact.OpenTime
                    CycleEnd = CurrentArtefact.CycleEndTimeFractal


                    if RangeStyle == "OC" and ManualRangeProjection
                        if OpenPrice < ClosePrice
                            MatrixRangeLow := OpenPrice
                            MatrixRange := math.abs(ClosePrice-OpenPrice)
                        else
                            MatrixRangeLow := ClosePrice
                            MatrixRange := math.abs(ClosePrice-OpenPrice)
                    else if RangeStyle == "IDR" and ManualRangeProjection
                        MatrixRangeLow := CurrentArtefact.CloseLow
                        MatrixRange := (CurrentArtefact.CloseHigh-CurrentArtefact.CloseLow)

                    else if RangeStyle == "DR" and ManualRangeProjection
                        MatrixRangeLow := CurrentArtefact.LowFractal
                        MatrixRange := (CurrentArtefact.HighFractal-CurrentArtefact.LowFractal)
                    else 
                        if math.abs(ClosePrice-OpenPrice)*0.4 > (CloseHigh-CloseLow)
                            if OpenPrice < ClosePrice
                                MatrixRangeLow := OpenPrice
                                MatrixRange := math.abs(ClosePrice-OpenPrice)
                            else
                                MatrixRangeLow := ClosePrice
                                MatrixRange := math.abs(ClosePrice-OpenPrice)
                        else
                            MatrixRangeLow := CloseLow
                            MatrixRange := (CloseHigh-CloseLow)

                        if ShowProjectionOnFirstCandle
                            MatrixRangeLow := CurrentArtefact.FirstCandleLow
                            MatrixRange := CurrentArtefact.FirstCandleHigh-CurrentArtefact.FirstCandleLow

                        for j = 0 to array.size(ArrayUpperBoxValue)-1
                            BoxUp = array.get(CurrentArtefact.MatrixBoxValuesUp, j)
                            BoxDown = array.get(CurrentArtefact.MatrixBoxValuesDown,j)
                            color Color = na
                            color ColorBorder = na
                            bool Bullish = na

                            if BoxUp.Value > 0
                                Color := MatrixBoxUpColor
                                ColorBorder := MatrixBoxUpBorderColor
                                Bullish := true
                            else
                                Color := MatrixBoxDownColor
                                ColorBorder := MatrixBoxDownBorderColor
                                Bullish := false
                            if BoxUp.Value > 0
                                Color := MatrixBoxUpColor
                                ColorBorder := MatrixBoxUpBorderColor
                            else
                                Color := MatrixBoxDownColor
                                ColorBorder := MatrixBoxDownBorderColor

                            if close > MatrixRangeLow+(MatrixRange*BoxDown.Value) and Bullish and not BoxDown.Drawn 

                                array.push(CurrentArtefact.ProjectionBoxes.Boxes, box.new(OpenTime,MatrixRangeLow+(MatrixRange*BoxUp.Value), CycleEnd, MatrixRangeLow+(MatrixRange*BoxDown.Value), xloc = xloc.bar_time, bgcolor = Color, border_color = ColorBorder, border_width = 1))
                                BoxDown.Drawn := true
                                // if close > SessionLowPrice+(SessionHighLowRange*2.5)
                                array.push(CurrentArtefact.ProjectionBoxes.Lines, line.new(OpenTime,MatrixRangeLow+(MatrixRange*2.5),CycleEnd, MatrixRangeLow+(MatrixRange*2.5),color = ColorBorder, style = line.style_solid, width = 1, xloc = xloc.bar_time))
                                array.push(CurrentArtefact.ProjectionBoxes.Lines, line.new(OpenTime,MatrixRangeLow+(MatrixRange*3.6),CycleEnd, MatrixRangeLow+(MatrixRange*3.6),color = ColorBorder, style = line.style_solid, width = 1, xloc = xloc.bar_time))
                            else if close > MatrixRangeLow+(MatrixRange*BoxUp.Value) and Bullish and not BoxUp.Drawn
                                if  j > 0
                                    BoxUp.Drawn := true
                                    BoxUp := array.get(ArrayUpperBoxValue, j-1)
                                    BoxDown := array.get(ArrayLowerBoxValue,j-1)
                                    array.push(CurrentArtefact.ProjectionBoxes.Boxes, box.new(OpenTime,MatrixRangeLow+(MatrixRange*BoxUp.Value), CycleEnd, MatrixRangeLow+(MatrixRange*BoxDown.Value), xloc = xloc.bar_time, bgcolor = Color, border_color = ColorBorder, border_width = 1))

                            else if close < MatrixRangeLow+(MatrixRange*BoxUp.Value) and not Bullish and not BoxUp.Drawn
                                array.push(CurrentArtefact.ProjectionBoxes.Boxes, box.new(OpenTime,MatrixRangeLow+(MatrixRange*BoxUp.Value), CycleEnd, MatrixRangeLow+(MatrixRange*BoxDown.Value), xloc = xloc.bar_time, bgcolor = Color, border_color = ColorBorder, border_width = 1))
                                BoxUp.Drawn := true
                                array.push(CurrentArtefact.ProjectionBoxes.Lines, line.new(OpenTime,MatrixRangeLow+(MatrixRange*-1.5),CycleEnd, MatrixRangeLow+(MatrixRange*-1.5),color = ColorBorder, style = line.style_solid, width = 1, xloc = xloc.bar_time))
                                array.push(CurrentArtefact.ProjectionBoxes.Lines, line.new(OpenTime,MatrixRangeLow+(MatrixRange*-2.6),CycleEnd, MatrixRangeLow+(MatrixRange*-2.6),color = ColorBorder, style = line.style_solid, width = 1, xloc = xloc.bar_time))
                            else if close < MatrixRangeLow+(MatrixRange*BoxDown.Value) and not Bullish and not BoxDown.Drawn 
                                // array.push(CurrentArtefact.ProjectionBoxes.Boxes, box.new(OpenTime,MatrixRangeLow+(SessionHighLowRange*BoxUp.Value), CycleEndY, MatrixRangeLow+(SessionHighLowRange*BoxDown.Value), xloc = xloc.bar_time, bgcolor = Color, border_color = ColorBorder, border_width = 1))
                                if  j < array.size(ArrayLowerBoxValue)-1
                                    BoxDown.Drawn := true
                                    BoxUp := array.get(ArrayUpperBoxValue, j+1)
                                    BoxDown := array.get(ArrayLowerBoxValue,j+1)                    
                                    array.push(CurrentArtefact.ProjectionBoxes.Boxes, box.new(OpenTime,MatrixRangeLow+(MatrixRange*BoxUp.Value), CycleEnd, MatrixRangeLow+(MatrixRange*BoxDown.Value), xloc = xloc.bar_time, bgcolor = Color, border_color = ColorBorder, border_width = 1))


                            // array.push(MatrixBoxes, box.new(OpenTime,MatrixRangeLow+(MatrixRange*BoxUp.Value), CycleEnd, MatrixRangeLow+(MatrixRange*BoxDown.Value), xloc = xloc.bar_time, bgcolor = Color, border_color = ColorBorder, border_width = 1))
                            // array.push(MatrixLines, line.new(OpenTime,MatrixRangeLow+(MatrixRange*2.5),CycleEnd, MatrixRangeLow+(MatrixRange*2.5),color = MatrixBoxUpBorderColor, style = line.style_solid, width = 1, xloc = xloc.bar_time))
                            // array.push(MatrixLines, line.new(OpenTime,MatrixRangeLow+(MatrixRange*3.6),CycleEnd, MatrixRangeLow+(MatrixRange*3.6),color = MatrixBoxUpBorderColor, style = line.style_solid, width = 1, xloc = xloc.bar_time))
                            // array.push(MatrixLines, line.new(OpenTime,MatrixRangeLow+(MatrixRange*-1.5),CycleEnd, MatrixRangeLow+(MatrixRange*-1.5),color = MatrixBoxDownBorderColor, style = line.style_solid, width = 1, xloc = xloc.bar_time))
                            // array.push(MatrixLines, line.new(OpenTime,MatrixRangeLow+(MatrixRange*-2.6),CycleEnd, MatrixRangeLow+(MatrixRange*-2.6),color = MatrixBoxDownBorderColor, style = line.style_solid, width = 1, xloc = xloc.bar_time))

                            // CurrentArtefact.ProjectionBoxes := BoxWithLines.new(MatrixBoxes,MatrixLines)


                if not CurrentArtefact.SessionConfirmedFractal


                    if close > CurrentArtefact.HighFractal and not CurrentArtefact.SessionConfirmedFractal and barstate.isconfirmed
                        if ShowConfCandleBullBear
                            BullConfirmationMark := true
                        TempCounter := TempCounter+1

                        CurrentArtefact.SessionConfirmedFractal := true
                        CurrentArtefact.ConfirmationDirectionDr := "Long" 
                        ConfirmationTime = time//+TickerTimeOffset
                        CurrentArtefact.ConfirmationTimeValue := ConfirmationTime // Store it
                        CurrentArtefact.ConfirmationCandleOpenValue := open // Populate new field
                        CurrentArtefact.ConfirmationCandleCloseValue := close // Populate new field
                        CandleHigh = high
                        CandleLow = low

                        if ShowConfirmationCandles
                            EndTime = CurrentArtefact.CycleEndTimeFractal

                            if ManualConfirmationCandleExtension
                                EndTime := ConfirmationTime+ExtendConfirmationCandleFor*ONE_HOUR
                            
                            // Add logic for extending base candle by number of session durations
                            if ExtendBaseCandleForward > 0
                                // Calculate the original session duration
                                sessionDuration = CurrentArtefact.CycleEndTimeFractal - CurrentArtefact.OpenTime
                                // Extend by N times the original duration
                                EndTime := CurrentArtefact.CycleEndTimeFractal + (sessionDuration * ExtendBaseCandleForward)
                            CurrentArtefact.ConfirmationCandle := box.new(ConfirmationTime,CandleHigh,EndTime,CandleLow, xloc = xloc.bar_time,border_color = BoxBull_Border_Color, bgcolor = BoxBull_Fill_Color, border_width = BoxBull_Border_Size, text_size = size.auto, text_halign = text.align_right, text_valign = text.align_center, text_color = BoxBull_Border_Color)
                            CurrentArtefact.ConfirmationCandleMidline := line.new(ConfirmationTime,CandleHigh-(CandleHigh-CandleLow)/2, EndTime, CandleHigh-(CandleHigh-CandleLow)/2,color = BoxBull_Border_Color,style = line.style_dashed, xloc = xloc.bar_time)

                            CurrentArtefact.ConfirmationMidpointValue := CandleHigh-(CandleHigh-CandleLow)/2
                            CurrentArtefact.ConfirmationCandleHighValue := CandleHigh
                            CurrentArtefact.ConfirmationCandleLowValue := CandleLow


                    if close < CurrentArtefact.LowFractal and not CurrentArtefact.SessionConfirmedFractal and barstate.isconfirmed
                        if ShowConfCandleBullBear
                            BearConfirmationMark := true
                        TempCounter := TempCounter+1

                        CurrentArtefact.SessionConfirmedFractal := true
                        CurrentArtefact.ConfirmationDirectionDr := "Short"
                        ConfirmationTime = time//+TickerTimeOffset
                        CurrentArtefact.ConfirmationTimeValue := ConfirmationTime // Store it
                        CurrentArtefact.ConfirmationCandleOpenValue := open // Populate new field
                        CurrentArtefact.ConfirmationCandleCloseValue := close // Populate new field
                        CandleHigh = high
                        CandleLow = low

                        if ShowConfirmationCandles
                            EndTime = CurrentArtefact.CycleEndTimeFractal
                            if ManualConfirmationCandleExtension
                                EndTime := ConfirmationTime+ExtendConfirmationCandleFor*ONE_HOUR
                            
                            // Add logic for extending base candle by number of session durations
                            if ExtendBaseCandleForward > 0
                                // Calculate the original session duration
                                sessionDuration = CurrentArtefact.CycleEndTimeFractal - CurrentArtefact.OpenTime
                                // Extend by N times the original duration
                                EndTime := CurrentArtefact.CycleEndTimeFractal + (sessionDuration * ExtendBaseCandleForward)

                            CurrentArtefact.ConfirmationCandle := box.new(ConfirmationTime,CandleHigh,EndTime,CandleLow, xloc = xloc.bar_time,border_color = BoxBear_Border_Color, bgcolor = BoxBear_Fill_Color, border_width = BoxBear_Border_Size, text_size = size.auto, text_halign = text.align_right, text_valign = text.align_center, text_color = BoxBear_Border_Color)
                            CurrentArtefact.ConfirmationCandleMidline := line.new(ConfirmationTime,CandleHigh-(CandleHigh-CandleLow)/2 ,EndTime, CandleHigh-(CandleHigh-CandleLow)/2,color = BoxBear_Border_Color,style = line.style_dashed, xloc = xloc.bar_time)

                            CurrentArtefact.ConfirmationMidpointValue := CandleHigh-(CandleHigh-CandleLow)/2
                            CurrentArtefact.ConfirmationCandleHighValue := CandleHigh
                            CurrentArtefact.ConfirmationCandleLowValue := CandleLow
            else if CurrentSessionState == "EndOfSession"
                CurrentArtefact.SessionConfirmedFractal := true





plotshape(BullConfirmationMark, color = ConfirmationShapeBullColor, location = location.abovebar, style = shape.triangleup, title = "Long Confirmation")
plotshape(BearConfirmationMark, color = ConfirmationShapeBearColor, location = location.belowbar, style = shape.triangledown, title = "Short Confirmation")

BullConfirmationMark := false
BearConfirmationMark := false

ExtendClustersInRealtime = true



if array.size(ArrayOfFractalObjects) > NumberOfHistoricalDrsToShow*NumberOfSessionsToShow
    DeleteArtefact = array.shift(ArrayOfFractalObjects)

    line.delete(DeleteArtefact.Open)
    line.delete(DeleteArtefact.Close)
    line.delete(DeleteArtefact.FractalEq)
    line.delete(DeleteArtefact.DrHigh)
    line.delete(DeleteArtefact.DrLow)
    line.delete(DeleteArtefact.IdrHigh)
    line.delete(DeleteArtefact.IdrLow)
    line.delete(DeleteArtefact.IdrMidpoint)
    box.delete(DeleteArtefact.CloseBox)
    box.delete(DeleteArtefact.IdrBox)
    box.delete(DeleteArtefact.ConfirmationCandle)
    line.delete(DeleteArtefact.ConfirmationCandleMidline)
    if ShowClusters
        box.delete(DeleteArtefact.ClusterHigh)
        box.delete(DeleteArtefact.ClusterLow)
        line.delete(DeleteArtefact.ClusterHighMidpoint)
        line.delete(DeleteArtefact.ClusterLowMidpoint)

    // if not na(DeleteArtefact.ProjectionBoxes)
    while array.size(DeleteArtefact.ProjectionBoxes.Boxes) > 0
        box.delete(array.shift(DeleteArtefact.ProjectionBoxes.Boxes))
        // for i = 0 to array.size(ArrayBoxes)-1
        //     box.delete(array.get(ArrayBoxes,i))
    while array.size(DeleteArtefact.ProjectionBoxes.Lines) > 0
        line.delete(array.shift(DeleteArtefact.ProjectionBoxes.Lines))
        // for i = 0 to array.size(ArrayOfLines)-1
        //     line.delete(array.get(ArrayOfLines,i))

    // if not na(DeleteArtefact.MatrixProjections)
    // if array.size(DeleteArtefact.MatrixProjections) > 0        
    //     for i = 0 to array.size(DeleteArtefact.MatrixProjections)-1
    //         CurrentArtefact = array.get(DeleteArtefact.MatrixProjections, i)
    //         line.delete(CurrentArtefact.Line)
    //         label.delete(CurrentArtefact.Label)



var SessionObject PreviousBiggestRdr = na
var SessionObject BigestRdrInArray = na

if ShowBiggestCluster and array.size(ArrayOfClusterRdrObjects) > 0
    PreviousBiggestRdr := BigestRdrInArray
      
    for i = 0 to array.size(ArrayOfClusterRdrObjects)-1 
        CurrentRdr = array.get(ArrayOfClusterRdrObjects, i)  
        if i == 0
            BigestRdrInArray := array.get(ArrayOfClusterRdrObjects, 0) 
        else
            CloseHigh = CurrentRdr.CloseHigh
            CloseLow = CurrentRdr.CloseLow

            if (CloseHigh - CloseLow) > (BigestRdrInArray.CloseHigh - BigestRdrInArray.CloseLow)
                BigestRdrInArray := CurrentRdr


var ClusterWasInArrayOfFractals = false

if not na(BigestRdrInArray) and not na(PreviousBiggestRdr)
    PreviousBigestOpenTime = PreviousBiggestRdr.OpenTime
    CurrentBiggestOpenTime = BigestRdrInArray.OpenTime
    ClusterWasInArrayOfFractals := false 
    for i = 0 to array.size(ArrayOfFractalObjects)-1
        FractalObject = array.get(ArrayOfFractalObjects, i)
        if PreviousBigestOpenTime == FractalObject.OpenTime
            if (ShowTuesdayCluster) and str.contains ("Tue", str.format_time(FractalObject.OpenTime, "E"))
                box.set_bgcolor(FractalObject.ClusterHigh, TuesdayClusterHighColor)
                box.set_bgcolor(FractalObject.ClusterLow, TuesdayClusterLowColor)
                box.set_border_color(FractalObject.ClusterHigh, TuesdayClusterHighBorderColor)
                box.set_border_color(FractalObject.ClusterLow, TuesdayClusterLowBorderColor)
                line.set_color(FractalObject.ClusterHighMidpoint, TuesdayClusterHighBorderColor)
                line.set_color(FractalObject.ClusterLowMidpoint, TuesdayClusterLowBorderColor)
            else
                box.set_bgcolor(FractalObject.ClusterHigh, ClusterHighColor)
                box.set_bgcolor(FractalObject.ClusterLow, ClusterLowColor)
                box.set_border_color(FractalObject.ClusterHigh, ClusterHighBorderColor)
                box.set_border_color(FractalObject.ClusterLow, ClusterLowBorderColor)
                line.set_color(FractalObject.ClusterHighMidpoint, ClusterHighBorderColor)
                line.set_color(FractalObject.ClusterLowMidpoint, ClusterLowBorderColor)
                
        if CurrentBiggestOpenTime == FractalObject.OpenTime
            box.set_bgcolor(FractalObject.ClusterHigh, LargestClusterHighColor)
            box.set_bgcolor(FractalObject.ClusterLow, LargestClusterLowColor)
            ClusterWasInArrayOfFractals := true

    if (not ClusterWasInArrayOfFractals) and not na(BigestRdrInArray)
        OpenTime = BigestRdrInArray.OpenTime
        High = BigestRdrInArray.HighFractal
        Low = BigestRdrInArray.LowFractal
        CloseHigh = BigestRdrInArray.CloseHigh
        CloseLow = BigestRdrInArray.CloseLow

        box.delete(PreviousBiggestRdr.ClusterHigh)
        box.delete(PreviousBiggestRdr.ClusterLow)
        line.delete(PreviousBiggestRdr.ClusterHighMidpoint)
        line.delete(PreviousBiggestRdr.ClusterLowMidpoint)        

        BigestRdrInArray.ClusterHigh := box.new(OpenTime,High,time,CloseHigh, xloc = xloc.bar_time,border_color = LargestClusterHighBorderColor, bgcolor = LargestClusterHighColor, border_width = 1, text_size = size.auto, text_halign = text.align_right, text_valign = text.align_center, text_color = BoxBull_Border_Color)
        BigestRdrInArray.ClusterHighMidpoint := line.new(OpenTime, CloseHigh+(High-CloseHigh)/2, time, CloseHigh+(High-CloseHigh)/2, xloc.bar_time, color = LargestClusterHighBorderColor, style = line.style_dashed, width = 1)
        BigestRdrInArray.ClusterLow := box.new(OpenTime,Low,time,CloseLow, xloc = xloc.bar_time,border_color = LargestClusterLowBorderColor, bgcolor = LargestClusterLowColor, border_width = 1, text_size = size.auto, text_halign = text.align_right, text_valign = text.align_center, text_color = BoxBull_Border_Color)
        BigestRdrInArray.ClusterLowMidpoint := line.new(OpenTime, CloseLow+(Low-CloseLow)/2, time, CloseLow+(Low-CloseLow)/2, xloc.bar_time, color = LargestClusterLowBorderColor, style = line.style_dashed, width = 1)
        





if array.size(ArrayOfFractalObjects) > 0
    for i = 0 to array.size(ArrayOfFractalObjects)-1
        CurrentArtefact = array.get(ArrayOfFractalObjects, i)
        if ColorConfirmationCandleDirection            
            if CurrentArtefact.ConfirmationDirectionDr == "Long"
                if close < CurrentArtefact.ConfirmationMidpointValue
                    box.set_bgcolor(CurrentArtefact.ConfirmationCandle, BoxInversion_Fill_Color)
                    box.set_border_color(CurrentArtefact.ConfirmationCandle, BoxInversion_Border_Color)
                else
                    box.set_bgcolor(CurrentArtefact.ConfirmationCandle, BoxBull_Fill_Color)
                    box.set_border_color(CurrentArtefact.ConfirmationCandle, BoxBull_Border_Color)
            else if CurrentArtefact.ConfirmationDirectionDr == "Short"
                if close > CurrentArtefact.ConfirmationMidpointValue
                    box.set_bgcolor(CurrentArtefact.ConfirmationCandle, BoxInversion_Fill_Color)
                    box.set_border_color(CurrentArtefact.ConfirmationCandle, BoxInversion_Border_Color) 
                else
                    box.set_bgcolor(CurrentArtefact.ConfirmationCandle, BoxBear_Fill_Color)
                    box.set_border_color(CurrentArtefact.ConfirmationCandle, BoxBear_Border_Color)
        if ExtendConfirmationCandle
            // CurrentArtefact = array.get(ArrayOfFractalObjects, i)
            box.set_right(CurrentArtefact.ConfirmationCandle, time)
            line.set_x2(CurrentArtefact.ConfirmationCandleMidline, time)

        if ExtendClustersInRealtime and ShowClusters
            // for i = 0 to array.size(ArrayOfFractalObjects)-1
            // CurrentArtefact = array.get(ArrayOfFractalObjects, i)
            box.set_right(CurrentArtefact.ClusterHigh, time)
            box.set_right(CurrentArtefact.ClusterLow, time)
            line.set_x2(CurrentArtefact.ClusterHighMidpoint, time)
            line.set_x2(CurrentArtefact.ClusterLowMidpoint, time)
        
        if ExtendClustersInRealtime and ShowTuesdayCluster and not ShowClusters
            box.set_right(CurrentArtefact.ClusterHigh, time)
            box.set_right(CurrentArtefact.ClusterLow, time)
            line.set_x2(CurrentArtefact.ClusterHighMidpoint, time)
            line.set_x2(CurrentArtefact.ClusterLowMidpoint, time)

    // if ExtendClustersInRealtime and ShowBiggestCluster
    //     box.set_right(CurrentBiggestRdr.ClusterHigh, time)
    //     box.set_right(CurrentBiggestRdr.ClusterLow, time)
    //     line.set_x2(CurrentBiggestRdr.ClusterHighMidpoint, time)
    //     line.set_x2(CurrentBiggestRdr.ClusterLowMidpoint, time)



if ExtendFractalLinesInRealtime and array.size(ArrayOfFractalObjects) > 0
    for i = 0 to array.size(ArrayOfFractalObjects)-1
        CurrentArtefact = array.get(ArrayOfFractalObjects, i)
        line.set_x2(CurrentArtefact.FractalEq, time)  


if AllignFractalsRight and array.size(ArrayOfFractalObjects) > 0
    for i = 0 to array.size(ArrayOfFractalObjects)-1
        CurrentArtefact = array.get(ArrayOfFractalObjects, i)
        line.set_x1(CurrentArtefact.FractalEq, time[20])
        line.set_x2(CurrentArtefact.FractalEq, time)  
  

// } --------------------- END QUANTUM DR CYCLE Ranges ---------------------



// { ----------------- Key Candles START -----------------



type HtfLiquidity
    float HighValue
    float LowValue
    bool HighPurged
    bool LowPurged
    bool BullKeyConfirmed
    bool BearKeyConfirmed
    LineWithLabel HighLine
    LineWithLabel LowLine
    int OpenTime
    float PurgedHighClose
    float PurgedLowClose

var array<HtfLiquidity> ArrayOfHtfLiquidity = array.new<HtfLiquidity>(0)

var array<label> ArrayOfPurgeLabels = array.new<label>(0)




ArrayNotEmpty(_Array) =>
    array.size(_Array) > 0 ? true : false

isBuVI(index) =>
    (open[index] > close[index+1] and low[index] <= high[index+1] and close[index] > close[index+1] and open[index] > open[index+1])

isBeVI(index) =>
    (open[index] < close[index+1] and open[index] < open[index+1] and high[index] >= low[index+1] and close[index] < close[index+1] and close[index] < open[index+1])

isBuGap(index) =>  high[1] < low
isBeGap(index) =>  low[1] > high

plotshape(series=isBeVI(0) and ShowDIBs, style=shape.circle, location=location.abovebar, color=color.new(color.red, 73), size=size.auto)
plotshape(series=isBuVI(0)and ShowDIBs, style=shape.circle, location=location.belowbar, color=color.new(color.blue, 73), size=size.auto)
plotshape(series=isBeGap(0)and ShowDIBs, style=shape.circle, location=location.abovebar, color=color.new(color.red, 73), size=size.auto)
plotshape(series=isBuGap(0)and ShowDIBs, style=shape.circle, location=location.belowbar, color=color.new(color.blue, 73), size=size.auto)

[PurgeTf_OpenTime,PurgeTf_HighValue, PurgeTf_LowValue,PurgeTf_CloseTime] = request.security(syminfo.tickerid, KeyTimeframe, [time, high, low, time_close], barmerge.gaps_off, barmerge.lookahead_off)

// Gib_Up = open > close[1]
// Gib_Down = open < close[1]

var bool ShouldDrawBullKeyCandle = false
var bool ShouldDrawBearKeyCandle = false

if ta.change(time(KeyTimeframe)) and barstate.isconfirmed
    HighLabel = ""
    LowLabel = ""
    if ShowKeyTfLabels
        HighLabel := KeyTimeframe+"H" +"/" + str.tostring((time-time)/ONE_HOUR, "##.#")
        LowLabel := KeyTimeframe+"L" +"/" + str.tostring((time-time)/ONE_HOUR, "##.#")

    
    HighLine = CreateLineWithLabel(PurgeTf_CloseTime, PurgeTf_HighValue,PurgeTf_CloseTime+timeframe.in_seconds(KeyTimeframe)*1000, KeyHighLineColor, KeyHighLowStyle, KeyHighLowWidth, HighLabel)
    LowLine = CreateLineWithLabel(PurgeTf_CloseTime, PurgeTf_LowValue,PurgeTf_CloseTime+timeframe.in_seconds(KeyTimeframe)*1000, KeyLowLineColor, KeyHighLowStyle, KeyHighLowWidth, LowLabel)
    if not ShowLiquidityLines
        line.delete(HighLine.Line)
        line.delete(LowLine.Line)
        if ShowKeyTfLabels
            label.delete(HighLine.Label)
            label.delete(LowLine.Label)
    array.push(ArrayOfHtfLiquidity, HtfLiquidity.new(PurgeTf_HighValue,PurgeTf_LowValue, false, false, false, false, HighLine, LowLine,PurgeTf_OpenTime, na, na))

    FirstArtefact = array.get(ArrayOfHtfLiquidity, 0)
    if FirstArtefact.OpenTime < time-(ONE_DAY*KeyNumberOfHistoricalHLDaysBack)
        array.shift(ArrayOfHtfLiquidity)
        line.delete(FirstArtefact.HighLine.Line)
        label.delete(FirstArtefact.HighLine.Label)
        line.delete(FirstArtefact.LowLine.Line)
        label.delete(FirstArtefact.LowLine.Label)


var int AlreadyDrawnLabel = na

var float BullLiquidityPurged = na
var float BearLiquidityPurged = na
var int CountDays = 0

if ta.change(time("D"))
    if CountDays == DaysOfLiquidityForCalculation-1
        BullLiquidityPurged := 0.0
        BearLiquidityPurged := 0.0
        CountDays := 0
    else
        CountDays := CountDays + 1

if ArrayNotEmpty(ArrayOfHtfLiquidity)	
    ArrayIndexSize = array.size(ArrayOfHtfLiquidity)-1		
    for i = 0 to ArrayIndexSize
        CurrentArtefact = array.get(ArrayOfHtfLiquidity,  i)

        // Key Candle Logic
        if i == ArrayIndexSize and not CurrentArtefact.BullKeyConfirmed and CurrentArtefact.LowPurged
            if isBuVI(0) or isBuGap(0)             // open > close[1] and barstate.isconfirmed //open > CurrentArtefact.PurgedHighClose
                CurrentArtefact.BullKeyConfirmed := true
                ShouldDrawBullKeyCandle := true

        if i == ArrayIndexSize and not CurrentArtefact.BearKeyConfirmed and CurrentArtefact.HighPurged
            if isBeVI(0) or isBeGap(0)             //open < close[1] and barstate.isconfirmed // open < CurrentArtefact.PurgedLowClose
                CurrentArtefact.BearKeyConfirmed := true
                ShouldDrawBearKeyCandle := true

        // H/L Manipulation        
        if high > CurrentArtefact.HighValue and not CurrentArtefact.HighPurged
            CurrentArtefact.HighPurged := true
            CurrentArtefact.PurgedHighClose := close
            if RemovePurgedHtfLiquidityLine
                line.delete(CurrentArtefact.HighLine.Line)
                label.delete(CurrentArtefact.HighLine.Label)               
            else
                line.set_color(CurrentArtefact.HighLine.Line, KeyCandleHighPurgedLineColor)
                label.set_textcolor(CurrentArtefact.HighLine.Label, KeyCandleHighPurgedLineColor)
            

            if ShowPurgeLabel and not (AlreadyDrawnLabel == time)
                AlreadyDrawnLabel := time
                BullLiquidityPurged := BullLiquidityPurged + (time-CurrentArtefact.OpenTime)/ONE_HOUR
                array.push(ArrayOfPurgeLabels ,label.new(time, high,"P" + str.tostring((time-CurrentArtefact.OpenTime)/ONE_HOUR, "##.#") + "/" + str.tostring(BullLiquidityPurged, "##.#"), xloc.bar_time, style = label.style_label_down, color =color.new(color.green, 100), textcolor = color.new(color.red, 0), size = size.small))
        else if low < CurrentArtefact.LowValue and not CurrentArtefact.LowPurged
            CurrentArtefact.LowPurged := true
            CurrentArtefact.PurgedLowClose := close
            if RemovePurgedHtfLiquidityLine
                line.delete(CurrentArtefact.LowLine.Line)
                label.delete(CurrentArtefact.LowLine.Label)
            else
                line.set_color(CurrentArtefact.LowLine.Line, KeyCandleLowPurgedLineColor)
                label.set_textcolor(CurrentArtefact.LowLine.Label, KeyCandleLowPurgedLineColor)
            if ShowPurgeLabel and not (AlreadyDrawnLabel == time)
                AlreadyDrawnLabel := time
                BearLiquidityPurged := BearLiquidityPurged + (time-CurrentArtefact.OpenTime)/ONE_HOUR
                array.push(ArrayOfPurgeLabels ,label.new(time, low,"P" +  str.tostring((time-CurrentArtefact.OpenTime)/ONE_HOUR, "##.#") + "/" + str.tostring(BearLiquidityPurged, "##.#"), xloc.bar_time, style = label.style_label_up, color =color.new(color.green, 100), textcolor = color.new(color.green, 0), size = size.small))
        if ShowOnlyLastHftLowHigh
            if i == ArrayIndexSize
                "Do nothing"
            else
                line.delete(CurrentArtefact.HighLine.Line)
                label.delete(CurrentArtefact.HighLine.Label)   
                line.delete(CurrentArtefact.LowLine.Line)
                label.delete(CurrentArtefact.LowLine.Label)            


if array.size(ArrayOfPurgeLabels) > PurgedLabelHistory
    label.delete(array.shift(ArrayOfPurgeLabels))


var array<box> ArrayKeyCandlesBoxes = array.new<box>()
var array<line> ArrayKeyCandleMidpoints = array.new<line>()

var array<float> ArrayKeyCandleMidpointValue = array.new<float>()
var array<string> ArrayKeyCandleDirection = array.new<string>()
var array<label> ArrayKeyCandleDirectionLabels = array.new<label>()
var array<float> ArrayKeyCandleDirectionLabelsHighValue = array.new<float>()
var array<float> ArrayKeyCandleDirectionLabelsLowValue = array.new<float>()


if ShowKeyCandles
    if ShouldDrawBullKeyCandle
        ShouldDrawBullKeyCandle := false

        High = high
        Time = time
        Low = low
        Midpoint = Low+((High-Low)/2)
        array.push(ArrayKeyCandlesBoxes, box.new(Time,High, Time+3600000*ExtendKeyCandlesForNHours,Low, xloc = xloc.bar_time, bgcolor = KeyCandlesBullBoxColor, border_color = KeyCandlesBullBoxBorderColor, border_width = KeyCandlesBullBorderSize))
        array.push(ArrayKeyCandleMidpointValue, Midpoint)
        array.push(ArrayKeyCandleDirection, "Bull")
        array.push(ArrayKeyCandleDirectionLabelsHighValue, High)
        array.push(ArrayKeyCandleDirectionLabelsLowValue, Low)
        if ShowKeyCandlesMidpoints
            array.push(ArrayKeyCandleMidpoints,line.new(Time, Midpoint, Time+3600000*ExtendKeyCandlesForNHours, Midpoint,color = KeyCandleLineColorBull,style = KeyCandleLineStyleBull, xloc = xloc.bar_time))


        array.push(ArrayKeyCandleDirectionLabels, label.new(bar_index, low,"▲", style = label.style_label_up, xloc = xloc.bar_index, color =color.new(color.green, 100), textcolor = color.new(color.green, 10), size =size.normal))
    else if ShouldDrawBearKeyCandle
        ShouldDrawBearKeyCandle := false

        High = high
        Low = low
        Time = time
        Midpoint = Low+((High-Low)/2)
        array.push(ArrayKeyCandlesBoxes, box.new(Time,High, Time+3600000*ExtendKeyCandlesForNHours,Low, xloc = xloc.bar_time, bgcolor = KeyCandlesBearBoxColor, border_color = KeyCandlesBearBoxBorderColor, border_width = KeyCandlesBearBorderSize))
        array.push(ArrayKeyCandleMidpointValue, Midpoint)
        array.push(ArrayKeyCandleDirection, "Bear")
        array.push(ArrayKeyCandleDirectionLabelsHighValue, High)
        array.push(ArrayKeyCandleDirectionLabelsLowValue, Low)
        if ShowKeyCandlesMidpoints
            array.push(ArrayKeyCandleMidpoints,line.new(Time, Midpoint, Time+3600000*ExtendKeyCandlesForNHours, Midpoint,color = KeyCandleLineColorBear,style = KeyCandleLineStyleBear, xloc = xloc.bar_time))

        array.push(ArrayKeyCandleDirectionLabels, label.new(bar_index, high,"▼", style = label.style_label_down, xloc = xloc.bar_index, color =color.new(color.green, 100), textcolor = color.new(color.red, 10), size =size.normal))


if ShowKeyCandles
    if array.size(ArrayKeyCandlesBoxes) > ShowNofKeyCandles
        box.delete(array.shift(ArrayKeyCandlesBoxes))
        array.shift(ArrayKeyCandleMidpointValue)
        array.shift(ArrayKeyCandleDirection)
        label.delete(array.shift(ArrayKeyCandleDirectionLabels))
        array.shift(ArrayKeyCandleDirectionLabelsHighValue)
        array.shift(ArrayKeyCandleDirectionLabelsLowValue)

        if ShowKeyCandlesMidpoints and array.size(ArrayKeyCandleMidpoints) > ShowNofKeyCandles
            line.delete(array.shift(ArrayKeyCandleMidpoints))

    if array.size(ArrayKeyCandleMidpointValue) > 0
        for i = 0 to array.size(ArrayKeyCandleMidpointValue)-1
            if array.get(ArrayKeyCandleDirection, i) == "Bull" 
                if array.get(ArrayKeyCandleMidpointValue, i) > close
                    box.set_bgcolor(array.get(ArrayKeyCandlesBoxes, i), KeyCandlesInversionBoxColor)
                    box.set_border_color(array.get(ArrayKeyCandlesBoxes, i), KeyCandlesInversionBoxBorderColor)
                    label.set_textcolor(array.get(ArrayKeyCandleDirectionLabels, i), color.new(color.purple, 10))
                    label.set_style(array.get(ArrayKeyCandleDirectionLabels, i), label.style_label_down)
                    label.set_y(array.get(ArrayKeyCandleDirectionLabels, i), array.get(ArrayKeyCandleDirectionLabelsHighValue, i)) 
                    label.set_text(array.get(ArrayKeyCandleDirectionLabels, i), "▼")
                else
                    box.set_bgcolor(array.get(ArrayKeyCandlesBoxes, i), KeyCandlesBullBoxColor)
                    box.set_border_color(array.get(ArrayKeyCandlesBoxes, i), KeyCandlesBullBoxBorderColor)
                    label.set_textcolor(array.get(ArrayKeyCandleDirectionLabels, i), color.new(color.green, 10))
                    label.set_style(array.get(ArrayKeyCandleDirectionLabels, i), label.style_label_up)
                    label.set_y(array.get(ArrayKeyCandleDirectionLabels, i), array.get(ArrayKeyCandleDirectionLabelsLowValue, i))
                    label.set_text(array.get(ArrayKeyCandleDirectionLabels, i), "▲")
            else if array.get(ArrayKeyCandleDirection, i) == "Bear" 
                if array.get(ArrayKeyCandleMidpointValue, i) < close
                    box.set_bgcolor(array.get(ArrayKeyCandlesBoxes, i), KeyCandlesInversionBoxColor)
                    box.set_border_color(array.get(ArrayKeyCandlesBoxes, i), KeyCandlesInversionBoxBorderColor)
                    label.set_textcolor(array.get(ArrayKeyCandleDirectionLabels, i), color.new(color.purple, 10))
                    label.set_style(array.get(ArrayKeyCandleDirectionLabels, i), label.style_label_up)
                    label.set_y(array.get(ArrayKeyCandleDirectionLabels, i), array.get(ArrayKeyCandleDirectionLabelsLowValue, i)) 
                    label.set_text(array.get(ArrayKeyCandleDirectionLabels, i), "▲")
                else
                    box.set_bgcolor(array.get(ArrayKeyCandlesBoxes, i), KeyCandlesBearBoxColor)
                    box.set_border_color(array.get(ArrayKeyCandlesBoxes, i), KeyCandlesBearBoxBorderColor)
                    label.set_textcolor(array.get(ArrayKeyCandleDirectionLabels, i), color.new(color.red, 10))
                    label.set_style(array.get(ArrayKeyCandleDirectionLabels, i), label.style_label_down)
                    label.set_y(array.get(ArrayKeyCandleDirectionLabels, i), array.get(ArrayKeyCandleDirectionLabelsHighValue, i))
                    label.set_text(array.get(ArrayKeyCandleDirectionLabels, i), "▼")

if ExtendKeyCandleBoxesInRealtime and array.size(ArrayKeyCandlesBoxes) > 0
    for i = 0 to array.size(ArrayKeyCandlesBoxes)-1
        box.set_right(array.get(ArrayKeyCandlesBoxes,i), time)
        if ShowKeyCandlesMidpoints
            line.set_x2(array.get(ArrayKeyCandleMidpoints, i), time)


if ExtendUnmitigatedHL and array.size(ArrayOfHtfLiquidity) > 0
    for i = 0 to array.size(ArrayOfHtfLiquidity)-1
        CurrentArtefact = array.get(ArrayOfHtfLiquidity, i)
        if not CurrentArtefact.HighPurged
            line.set_x2(CurrentArtefact.HighLine.Line, time)
            if ShowKeyTfLabels
                label.set_x(CurrentArtefact.HighLine.Label, time)
                label.set_text(CurrentArtefact.HighLine.Label, KeyTimeframe+"H" +"/" + str.tostring((time-CurrentArtefact.OpenTime)/ONE_HOUR, "##.#"))
        if not CurrentArtefact.LowPurged
            line.set_x2(CurrentArtefact.LowLine.Line, time)
            if ShowKeyTfLabels
                label.set_x(CurrentArtefact.LowLine.Label, time)
                label.set_text(CurrentArtefact.LowLine.Label, KeyTimeframe+"L" +"/" + str.tostring((time-CurrentArtefact.OpenTime)/ONE_HOUR, "##.#"))         





// } ----------------- Key Candles END -----------------

// Helper function to get anchor price based on type
getSubModelAnchorValue(sessionObject, anchorType) =>
    float value = na
    switch anchorType
        "Base Candle Midpoint" => // Renamed
            value := sessionObject.ConfirmationMidpointValue
        "Base Candle Open" => // Renamed
            value := sessionObject.ConfirmationCandleOpenValue
        "Base Candle Close" => // Renamed
            value := sessionObject.ConfirmationCandleCloseValue
        "Session Open" => // Renamed from Fractal Session Open
            value := sessionObject.OpenValue // This is the fractal session's open
        "Session Close" => // Renamed from Fractal Session Close
            value := sessionObject.CloseValue // This is the fractal session's close
        "Distribution Close" =>
            value := sessionObject.DistributionCloseValue // NEW – distribution close
        "Base Candle High" => // New
            value := sessionObject.ConfirmationCandleHighValue
        "Base Candle Low" => // New
            value := sessionObject.ConfirmationCandleLowValue
        "Session High" => // Renamed from Fractal Session High
            value := sessionObject.HighFractal
        "Session Low" => // Renamed from Fractal Session Low
            value := sessionObject.LowFractal
        "Session EQ" => // Renamed from Fractal EQ
            value := sessionObject.EqValue
        "IDR High" => // New
            value := sessionObject.CloseHigh // Represents IDR High
        "IDR Low" => // New
            value := sessionObject.CloseLow   // Represents IDR Low
    value // Default to na if no match or if underlying values are na

// Helper function to get anchor time based on type
getSubModelAnchorTime(sessionObject, anchorType) =>
    int timeValue = na
    switch anchorType
        "Base Candle Midpoint" => // Renamed
            timeValue := sessionObject.ConfirmationTimeValue
        "Base Candle Open" => // Renamed
            timeValue := sessionObject.ConfirmationTimeValue
        "Base Candle Close" => // Renamed
            timeValue := sessionObject.ConfirmationTimeValue
        "Session Open" => // Renamed from Fractal Session Open
            timeValue := sessionObject.OpenTime // This is the fractal session's open time
        "Session Close" => // Renamed from Fractal Session Close
            timeValue := sessionObject.FractalSessionEndTimeActual // Use new field
        "Distribution Close" =>
            timeValue := sessionObject.DistributionTimeValue // NEW – actual bar time of distribution close
        "Base Candle High" => // New
            timeValue := sessionObject.ConfirmationTimeValue
        "Base Candle Low" => // New
            timeValue := sessionObject.ConfirmationTimeValue
        "Session High" => // Renamed from Fractal Session High
            timeValue := sessionObject.OpenTime // Contextual time
        "Session Low" => // Renamed from Fractal Session Low
            timeValue := sessionObject.OpenTime // Contextual time
        "Session EQ" => // Renamed from Fractal EQ
            timeValue := sessionObject.OpenTime // Contextual time
        "IDR High" => // New
            timeValue := sessionObject.OpenTime // Contextual time
        "IDR Low" => // New
            timeValue := sessionObject.OpenTime   // Contextual time
    timeValue // Default to na if no match

// Helper function to create sub base model for a specific preset
createSubBaseModelForPreset(SessionObjectPrev, SessionObjectCurr, presetName, presetNumber) =>
    string effectiveStartAnchorType = ""
    string effectiveEndAnchorType = ""

    switch presetName
        "Base Open to Base Open" =>
            effectiveStartAnchorType := "Base Candle Open"
            effectiveEndAnchorType := "Base Candle Open"
        "Base Close to Base Close" =>
            effectiveStartAnchorType := "Base Candle Close"
            effectiveEndAnchorType := "Base Candle Close"
        "Session Open to Session Open" => 
            effectiveStartAnchorType := "Session Open"
            effectiveEndAnchorType := "Session Open"
        "Session Close to Session Close" => 
            effectiveStartAnchorType := "Session Close"
            effectiveEndAnchorType := "Session Close"
        "Base Open to Session Open" => 
            effectiveStartAnchorType := "Base Candle Open"
            effectiveEndAnchorType := "Session Open"
        "Distro Close to Distro Close" => 
            effectiveStartAnchorType := "Distribution Close"
            effectiveEndAnchorType := "Distribution Close"
        "Session Body" =>
            effectiveStartAnchorType := "Session Open"
            effectiveEndAnchorType := "Session Close"
        "Base Body" =>
            effectiveStartAnchorType := "Base Candle Open"
            effectiveEndAnchorType := "Base Candle Close"
        "Fractal EQ to Fractal EQ" =>
            effectiveStartAnchorType := "Session EQ"
            effectiveEndAnchorType := "Session EQ"
                
    int startTime = getSubModelAnchorTime(SessionObjectPrev, effectiveStartAnchorType)
    int endTime = getSubModelAnchorTime(SessionObjectCurr, effectiveEndAnchorType)
    float startY = getSubModelAnchorValue(SessionObjectPrev, effectiveStartAnchorType)
    float endY = getSubModelAnchorValue(SessionObjectCurr, effectiveEndAnchorType)

    if not na(SessionObjectPrev.BaseSessionName) and not na(SessionObjectCurr.BaseSessionName) and not na(startTime) and not na(endTime) and not na(startY) and not na(endY)
        bool alreadyExists = false
        if array.size(ArrayOfSubBaseModels) > 0
            for subModelIdx = 0 to array.size(ArrayOfSubBaseModels) - 1
                existingSubModel = array.get(ArrayOfSubBaseModels, subModelIdx)
                if existingSubModel.StartTime == startTime and existingSubModel.EndTime == endTime and existingSubModel.PresetNumber == presetNumber
                    alreadyExists := true
                    break
        
        if not alreadyExists
            string subModelName = SessionObjectPrev.BaseSessionName + (presetNumber == 2 ? " P2" : "") // Add P2 suffix for second preset
            
            float boxBottom = math.min(startY, endY)
            float boxTop = math.max(startY, endY)
            float eqVal = (boxTop + boxBottom) / 2
            
            string initialBelowAbove = na
            if not na(eqVal)
                if close > eqVal
                    initialBelowAbove := "Above"
                else if close < eqVal
                    initialBelowAbove := "Below"
                else
                    initialBelowAbove := "Mitigated"

            // Calculate additional fields for the new sub model
            boxHeight = calculateBoxHeight(boxBottom, boxTop)
            boxHeightPercent = calculateBoxHeightPercent(boxBottom, boxTop)
            sizeCategory = getSizeCategory(boxHeightPercent)
            
            // Get source session data
            startSessionName = getSessionNameFromObject(SessionObjectPrev)
            endSessionName = getSessionNameFromObject(SessionObjectCurr)
            startSessionDirection = getSessionDirectionFromObject(SessionObjectPrev)
            endSessionDirection = getSessionDirectionFromObject(SessionObjectCurr)
            directionalAgreement = calculateDirectionalAgreement(startSessionDirection, endSessionDirection)
            startSessionEqStatus = getSessionEqStatusFromObject(SessionObjectPrev)
            endSessionEqStatus = getSessionEqStatusFromObject(SessionObjectCurr)
            
            // Market context data
            dayOfWeekCreated = getDayOfWeekString(time)
            
            // Create the new sub model
            newSubModel = SubBaseModelObject.new(subModelName, startTime, endTime, boxBottom, boxTop, eqVal, na, na, initialBelowAbove, presetNumber, presetName, boxHeight, boxHeightPercent, sizeCategory, time, high, low, 0, 0.0, 0.0, na, 0.0, 0.0, na, 50.0, startSessionName, endSessionName, startSessionDirection, endSessionDirection, directionalAgreement, startSessionEqStatus, endSessionEqStatus, dayOfWeekCreated, "None", na, close, na, 0, na, false, na, 0, na, na, 0.0, 0.0, na, na, na)
            
            array.push(ArrayOfSubBaseModels, newSubModel)
            
            // Calculate and store AMD data for this Sub Base Model
            [manipulation, distribution, manipulationTime, distributionTime] = calculateSubBaseModelAMD(newSubModel)
            maintainSubBaseModelAMDArrays(manipulation, distribution, manipulationTime, distributionTime, subModelName)

// Function to create Sub Base Models
createSubBaseModels() =>
    if array.size(ArrayOfFractalObjects) >= 2
        for i = 0 to array.size(ArrayOfFractalObjects) - 2 
            SessionObjectPrev = array.get(ArrayOfFractalObjects, i)
            SessionObjectCurr = array.get(ArrayOfFractalObjects, i + 1)

            // Create models for first preset
            createSubBaseModelForPreset(SessionObjectPrev, SessionObjectCurr, SubBaseModelAnchorPreset, 1)
            
            // Create models for second preset if enabled
            if ShowSecondPreset
                createSubBaseModelForPreset(SessionObjectPrev, SessionObjectCurr, SubBaseModelAnchorPreset2, 2)



// Create Sub Base Models after all session objects are processed for the current bar
// createSubBaseModels() // MOVED FROM HERE

// Optional: Manage ArrayOfSubBaseModels size
var int MaxSubBaseModels = 50 // Or make this an input
if array.size(ArrayOfSubBaseModels) > MaxSubBaseModels
    SubBaseModelObject oldSubModel = array.shift(ArrayOfSubBaseModels)
    if not na(oldSubModel.DisplayBox)
        box.delete(oldSubModel.DisplayBox)
    if not na(oldSubModel.EqLine) 
        line.delete(oldSubModel.EqLine)


plotshape(BullConfirmationMark, color = ConfirmationShapeBullColor, location = location.abovebar, style = shape.triangleup, title = "Long Confirmation")
plotshape(BearConfirmationMark, color = ConfirmationShapeBearColor, location = location.belowbar, style = shape.triangledown, title = "Short Confirmation")

// Update Sub Base Model data and Drawing Logic
if ShowSubBaseModels and array.size(ArrayOfSubBaseModels) > 0
    for i = 0 to array.size(ArrayOfSubBaseModels) - 1
        SubBaseModelObject currentSubModel = array.get(ArrayOfSubBaseModels, i)
        
        // Update real-time data for this sub model
        updateSubBaseModelData(currentSubModel)
        
        // Update overlap count with other sub models
        currentSubModel.OverlapCount := calculateOverlapCount(currentSubModel, ArrayOfSubBaseModels)
        
        if not na(currentSubModel.DisplayBox)
            box.delete(currentSubModel.DisplayBox)
        if not na(currentSubModel.EqLine)
            line.delete(currentSubModel.EqLine)

        // Determine colors based on preset
        color currentBgColor = currentSubModel.PresetNumber == 2 ? SubBaseModelDefaultColor2 : SubBaseModelDefaultColor
        color currentBorderColor = currentSubModel.PresetNumber == 2 ? SubBaseModelBorderColor2 : SubBaseModelBorderColor
        color currentEqLineColor = currentSubModel.PresetNumber == 2 ? SubBaseModelEqLineColor2 : SubBaseModelEqLineColor

        if EnableSubBaseModelSizeColoring and not na(currentSubModel.StartY) and not na(currentSubModel.EndY)
            // currentSubModel.StartY is boxBottom, currentSubModel.EndY is boxTop
            float modelHeight = currentSubModel.EndY - currentSubModel.StartY // Height is always >= 0

            if modelHeight == 0 // Zero height box
                currentBgColor := currentSubModel.PresetNumber == 2 ? SubBaseModelSmallColor2 : SubBaseModelSmallColor
            else if currentSubModel.StartY > 0 // Ensure bottom price is positive for percentage calculation
                float sizePercent = (modelHeight / currentSubModel.StartY) * 100
                
                if sizePercent <= SubBaseModelSmallSizeThresholdPercent
                    currentBgColor := currentSubModel.PresetNumber == 2 ? SubBaseModelSmallColor2 : SubBaseModelSmallColor
                else if sizePercent <= SubBaseModelMediumSizeThresholdPercent
                    currentBgColor := currentSubModel.PresetNumber == 2 ? SubBaseModelMediumColor2 : SubBaseModelMediumColor
                else // sizePercent > SubBaseModelMediumSizeThresholdPercent
                    currentBgColor := currentSubModel.PresetNumber == 2 ? SubBaseModelLargeColor2 : SubBaseModelLargeColor
            // Else, if StartY (bottom price) is not > 0, currentBgColor remains default for the preset
        
        // Ensure StartY is bottom and EndY is top for box.new arguments
        currentSubModel.DisplayBox := box.new(currentSubModel.StartTime, currentSubModel.EndY, 
                                             currentSubModel.EndTime, currentSubModel.StartY,
                                             xloc = xloc.bar_time, bgcolor = currentBgColor, 
                                             border_color = currentBorderColor,
                                             text = currentSubModel.Name, text_color = SubBaseModelTextColor, 
                                             text_size = size.tiny, 
                                             text_halign = text.align_left, text_valign = text.align_top, text_wrap = text.wrap_none)
        
        // EQ Line Mitigation Logic for Sub Base Models
        if not na(currentSubModel.EqValue) // Ensure EqValue is calculated
            color eqLineColor = currentSubModel.BelowAbove == "Mitigated" ? MitigatedFractalEqLineColor : currentEqLineColor

            // Check for mitigation on current bar if not already mitigated
            if currentSubModel.BelowAbove == "Above"
                if low < currentSubModel.EqValue // Price crossed below from above
                    eqLineColor := MitigatedFractalEqLineColor
                    currentSubModel.BelowAbove := "Mitigated"
            else if currentSubModel.BelowAbove == "Below"
                if high > currentSubModel.EqValue // Price crossed above from below
                    eqLineColor := MitigatedFractalEqLineColor
                    currentSubModel.BelowAbove := "Mitigated"
            
            // Draw or update the EQ line
            if not na(currentSubModel.EqLine)
                line.set_color(currentSubModel.EqLine, eqLineColor)
                // Extend line to current time if enabled
                if ExtendSubBaseModelEqLines
                    line.set_x2(currentSubModel.EqLine, time)
            else // New line
                int lineEndTime = ExtendSubBaseModelEqLines ? time : currentSubModel.EndTime
                currentSubModel.EqLine := line.new(currentSubModel.StartTime, currentSubModel.EqValue, 
                                                  lineEndTime, currentSubModel.EqValue, 
                                                  xloc.bar_time, color = eqLineColor, 
                                                  style = SubBaseModelEqLineStyle, width = 1)

// Debug: Add a comprehensive debug label (temporary)
if ShowSubBaseModelTable and false // Disabled for now
    string debugText = "SBM Count: " + str.tostring(array.size(ArrayOfSubBaseModels)) + 
                      "\nFractal Count: " + str.tostring(array.size(ArrayOfFractalObjects)) +
                      "\nSBM Show: " + str.tostring(ShowSubBaseModels) +
                      "\nAMD Count: " + str.tostring(array.size(ArraySubBaseModelManipulation))
    label.new(bar_index, high + (high - low) * 0.1, debugText, 
              style = label.style_label_down, color = color.yellow, textcolor = color.black, size = size.small)

// Sub Base Model Table Update
if ShowSubBaseModelTable
    // Clear table first
    table.clear(SubBaseModelTable, 0, 0, 10, SubBaseModelTableMaxRows)
    
    // Add headers with comprehensive tooltips
    table.cell(SubBaseModelTable, 0, 0, "Name", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor, tooltip = "Sub Base Model identifier. Shows session name or 'SessionName P2' for second preset. Identifies which sessions created this model. Example: 'Alpha', 'Bravo P2', 'Charlie'")
    table.cell(SubBaseModelTable, 1, 0, "Anchor", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor, tooltip = "Anchor Type (abbreviated). Shows the preset used to create this model. BOBO=Base Open to Base Open, BCBC=Base Close to Base Close, SOSO=Session Open to Session Open, SB=Session Body, BB=Base Body, FEQ=Fractal EQ to Fractal EQ, etc.")
    table.cell(SubBaseModelTable, 2, 0, "Height", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor, tooltip = "Box Height in price points/pips. The absolute distance between the top and bottom of the Sub Base Model box. Larger heights indicate bigger price ranges and potentially more significant levels")
    table.cell(SubBaseModelTable, 3, 0, "Height%", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor, tooltip = "Box Height as percentage of start price. Shows relative size of the model compared to price level. Higher percentages indicate larger relative ranges. Used for size categorization (Small/Medium/Large)")
    table.cell(SubBaseModelTable, 4, 0, "EQ", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor, tooltip = "Equilibrium Value. The midpoint price of the Sub Base Model box. Acts as key support/resistance level. Price above EQ = bullish bias, below EQ = bearish bias. Critical level for entries and exits")
    table.cell(SubBaseModelTable, 5, 0, "Status", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor, tooltip = "Current price status relative to EQ line. Above (Green) = Price above EQ, Below (Red) = Price below EQ, Mitigated (Gray) = EQ line has been breached. Shows current market bias")
    table.cell(SubBaseModelTable, 6, 0, "Size", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor, tooltip = "Size Category based on Height%. Small ≤0.144%, Medium ≤0.721%, Large >0.721%. Larger models may be more significant levels with greater impact on price action")
    table.cell(SubBaseModelTable, 7, 0, "Age", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor, tooltip = "Time since creation. Format: minutes(m), hours(h), or days(d). Newer models may be more relevant, while older models show historical significance. Helps assess level freshness")
    table.cell(SubBaseModelTable, 8, 0, "Touches", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor, tooltip = "Number of times price has touched the EQ line (within 1% tolerance). More touches indicate stronger support/resistance. Multiple touches confirm level significance and reliability")
    table.cell(SubBaseModelTable, 9, 0, "Day", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor, tooltip = "Day of week when this Sub Base Model was created. Useful for identifying weekly patterns and session-specific behaviors. Shows which day the model was formed")
    table.cell(SubBaseModelTable, 10, 0, "Dev", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor, tooltip = "Current Deviation from EQ line in points/pips. Shows absolute distance between current price and EQ. Lower values = closer to EQ (potential reversal), Higher values = further from EQ (momentum/trend)")
    
    // Add total count information
    int totalModels = array.size(ArrayOfSubBaseModels)
    string totalText = "Total: " + str.tostring(totalModels) + " models"
    
    // Add data rows (most recent first, limited by MaxRows)
    int rowsToShow = math.min(totalModels, SubBaseModelTableMaxRows)
    
    // Add total count row at the bottom if we have models, or show help message if none
    if totalModels > 0
        table.cell(SubBaseModelTable, 0, rowsToShow + 1, totalText, text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor)
        table.cell(SubBaseModelTable, 1, rowsToShow + 1, rowsToShow < totalModels ? "Showing " + str.tostring(rowsToShow) + "/" + str.tostring(totalModels) : "All shown", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor)
    else
        table.cell(SubBaseModelTable, 0, 1, "No Sub Base Models", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor)
        table.cell(SubBaseModelTable, 1, 1, "Need 2+ confirmed sessions", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor)
        table.cell(SubBaseModelTable, 0, 2, "Enable base sessions", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor)
        table.cell(SubBaseModelTable, 1, 2, "Wait for base candles", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor)
    
    if rowsToShow > 0
        for i = 0 to rowsToShow - 1
            SubBaseModelObject subModel = array.get(ArrayOfSubBaseModels, array.size(ArrayOfSubBaseModels) - 1 - i)
            int row = i + 1
            
            // Determine status color
            color statusColor = subModel.BelowAbove == "Above" ? color.green : subModel.BelowAbove == "Below" ? color.red : color.gray
            
            // Calculate current deviation
            float currentDev = na
            if not na(subModel.EqValue)
                currentDev := math.abs(close - subModel.EqValue)
            
            // Populate table cells
            table.cell(SubBaseModelTable, 0, row, subModel.Name, text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted)
            table.cell(SubBaseModelTable, 1, row, abbreviateAnchorType(subModel.AnchorType), text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted)
            table.cell(SubBaseModelTable, 2, row, str.tostring(math.round(subModel.BoxHeight, 2)), text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted)
            table.cell(SubBaseModelTable, 3, row, str.tostring(math.round(subModel.BoxHeightPercent, 2)) + "%", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted)
            table.cell(SubBaseModelTable, 4, row, str.tostring(math.round(subModel.EqValue, 2)), text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted)
            table.cell(SubBaseModelTable, 5, row, subModel.BelowAbove, text_color = statusColor, text_size = SubBaseModelTableTextSizeConverted)
            table.cell(SubBaseModelTable, 6, row, subModel.SizeCategory, text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted)
            table.cell(SubBaseModelTable, 7, row, formatTimeElapsed(subModel.CreationTime, time), text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted)
            table.cell(SubBaseModelTable, 8, row, str.tostring(subModel.EqTouches), text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted)
            table.cell(SubBaseModelTable, 9, row, subModel.DayOfWeekCreated, text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted)
            table.cell(SubBaseModelTable, 10, row, na(currentDev) ? "N/A" : str.tostring(math.round(currentDev, 1)), text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted)

// Advanced Analytics Table Update
if ShowSubBaseModelAdvancedTable and array.size(ArrayOfSubBaseModels) > 0
    // Clear advanced table first
    table.clear(SubBaseModelAdvancedTable, 0, 0, 24, SubBaseModelAdvancedTableMaxRows)
    
    // Add headers for all metrics (regular + advanced) with comprehensive tooltips
    // Regular table columns (0-9)
    table.cell(SubBaseModelAdvancedTable, 0, 0, "Name", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor, tooltip = "Sub Base Model identifier. Shows session name or 'SessionName P2' for second preset. Identifies which sessions created this model. Example: 'Alpha', 'Bravo P2', 'Charlie'")
    table.cell(SubBaseModelAdvancedTable, 1, 0, "Anchor", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor, tooltip = "Anchor Type (abbreviated). Shows the preset used to create this model. BOBO=Base Open to Base Open, BCBC=Base Close to Base Close, SOSO=Session Open to Session Open, SB=Session Body, BB=Base Body, FEQ=Fractal EQ to Fractal EQ, etc.")
    table.cell(SubBaseModelAdvancedTable, 2, 0, "Height", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor, tooltip = "Box Height in price points/pips. The absolute distance between the top and bottom of the Sub Base Model box. Larger heights indicate bigger price ranges and potentially more significant levels")
    table.cell(SubBaseModelAdvancedTable, 3, 0, "Height%", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor, tooltip = "Box Height as percentage of start price. Shows relative size of the model compared to price level. Higher percentages indicate larger relative ranges. Used for size categorization (Small/Medium/Large)")
    table.cell(SubBaseModelAdvancedTable, 4, 0, "EQ", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor, tooltip = "Equilibrium Value. The midpoint price of the Sub Base Model box. Acts as key support/resistance level. Price above EQ = bullish bias, below EQ = bearish bias. Critical level for entries and exits")
    table.cell(SubBaseModelAdvancedTable, 5, 0, "Status", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor, tooltip = "Current price status relative to EQ line. Above (Green) = Price above EQ, Below (Red) = Price below EQ, Mitigated (Gray) = EQ line has been breached. Shows current market bias")
    table.cell(SubBaseModelAdvancedTable, 6, 0, "Size", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor, tooltip = "Size Category based on Height%. Small ≤0.144%, Medium ≤0.721%, Large >0.721%. Larger models may be more significant levels with greater impact on price action")
    table.cell(SubBaseModelAdvancedTable, 7, 0, "Age", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor, tooltip = "Time since creation. Format: minutes(m), hours(h), or days(d). Newer models may be more relevant, while older models show historical significance. Helps assess level freshness")
    table.cell(SubBaseModelAdvancedTable, 8, 0, "Touches", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor, tooltip = "Number of times price has touched the EQ line (within 1% tolerance). More touches indicate stronger support/resistance. Multiple touches confirm level significance and reliability")
    table.cell(SubBaseModelAdvancedTable, 9, 0, "Day", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor, tooltip = "Day of week when this Sub Base Model was created. Useful for identifying weekly patterns and session-specific behaviors. Shows which day the model was formed")
    table.cell(SubBaseModelAdvancedTable, 10, 0, "Dev", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor, tooltip = "Current Deviation from EQ line in points/pips. Shows absolute distance between current price and EQ. Lower values = closer to EQ (potential reversal), Higher values = further from EQ (momentum/trend)")
    
    // Advanced table columns (11-24)
    table.cell(SubBaseModelAdvancedTable, 11, 0, "Sessions", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor, tooltip = "Source sessions that created this model. Format: StartSession-EndSession (abbreviated). Example: 'Alp-Bra' = Alpha to Bravo relationship")
    table.cell(SubBaseModelAdvancedTable, 12, 0, "Direction", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor, tooltip = "Directional agreement between source sessions. ✓ = Both sessions confirmed same direction (stronger signal). ✗ = Sessions disagreed on direction (weaker signal). Green = Agreement, Red = Disagreement")
    table.cell(SubBaseModelAdvancedTable, 13, 0, "BoxPos%", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor, tooltip = "Current price position within the Sub Base Model box (0-100%). >70% = Near top (resistance), <30% = Near bottom (support), ~50% = Near equilibrium. Green = High, Red = Low, White = Middle")
    table.cell(SubBaseModelAdvancedTable, 14, 0, "Volatility", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor, tooltip = "Market volatility during model's timeframe. Calculated as ((High-Low)/Low)*100. Higher values indicate more price movement and trading opportunity")
    table.cell(SubBaseModelAdvancedTable, 15, 0, "Retests", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor, tooltip = "Number of times price retested the EQ line after mitigation. Counts touches within 1% tolerance. Multiple retests indicate strong support/resistance level")
    table.cell(SubBaseModelAdvancedTable, 16, 0, "Overlaps", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor, tooltip = "Number of other Sub Base Models overlapping this one (time + price). Higher overlap areas may be more significant levels with confluence")
    table.cell(SubBaseModelAdvancedTable, 17, 0, "MitSpeed", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor, tooltip = "Mitigation Speed: Time from creation to EQ line breach. Fast (<1h) = Strong momentum (Green), Slow (>4h) = Weak momentum (Red), N/A = Still active. Format: minutes(m) or hours(h)")
    table.cell(SubBaseModelAdvancedTable, 18, 0, "Efficiency", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor, tooltip = "Price Movement Efficiency: Net movement / Total movement (0-100%). High (>70%) = Clean directional moves (Green), Low (<30%) = Choppy action (Red), Medium = Normal behavior")
    table.cell(SubBaseModelAdvancedTable, 19, 0, "MaxDD", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor, tooltip = "Maximum Drawdown: Largest adverse price movement from EQ line (in points/pips). Shows historical risk level and potential stop loss distance")
    table.cell(SubBaseModelAdvancedTable, 20, 0, "MaxFav", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor, tooltip = "Maximum Favorable: Largest favorable price movement from EQ line (in points/pips). Shows profit potential and historical reward levels")
    table.cell(SubBaseModelAdvancedTable, 21, 0, "1stTouch", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor, tooltip = "Time to First Touch: How long until price first interacted with EQ line. Quick touch = Immediate reaction, Delayed = Less significant initially. Format: minutes(m) or hours(h)")
    table.cell(SubBaseModelAdvancedTable, 22, 0, "SrcEQ", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor, tooltip = "Source EQ Status: Mitigation status of both source sessions. Format: Start/End (A=Above, B=Below, M=Mitigated). M/M = Both broken (weaker), A/A or B/B = Consistent")
    table.cell(SubBaseModelAdvancedTable, 23, 0, "StdDev", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor, tooltip = "Standard Deviation: Price volatility measure during model's lifetime (in points/pips). Higher values indicate more volatile price action and wider trading ranges")
    
    // Add total count information for advanced table
    int advTotalModels = array.size(ArrayOfSubBaseModels)
    string advTotalText = "Total: " + str.tostring(advTotalModels) + " models"
    
    // Add data rows for advanced metrics
    int advRowsToShow = math.min(advTotalModels, SubBaseModelAdvancedTableMaxRows)
    
    // Add total count row at the bottom if we have models
    if advTotalModels > 0
        table.cell(SubBaseModelAdvancedTable, 0, advRowsToShow + 1, advTotalText, text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor)
        table.cell(SubBaseModelAdvancedTable, 1, advRowsToShow + 1, advRowsToShow < advTotalModels ? "Showing " + str.tostring(advRowsToShow) + "/" + str.tostring(advTotalModels) : "All shown", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted, bgcolor = SubBaseModelTableBorderColor)
    
    for i = 0 to advRowsToShow - 1
        SubBaseModelObject advSubModel = array.get(ArrayOfSubBaseModels, array.size(ArrayOfSubBaseModels) - 1 - i)
        int advRow = i + 1
        
        // Format session names (abbreviated)
        string sessionNames = str.substring(advSubModel.StartSessionName, 0, 3) + "-" + str.substring(advSubModel.EndSessionName, 0, 3)
        
        // Direction agreement indicator
        string directionIndicator = advSubModel.DirectionalAgreement ? "✓" : "✗"
        color directionColor = advSubModel.DirectionalAgreement ? color.green : color.red
        
        // Box position color coding
        color boxPosColor = advSubModel.CurrentBoxPosition > 70 ? color.green : advSubModel.CurrentBoxPosition < 30 ? color.red : SubBaseModelTableTextColor
        
        // Format additional metrics
        string mitSpeedText = na(advSubModel.MitigationSpeed) ? "N/A" : (advSubModel.MitigationSpeed < 60 ? str.tostring(math.round(advSubModel.MitigationSpeed, 1)) + "m" : str.tostring(math.round(advSubModel.MitigationSpeed / 60, 1)) + "h")
        string efficiencyText = na(advSubModel.EfficiencyRatio) ? "N/A" : str.tostring(math.round(advSubModel.EfficiencyRatio * 100, 1)) + "%"
        string maxDDText = na(advSubModel.MaxDrawdown) ? "N/A" : str.tostring(math.round(advSubModel.MaxDrawdown, 1))
        string maxFavText = na(advSubModel.MaxFavorable) ? "N/A" : str.tostring(math.round(advSubModel.MaxFavorable, 1))
        string firstTouchText = na(advSubModel.TimeToFirstTouch) ? "N/A" : (advSubModel.TimeToFirstTouch < 3600000 ? str.tostring(math.round(advSubModel.TimeToFirstTouch / 60000, 1)) + "m" : str.tostring(math.round(advSubModel.TimeToFirstTouch / 3600000, 1)) + "h")
        string srcEqText = str.substring(advSubModel.StartSessionEqStatus, 0, 1) + "/" + str.substring(advSubModel.EndSessionEqStatus, 0, 1) // A/B, M/M, etc.
        string stdDevText = na(advSubModel.PriceStandardDev) ? "N/A" : str.tostring(math.round(advSubModel.PriceStandardDev, 1))
        
        // Color coding for performance metrics
        color efficiencyColor = na(advSubModel.EfficiencyRatio) ? SubBaseModelTableTextColor : (advSubModel.EfficiencyRatio > 0.7 ? color.green : advSubModel.EfficiencyRatio < 0.3 ? color.red : SubBaseModelTableTextColor)
        color mitSpeedColor = na(advSubModel.MitigationSpeed) ? SubBaseModelTableTextColor : (advSubModel.MitigationSpeed < 60 ? color.green : advSubModel.MitigationSpeed > 240 ? color.red : SubBaseModelTableTextColor)
        
        // Calculate current deviation for regular table data
        float advCurrentDev = na
        if not na(advSubModel.EqValue)
            advCurrentDev := math.abs(close - advSubModel.EqValue)
        
        // Determine status color for regular table data
        color advStatusColor = advSubModel.BelowAbove == "Above" ? color.green : advSubModel.BelowAbove == "Below" ? color.red : color.gray
        
        // Populate all table cells (regular + advanced)
        // Regular table columns (0-10)
        table.cell(SubBaseModelAdvancedTable, 0, advRow, advSubModel.Name, text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted)
        table.cell(SubBaseModelAdvancedTable, 1, advRow, abbreviateAnchorType(advSubModel.AnchorType), text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted)
        table.cell(SubBaseModelAdvancedTable, 2, advRow, str.tostring(math.round(advSubModel.BoxHeight, 2)), text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted)
        table.cell(SubBaseModelAdvancedTable, 3, advRow, str.tostring(math.round(advSubModel.BoxHeightPercent, 2)) + "%", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted)
        table.cell(SubBaseModelAdvancedTable, 4, advRow, str.tostring(math.round(advSubModel.EqValue, 2)), text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted)
        table.cell(SubBaseModelAdvancedTable, 5, advRow, advSubModel.BelowAbove, text_color = advStatusColor, text_size = SubBaseModelTableTextSizeConverted)
        table.cell(SubBaseModelAdvancedTable, 6, advRow, advSubModel.SizeCategory, text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted)
        table.cell(SubBaseModelAdvancedTable, 7, advRow, formatTimeElapsed(advSubModel.CreationTime, time), text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted)
        table.cell(SubBaseModelAdvancedTable, 8, advRow, str.tostring(advSubModel.EqTouches), text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted)
        table.cell(SubBaseModelAdvancedTable, 9, advRow, advSubModel.DayOfWeekCreated, text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted)
        table.cell(SubBaseModelAdvancedTable, 10, advRow, na(advCurrentDev) ? "N/A" : str.tostring(math.round(advCurrentDev, 1)), text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted)
        
        // Advanced table columns (11-23)
        table.cell(SubBaseModelAdvancedTable, 11, advRow, sessionNames, text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted)
        table.cell(SubBaseModelAdvancedTable, 12, advRow, directionIndicator, text_color = directionColor, text_size = SubBaseModelTableTextSizeConverted)
        table.cell(SubBaseModelAdvancedTable, 13, advRow, str.tostring(math.round(advSubModel.CurrentBoxPosition, 1)) + "%", text_color = boxPosColor, text_size = SubBaseModelTableTextSizeConverted)
        table.cell(SubBaseModelAdvancedTable, 14, advRow, na(advSubModel.MarketVolatility) ? "N/A" : str.tostring(math.round(advSubModel.MarketVolatility, 1)) + "%", text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted)
        table.cell(SubBaseModelAdvancedTable, 15, advRow, str.tostring(advSubModel.RetestCount), text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted)
        table.cell(SubBaseModelAdvancedTable, 16, advRow, str.tostring(advSubModel.OverlapCount), text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted)
        table.cell(SubBaseModelAdvancedTable, 17, advRow, mitSpeedText, text_color = mitSpeedColor, text_size = SubBaseModelTableTextSizeConverted)
        table.cell(SubBaseModelAdvancedTable, 18, advRow, efficiencyText, text_color = efficiencyColor, text_size = SubBaseModelTableTextSizeConverted)
        table.cell(SubBaseModelAdvancedTable, 19, advRow, maxDDText, text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted)
        table.cell(SubBaseModelAdvancedTable, 20, advRow, maxFavText, text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted)
        table.cell(SubBaseModelAdvancedTable, 21, advRow, firstTouchText, text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted)
        table.cell(SubBaseModelAdvancedTable, 22, advRow, srcEqText, text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted)
        table.cell(SubBaseModelAdvancedTable, 23, advRow, stdDevText, text_color = SubBaseModelTableTextColor, text_size = SubBaseModelTableTextSizeConverted)

// Record Distribution Close once distribution end time is reached
if array.size(ArrayOfFractalObjects) > 0
    for i = 0 to array.size(ArrayOfFractalObjects)-1
        _obj = array.get(ArrayOfFractalObjects,i)
        if na(_obj.DistributionCloseValue) and time >= _obj.CycleEndTimeFractal
            _obj.DistributionCloseValue := close
            _obj.DistributionTimeValue  := time

// Create Sub Base Models after all session objects are processed for the current bar,
// including updates to DistributionCloseValue
createSubBaseModels()

// Optional: Manage ArrayOfSubBaseModels size
// Moved the MaxSubBaseModels size management to be just after its creation and potential modification.
if array.size(ArrayOfSubBaseModels) > MaxSubBaseModels
    SubBaseModelObject oldSubModel = array.shift(ArrayOfSubBaseModels)
    if not na(oldSubModel.DisplayBox)
        box.delete(oldSubModel.DisplayBox)
    if not na(oldSubModel.EqLine) 
        line.delete(oldSubModel.EqLine)

// Distribution Close Candles Settings
DistributionCloseSettings = "Distribution Close Candles"
ShowDistributionCloseCandles = input.bool(true, "Show Distribution Close Candles", group = DistributionCloseSettings, inline = "DC_Show", display = display.none)
ShowDistCloseMiddleLines = true // Hard coded to true
ColorDistCloseDirection = true // Hard coded to true
ShowDistCloseLabels = false

DistCloseExtensionType = input.string("Session", options= ["Realtime","Session", "Manual"], group=DistributionCloseSettings, title = "Box Extension", inline = "DC_Ext", display = display.none)
DistCloseExtendHours = input.int(6, title="Manual Extend Hours:", minval=0, group = DistributionCloseSettings, inline = "DC_Ext", display = display.none)

// Base to Distribution Connection Settings (Independent Feature)
BaseToDistConnectionSettings = "Base to Distribution Connections (Independent)"
ShowBaseToDistConnections = input.bool(true, "Show Base to Distribution Connections", group = BaseToDistConnectionSettings, inline = "BDC_Show", tooltip = "Requires base candles and distribution candles to be enabled to work properly", display = display.none)
ShowConnectionLines = input.bool(true, "Show Connection Lines", group = BaseToDistConnectionSettings, inline = "BDC_Show", display = display.none)
ExtendConnectionsRealtime = input.bool(false, "Extend in Realtime", group = BaseToDistConnectionSettings, inline = "BDC_Extend", display = display.none)
MaxConnectionsToShow = input.int(5, "Max Connections", minval = 1, maxval = 20, group = BaseToDistConnectionSettings, inline = "BDC_Extend", display = display.none)

BaseToDistConnectionBullColor = input.color(color.new(color.green, 85), "Bull Connection", group = BaseToDistConnectionSettings, inline = "BDC_Bull", display = display.none)
BaseToDistConnectionBullBorderColor = input.color(color.new(color.green, 40), "Bull Border", group = BaseToDistConnectionSettings, inline = "BDC_Bull", display = display.none)
BaseToDistConnectionBearColor = input.color(color.new(color.red, 85), "Bear Connection", group = BaseToDistConnectionSettings, inline = "BDC_Bear", display = display.none)
BaseToDistConnectionBearBorderColor = input.color(color.new(color.red, 40), "Bear Border", group = BaseToDistConnectionSettings, inline = "BDC_Bear", display = display.none)
BaseToDistConnectionMixedColor = input.color(color.new(color.purple, 85), "Mixed Connection", group = BaseToDistConnectionSettings, inline = "BDC_Mixed", display = display.none)
BaseToDistConnectionMixedBorderColor = input.color(color.new(color.purple, 40), "Mixed Border", group = BaseToDistConnectionSettings, inline = "BDC_Mixed", display = display.none)

DistCloseBoxBullColor = input.color(color.new(color.blue, 90), "Bull Box", group = DistributionCloseSettings, inline = "DC_Bull", display = display.none)
DistCloseBoxBullBorderColor = input.color(color.new(color.blue, 50), "Bull Border", group = DistributionCloseSettings, inline = "DC_Bull", display = display.none)
DistCloseBoxBearColor = input.color(color.new(color.red, 90), "Bear Box", group = DistributionCloseSettings, inline = "DC_Bear", display = display.none)
DistCloseBoxBearBorderColor = input.color(color.new(color.red, 50), "Bear Border", group = DistributionCloseSettings, inline = "DC_Bear", display = display.none)
DistCloseBoxInversionColor = input.color(color.new(color.purple, 90), "Inversion Box", group = DistributionCloseSettings, inline = "DC_Inversion", display = display.none)
DistCloseBoxInversionBorderColor = input.color(color.new(color.purple, 50), "Inversion Border", group = DistributionCloseSettings, inline = "DC_Inversion", display = display.none)

var bool DistCloseExtendConfirmationCandle = false
var bool DistCloseManualConfirmationCandleExtension = false

if DistCloseExtensionType == "Session"
    DistCloseExtendConfirmationCandle := false
    DistCloseManualConfirmationCandleExtension := false
else if DistCloseExtensionType == "Realtime"
    DistCloseExtendConfirmationCandle := true
    DistCloseManualConfirmationCandleExtension := false
else if DistCloseExtensionType == "Manual"
    DistCloseExtendConfirmationCandle := false
    DistCloseManualConfirmationCandleExtension := true

// Function to check if a base model is enabled
isBaseModelEnabled(baseModelName) =>
    bool enabled = false
    switch baseModelName
        "Alpha" => enabled := ShowADRQ1Dr
        "Bravo" => enabled := ShowADRQ2Dr
        "Charlie" => enabled := ShowADRQ3Dr
        "Delta" => enabled := ShowADRQ4Dr
        "Echo" => enabled := ShowODRQ1Dr
        "Foxtrot" => enabled := ShowODRQ2Dr
        "Golf" => enabled := ShowRDRQ1Dr
        "Hotel" => enabled := ShowRDRQ2Dr
        "India" => enabled := ShowRDRQ3Dr
        "Juliet" => enabled := ShowRDRQ4Dr
        "ADR" => enabled := ShowADRDr
        "ODR" => enabled := ShowODRDr
        "RDR" => enabled := ShowRDRDr
        "Kilo" => enabled := ShowHTF1Dr
        "Lima" => enabled := ShowHTF2Dr
    enabled

// Function to convert time string to timestamp
getExtensionTimestamp(timeString, currentTime) =>
    int hour = int(str.tonumber(str.substring(timeString, 0, 2)))
    int minute = int(str.tonumber(str.substring(timeString, 2, 4)))
    int currentHour = hour(currentTime, Timezone)
    int currentMinute = minute(currentTime, Timezone)
    
    // Start with today's date
    int extensionTime = timestamp(Timezone, year(currentTime), month(currentTime), dayofmonth(currentTime), hour, minute, 0)
    
    // Calculate total minutes from midnight for comparison
    int currentTotalMinutes = currentHour * 60 + currentMinute
    int extensionTotalMinutes = hour * 60 + minute
    
    // If extension time is later in the day, use same day
    // If extension time is earlier in the day, use next day
    if extensionTotalMinutes > currentTotalMinutes
        // Same day - extension is later today
        extensionTime := extensionTime
    else
        // Next day - extension time has passed or is same time
        extensionTime := extensionTime + 86400000 // Add one day
    
    extensionTime



// Distribution Close Candles Creation Logic
if ShowDistributionCloseCandles and barstate.isconfirmed
    currentHour = hour(time, Timezone)
    currentMinute = minute(time, Timezone)
    currentTimeString = str.format("{0,number,00}{1,number,00}", currentHour, currentMinute)
    
    // Check if current time matches any distribution close time and if the base model is enabled
    string matchedBaseModel = ""
    string extensionTimeString = ""
    int matchedIndex = -1
    bool shouldCreateCandle = false
    if array.size(DistributionCloseTimes) > 0
        for i = 0 to array.size(DistributionCloseTimes) - 1
            if currentTimeString == array.get(DistributionCloseTimes, i)
                matchedBaseModel := array.get(DistributionCloseBaseModels, i)
                extensionTimeString := array.get(DistributionExtensionTimes, i)
                matchedIndex := i
                if isBaseModelEnabled(matchedBaseModel)
                    shouldCreateCandle := true
                break
    
    if shouldCreateCandle
        // Determine candle direction
        string candleDirection = close > open ? "Bull" : "Bear"
        
        // Determine colors based on direction
        color boxColor = candleDirection == "Bull" ? DistCloseBoxBullColor : DistCloseBoxBearColor
        color borderColor = candleDirection == "Bull" ? DistCloseBoxBullBorderColor : DistCloseBoxBearBorderColor
        
        // Calculate end time based on extension type
        int endTime = time
        if DistCloseExtensionType == "Manual"
            endTime := time + DistCloseExtendHours * 3600000
        else if DistCloseExtensionType == "Session"
            endTime := getExtensionTimestamp(extensionTimeString, time)
        else // Realtime
            endTime := getExtensionTimestamp(extensionTimeString, time)
        
        // Safety check: ensure endTime is always after startTime
        if endTime <= time
            endTime := time + 3600000 // Default to 1 hour if calculation fails
            
        // Special case handling for Hotel and Juliet - applies regardless of extension type
        if matchedBaseModel == "Hotel"
            // Force extension to 1505 (3:05 PM) for Hotel
            endTime := timestamp(Timezone, year(time), month(time), dayofmonth(time), 15, 5, 0)
            // Ensure endTime is always after current time
            if endTime <= time
                endTime := time + 65 * 60 * 1000 // Add 65 minutes from current time
        else if matchedBaseModel == "Juliet"
            // Check if it's Friday - if so, extend to Sunday 18:45, otherwise extend 2 hours
            if dayofweek(time) == dayofweek.friday
                // Friday: Extend to Sunday 18:45 (Asia session)
                endTime := timestamp(Timezone, year(time), month(time), dayofmonth(time) + 2, 18, 45, 0)
            else
                // Other days: Extend exactly 2 hours from creation time (16:45 + 2:00 = 18:45)
                endTime := time + 120 * 60 * 1000 // Always add exactly 120 minutes
        
        // Additional special cases for Session extension type only
        if DistCloseExtensionType == "Session"
            if matchedBaseModel == "Charlie"
                // Force extension to 0935 (9:35 AM) for Charlie
                endTime := timestamp(Timezone, year(time), month(time), dayofmonth(time), 9, 35, 0)
            else if matchedBaseModel == "Kilo"
                // Force extension to 1235 (12:35 PM) next day for Kilo
                endTime := timestamp(Timezone, year(time), month(time), dayofmonth(time) + 1, 12, 35, 0)
            else if matchedBaseModel == "Lima"
                // Force extension to 2235 (10:35 PM) for Lima
                endTime := timestamp(Timezone, year(time), month(time), dayofmonth(time), 22, 35, 0)
        
        // Create box with optional label
        string boxText = ShowDistCloseLabels ? matchedBaseModel + " " + str.format("{0,number,00}:{1,number,00}", currentHour, currentMinute) : ""
        box newBox = box.new(time, high, endTime, low, 
                             xloc = xloc.bar_time, 
                             bgcolor = boxColor, 
                             border_color = borderColor, 
                             border_width = 1,
                             text = boxText,
                             text_color = borderColor,
                             text_size = size.small,
                             text_halign = text.align_right,
                             text_valign = text.align_top)
        
        // Create midpoint line if enabled
        line newMidLine = na
        float midpoint = low + (high - low) / 2
        if ShowDistCloseMiddleLines
            newMidLine := line.new(time, midpoint, endTime, midpoint, 
                                  xloc.bar_time, 
                                  color = borderColor, 
                                  style = line.style_dashed,
                                  width = 1)
        
        // Store in array
        array.push(ArrayOfDistributionCloseCandles, 
                   DistributionCloseCandle.new(newBox, newMidLine, midpoint, high, low, time, candleDirection, matchedBaseModel))

// Distribution Close Candles Extension and Color Management
if ShowDistributionCloseCandles and array.size(ArrayOfDistributionCloseCandles) > 0
    for i = 0 to array.size(ArrayOfDistributionCloseCandles) - 1
        currentCandle = array.get(ArrayOfDistributionCloseCandles, i)
        
        // Extend in realtime if enabled
        if DistCloseExtendConfirmationCandle
            box.set_right(currentCandle.CandleBox, time)
            if not na(currentCandle.MidpointLine)
                line.set_x2(currentCandle.MidpointLine, time)
        
        // Update colors based on current price vs midpoint
        if ColorDistCloseDirection and not na(currentCandle.MidpointValue)
            if currentCandle.Direction == "Bull"
                if close < currentCandle.MidpointValue
                    // Bull candle with price below midpoint = inversion
                    box.set_bgcolor(currentCandle.CandleBox, DistCloseBoxInversionColor)
                    box.set_border_color(currentCandle.CandleBox, DistCloseBoxInversionBorderColor)
                else
                    // Bull candle with price above midpoint = normal bull
                    box.set_bgcolor(currentCandle.CandleBox, DistCloseBoxBullColor)
                    box.set_border_color(currentCandle.CandleBox, DistCloseBoxBullBorderColor)
            else if currentCandle.Direction == "Bear"
                if close > currentCandle.MidpointValue
                    // Bear candle with price above midpoint = inversion
                    box.set_bgcolor(currentCandle.CandleBox, DistCloseBoxInversionColor)
                    box.set_border_color(currentCandle.CandleBox, DistCloseBoxInversionBorderColor)
                else
                    // Bear candle with price below midpoint = normal bear
                    box.set_bgcolor(currentCandle.CandleBox, DistCloseBoxBearColor)
                    box.set_border_color(currentCandle.CandleBox, DistCloseBoxBearBorderColor)

// Cleanup old distribution close candles - keep only the most recent ones
var int MaxDistributionCloseCandles = 10
if array.size(ArrayOfDistributionCloseCandles) > MaxDistributionCloseCandles
    oldCandle = array.shift(ArrayOfDistributionCloseCandles)
    if not na(oldCandle.CandleBox)
        box.delete(oldCandle.CandleBox)
    if not na(oldCandle.MidpointLine)
        line.delete(oldCandle.MidpointLine)

// Base to Distribution Connection functions are now integrated into the main logic below

// Independent Base to Distribution Connection Creation Logic
if ShowBaseToDistConnections and barstate.isconfirmed
    currentHour = hour(time, Timezone)
    currentMinute = minute(time, Timezone)
    currentTimeString = str.format("{0,number,00}{1,number,00}", currentHour, currentMinute)
    
    // Check if current time matches any distribution close time (independent of base model toggles)
    string matchedBaseModel = ""
    int matchedIndex = -1
    bool shouldCreateConnection = false
    if array.size(DistributionCloseTimes) > 0
        for i = 0 to array.size(DistributionCloseTimes) - 1
            if currentTimeString == array.get(DistributionCloseTimes, i)
                matchedBaseModel := array.get(DistributionCloseBaseModels, i)
                matchedIndex := i
                shouldCreateConnection := true // Always create connection regardless of base model toggles
                break
    
    if shouldCreateConnection
        // Find the matching session (doesn't need to be confirmed base candle)
        SessionObject matchingSession = na
        if array.size(ArrayOfFractalObjects) > 0
            for i = 0 to array.size(ArrayOfFractalObjects) - 1
                sessionObj = array.get(ArrayOfFractalObjects, i)
                if not na(sessionObj.BaseSessionName) and sessionObj.BaseSessionName == matchedBaseModel
                    // Use any session, not just confirmed ones
                    matchingSession := sessionObj
                    break
        
        // Check if we already have a connection for this distribution time and base model
        bool connectionExists = false
        if array.size(ArrayOfBaseToDistConnections) > 0
            for i = 0 to array.size(ArrayOfBaseToDistConnections) - 1
                existingConnection = array.get(ArrayOfBaseToDistConnections, i)
                if existingConnection.DistCandleTime == time and existingConnection.BaseModel == matchedBaseModel
                    connectionExists := true
                    break
        
        // Create connection if it doesn't exist and we have a matching session
        if not connectionExists and not na(matchingSession)
            // Create a virtual distribution candle data
            string candleDirection = close > open ? "Bull" : "Bear"
            
            // Use session data instead of base candle data for truly independent operation
            float sessionHigh = matchingSession.HighFractal
            float sessionLow = matchingSession.LowFractal
            int sessionStartTime = matchingSession.OpenTime
            
            // If we have confirmed base candle data, use it; otherwise use session data
            if not na(matchingSession.ConfirmationTimeValue)
                // Use base candle data if available
                sessionHigh := matchingSession.ConfirmationCandleHighValue
                sessionLow := matchingSession.ConfirmationCandleLowValue
                sessionStartTime := matchingSession.ConfirmationTimeValue
            
            // Calculate extremes between session/base and current distribution close
            float highestHigh = math.max(sessionHigh, high)
            float lowestLow = math.min(sessionLow, low)
            
            // Determine connection direction
            string connectionDirection = "Mixed"
            if not na(matchingSession.ConfirmationDirectionDr)
                if matchingSession.ConfirmationDirectionDr == "Long" and candleDirection == "Bull"
                    connectionDirection := "Bull"
                else if matchingSession.ConfirmationDirectionDr == "Short" and candleDirection == "Bear"
                    connectionDirection := "Bear"
            else
                // Use session direction if no base candle confirmation
                if matchingSession.OpenValue < matchingSession.CloseValue and candleDirection == "Bull"
                    connectionDirection := "Bull"
                else if matchingSession.OpenValue > matchingSession.CloseValue and candleDirection == "Bear"
                    connectionDirection := "Bear"
            
            // Determine colors based on direction
            color boxColor = connectionDirection == "Bull" ? BaseToDistConnectionBullColor : connectionDirection == "Bear" ? BaseToDistConnectionBearColor : BaseToDistConnectionMixedColor
            color borderColor = connectionDirection == "Bull" ? BaseToDistConnectionBullBorderColor : connectionDirection == "Bear" ? BaseToDistConnectionBearBorderColor : BaseToDistConnectionMixedBorderColor
            
            // Calculate end time for the connection box
            int endTime = ExtendConnectionsRealtime ? time : time
            
            // Create connection box from session/base time to distribution candle time
            box connectionBox = box.new(sessionStartTime, highestHigh, endTime, lowestLow,
                                       xloc = xloc.bar_time,
                                       bgcolor = boxColor,
                                       border_color = borderColor,
                                       border_width = 1,
                                       text = matchingSession.BaseSessionName + " → Dist",
                                       text_color = borderColor,
                                       text_size = size.tiny,
                                       text_halign = text.align_center,
                                       text_valign = text.align_top)
            
            // Create connection line if enabled
            line connectionLine = na
            if ShowConnectionLines
                float midPrice = (highestHigh + lowestLow) / 2
                connectionLine := line.new(sessionStartTime, midPrice, time, midPrice,
                                          xloc = xloc.bar_time,
                                          color = borderColor,
                                          style = line.style_dashed,
                                          width = 2)
            
            // Create and store the connection
            BaseToDistributionConnection newConnection = BaseToDistributionConnection.new(connectionBox, connectionLine, highestHigh, lowestLow, sessionHigh, sessionLow, high, low, sessionStartTime, time, matchedBaseModel, connectionDirection, true)
            
            array.push(ArrayOfBaseToDistConnections, newConnection)

// Base to Distribution Connection Extension and Management
if ShowBaseToDistConnections and array.size(ArrayOfBaseToDistConnections) > 0
    for i = 0 to array.size(ArrayOfBaseToDistConnections) - 1
        connection = array.get(ArrayOfBaseToDistConnections, i)
        
        // Extend connection box in realtime if enabled
        if ExtendConnectionsRealtime and connection.IsActive
            box.set_right(connection.ConnectionBox, time)
            if not na(connection.ConnectionLine)
                line.set_x2(connection.ConnectionLine, time)

// Cleanup old base to distribution connections
if array.size(ArrayOfBaseToDistConnections) > MaxConnectionsToShow
    oldConnection = array.shift(ArrayOfBaseToDistConnections)
    if not na(oldConnection.ConnectionBox)
        box.delete(oldConnection.ConnectionBox)
    if not na(oldConnection.ConnectionLine)
        line.delete(oldConnection.ConnectionLine)

