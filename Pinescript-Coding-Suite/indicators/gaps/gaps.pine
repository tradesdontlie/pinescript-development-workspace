// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © jnovak1963zas

//@version=5
indicator(("TBRos Gaps∞"), overlay=true,max_lines_count = 500,max_labels_count = 500, max_boxes_count = 500)

import jnovak1963zas/LibraryQuantumWarrior369/17 as Quant


General_Group = "Gap Settings"
ShowLabel = input.bool(title="Gap Labels", defval=true, inline="1", group=General_Group)
ShowLabelDate = input.bool(title="Gap Label Date", defval=true, inline="1", group=General_Group)
ShowCeLines = input.bool(title="CEs", defval=true, inline="1", group=General_Group, tooltip="Show Consequence Encouragement Lines")
eventHorizon = input.bool(title="Event Horizon", defval=true, inline="1", group=General_Group, tooltip="Show NWOG Event Horizon")


Nwog_Group = "NWOGs"
showNWOG = input.bool(title="Show NWOG", defval=true, inline="1", group=Nwog_Group, tooltip="Show New Week Opening Gaps")
ExtendNwogsType = input.string(defval = "Realtime", title = "Extend To", options = ["End", "Realtime", "EndOfDay"], inline = "1", group = Nwog_Group, tooltip="Extend NWOGs to End of week, End of day or Extend in Realtime")
nwogsAmount = input.int(5, title="Number", minval=0, group = Nwog_Group, inline="1")
showNwogCE = ShowCeLines //input.bool(title="Show NWOG CE", defval=true, inline="1", group=Nwog_Group, tooltip="Show New Week Opening Gap. Consequence Encouragement")


bool extendAllNwogs = false
bool ExtendNwogsInRealtime = false
if ExtendNwogsType == "EndOfDay"
    extendAllNwogs := true//input.bool(title="Extend NWOGs", defval=true, inline="1", group=Nwog_Group, tooltip="Extend NWOGs forward for one day")
else if ExtendNwogsType == "Realtime"
    ExtendNwogsInRealtime := true//input.bool(title="Extend NWOGs in Realtime", defval=false, inline="1", group=Nwog_Group, tooltip="Extend NWOGs forward realtime")

Ndog_Group = "NDOGs"
showNDOG = input.bool(title="Show NDOG", defval=true, inline="1", group=Ndog_Group, tooltip="Show New Day Opening Gaps")
ExtendNdogsType = input.string(defval = "Realtime", title = "Extend To", options = ["End", "Realtime", "EndOfDay"], inline = "1", group = Ndog_Group, tooltip="Extend NDOGs to End of week, End of day or Extend in Realtime")
ndogsAmount  = input.int(5, title="Number", minval=0, group = Ndog_Group, inline="1")
showNdogCE = ShowCeLines //input.bool(title="Show NDOG CE", defval=true, inline="2", group=Ndog_Group, tooltip="Show New Day Opening Gap Consequence Encouragement")



bool extendAllNdogs = false
bool ExtendNdogsInRealtime = false
if ExtendNdogsType  == "EndOfDay"
    extendAllNdogs := true //input.bool(title="Extend NDOGs", defval=true, inline="2", group=Ndog_Group, tooltip="Extend NDOGs forward for one day")
else if ExtendNdogsType == "Realtime"
    ExtendNdogsInRealtime := true//input.bool(title="Extend NDOGs in Realtime", defval=false, inline="2", group=Ndog_Group, tooltip="Extend NDOGs forward realtime")

Rth_Group = "RTH Gaps"
ShowRthGap = input.bool(title="Show RTH", defval=true, inline="1", group=Rth_Group, tooltip="Show RTH Gaps")
ShowRthCe = ShowCeLines //input.bool(title="ShowRTH CE", defval=true, inline="2", group=Rth_Group, tooltip="Show RTH Gap Consequence Encouragement")
RthAmount  = input.int(5, title="Number of RTHs", minval=0, group = Rth_Group, inline="1")

RthGapStartAtOpening = input.bool(title="Start At Open", defval=false, inline="2", group=Rth_Group, tooltip="Start RTH Gap at RTH Open or RTH Close.")
ExtendRthsType = input.string(defval = "Open", title = "Extend To", options = ["Open", "Realtime", "EndOfDay"], inline = "2", group = Rth_Group, tooltip="Extend RTHs to End of week, End of day or Extend in Realtime")

bool ExtendRthGapsInRealtime = false
bool ExtendRthGapToNextDay = false //input.bool(title="Extend RTHs", defval=true, inline="2", group=Rth_Group, tooltip="Has no Impact if Start Box At Opening Price is selected")

if ExtendRthsType == "Realtime"
    ExtendRthGapsInRealtime := true //input.bool(title="Extend RTHs in Realtime", defval=false, inline="3", group=Rth_Group, tooltip="Extend Regular Trading Hour Gaps forward realtime. Has Highest precedence")
else if ExtendRthsType == "EndOfDay"
    ExtendRthGapToNextDay := true

Unmitigated_Group = "Mitigation Settings"
ShowUnmitigatedBox = input.bool(defval = true, title = "Show Unmitigated Box", inline = "1", group = Unmitigated_Group)
ShowUnmitigatedBoxLabel = input.bool(defval = true, title = "Show Label", inline = "1", group = Unmitigated_Group)
DeleteMitigatedNwogs = input.bool(defval = false, title = "Delete Mitigated NWOGs", inline = "2", group = Unmitigated_Group)
DeleteMitigatedNdogs = input.bool(defval = false, title = "NDOGs", inline = "2", group = Unmitigated_Group)
DeleteMitigatedRTHs = input.bool(defval = false, title = "RTHs", inline = "2", group = Unmitigated_Group)
DeleteMitigatedBoxes = true //input.bool(defval = true, title = "Delete Mitigated Boxes", inline = "1", group = Unmitigated_Group)
CalculateMitigation = true //input.bool(defval = true, title = "Calculate Mitigation", inline = "1", group = Unmitigated_Group)


AdvancedGapTheory_Group = "Advanced Gap Theory"
ShowProjectionLines = input.bool(title="Show Projections", defval=false, inline="1", group=AdvancedGapTheory_Group)
Gap1Select = input.string("NWOG1", options= ["NWOG1", "NWOG2","NWOG3","NWOG4","NWOG5","NDOG1","NDOG2","NDOG3","NDOG4","NDOG5","RTH1","RTH2","RTH3","RTH4","RTH5"], inline="1", group=AdvancedGapTheory_Group, title = "Gap1:")
Gap2Select = input.string("NWOG2", options= ["NWOG1", "NWOG2","NWOG3","NWOG4","NWOG5","NDOG1","NDOG2","NDOG3","NDOG4","NDOG5","RTH1","RTH2","RTH3","RTH4","RTH5"], inline="1", group=AdvancedGapTheory_Group, title = "Gap2:")
LinesToShow = input.string("Extremes", options=["Standard","CEs", "Extremes", "All"], inline="1", title = "Lines Type", group=AdvancedGapTheory_Group)
ExtendProjectionLinesInRealtime = input.bool(title="Extend Projections Realtime", defval=true, inline="1", group=AdvancedGapTheory_Group)
ShowProjectionLabels = input.bool(title="Show Labels", defval=true, inline="1", group=AdvancedGapTheory_Group)
StandardRangeStyleStdevs = input.string("", inline="1", title = "Add Additional Standard Stdevs: ", group=AdvancedGapTheory_Group)

ManualConfiguration = input.bool(title="Enable Manual Anchor", defval=false, inline="2", tooltip=AdvancedGapTheory_Group, group=AdvancedGapTheory_Group)
BullAnchor = input.string("0.0", options=["0.0", "0.25", "0.333", "0.50", "0.666", "0.75", "0.89"], inline="2", group=AdvancedGapTheory_Group, title = "Bull")
BearAnchor = input.string("0.0", options=["0.0", "0.25", "0.333", "0.50", "0.666", "0.75", "0.89"], inline="2", group=AdvancedGapTheory_Group, title = "Bear")




NwogColorsGroup = "NWOG Colors and Style"
nwogBg = input.color(color.rgb(95, 169, 230, 95), title="Background", group = NwogColorsGroup, inline="1")
nwogBorderColor = input.color(color.rgb(95, 169, 230, 70), title="Border", group = NwogColorsGroup, inline="1")
nwogCEColor = input.color(color.rgb(95, 169, 230, 70), title="CE", group = NwogColorsGroup, inline="1")
LabelColor = input.color(color.rgb(95, 169, 230, 70), title="Label", group = NwogColorsGroup, inline="1")
nwogCEStyleRaw = input.string(defval = "Dotted", title = "", options = ["Solid", "Dotted", "Dashed"], inline = "1", group = NwogColorsGroup, tooltip = "CE Line Style")
eventHorizonLineColor = input.color(color.rgb(95, 169, 230, 50), title="Event Horizon", group = NwogColorsGroup, inline="2")
eventHorizonLineStyleRaw = input.string(defval = "Dotted", title = "", options = ["Solid", "Dotted", "Dashed"], inline = "2", group = NwogColorsGroup)
EventHorizonLineWidth = input.int(2, title="", minval=0, group = NwogColorsGroup, inline="2", tooltip = "Event Horizon Line Width")


NdogColorsGroup = "NDOG Colors and Style"
ndogBg = input.color(color.rgb(223, 123, 123, 95), title="Background", group = NdogColorsGroup, inline="1")
ndogBorderColor = input.color(color.rgb(223, 123, 123, 70), title="Border", group = NdogColorsGroup, inline="1")
ndogCEColor = input.color(color.rgb(223, 123, 123, 70), title="CE", group = NdogColorsGroup, inline="1")
ndogLabelColor = input.color(color.rgb(223, 123, 123, 70), title="Label", group = NdogColorsGroup, inline="1")
ndogCEStyleRaw = input.string(defval = "Dotted", title = "", options = ["Solid", "Dotted", "Dashed"], inline = "1", group = NdogColorsGroup, tooltip = "CE Line Style")

Rth_ColorGroup = "RTH Colors"
RthBoxBgColor = input.color(color.new(color.gray, 90), title="Background", group = Rth_ColorGroup, inline="1")
RthBoxBorderColor = input.color(color.new(color.gray, 0), title="Border", group = Rth_ColorGroup, inline="1")
RthBoxCeColor = input.color(color.new(color.gray, 0), title="CE", group = Rth_ColorGroup, inline="1")
RthLabelColor = input.color(color.new(color.gray, 0), title="Label", group = Rth_ColorGroup, inline="1")
RthCeStyleRaw = input.string(defval = "Dotted", title = "", options = ["Solid", "Dotted", "Dashed"], inline = "1", group = Rth_ColorGroup, tooltip = "CE Line Style")

ProjectionColor_Group = "Projection Colors"
ProjectionColor = input.color(color.new(color.gray, 0), title="Line Colors", group = ProjectionColor_Group, inline="1")


UnmitigatedColors_Group = "Mitigation Colors"
UnmitigatedBoxColor = input.color(color.new(color.gray, 94), title="Box Color", inline = "1", group = UnmitigatedColors_Group)
UnmitigatedBoxBorderColor = input.color(color.new(color.gray, 80), title="Box Border", inline = "1", group = UnmitigatedColors_Group)
UnmitigatedCeColor =  input.color(color.new(color.purple, 60), title="Line Color", inline = "1", group = UnmitigatedColors_Group)
// MitigatedCeColor =  input.color(color.new(color.gray, 60), title="Mitigated EQ Line Color", inline = "5", group = UnmitigatedColors_Group)







previousNwogBg = nwogBorderColor
string LabelXPosition = text.align_right
string LabelYPosition = text.align_center
string LabelSize = size.small

string ndogLabelXPosition = text.align_right
string ndogLabelYPosition = text.align_center
string ndogLabelSize = size.small

previousNdogBg = ndogBg
string ndogLabel = "NDOG"
string Label = "NWOG"


nwogCEStyle = Quant.LineStyle(nwogCEStyleRaw)
ndogCEStyle = Quant.LineStyle(ndogCEStyleRaw)
eventHorizonLineStyle = Quant.LineStyle(eventHorizonLineStyleRaw)
RthCeStyle = Quant.LineStyle(RthCeStyleRaw)

type LineWithLabel
    line Line
    label Label

type ProjectionLines
    color Color
    array<float> LineValues
    array<LineWithLabel> Lines
    float NextRangeHighDeviation
    float NextRangeLowDeviation
    bool RangeHighChanged
    bool RangeLowChanged
    bool RangeHighExtreme
    bool RangeLowExtreme
    bool FirstRangeDrawn
    float InitialRange
    float InitialRangeHigh
    float InitialRangeLow
    float RangeValue
    float RangeHigh
    float RangeLow
    int RangeHighIndex
    int RangeLowIndex
	int StartTimeMin
	int StartTimeMax
	int EndTimeMin
	int EndTimeMax


var array<float> ArrayOfProjections = array.new<float>()
array<LineWithLabel> ArrayBlankLinesWithLabel = array.new<LineWithLabel>()
array<float> ArrayofBlankFloats = array.new<float>()
var ProjectionLines ProjectionLinesObject = na
var array<float> ArrayOfRangeHighLowAnchors = array.new<float>()

if barstate.isfirst
    ProjectionLinesObject := ProjectionLines.new(ProjectionColor,ArrayofBlankFloats,ArrayBlankLinesWithLabel,na,na,false,false,false,false,false,na,na,na,na,na,na,na,na,na,na)
    if LinesToShow == "All" 
        ArrayOfProjections := array.from(-0.111,0.0,0.03,0.111,0.17,0.25,0.29,0.333,0.382,0.41,0.47,0.5,0.53,0.59,0.618,0.666,0.71,0.75,0.83,0.89,0.97,1.0,1.111)
    else if LinesToShow == "CEs"
        ArrayOfProjections := array.from(0.0,0.03, 0.17,0.29,0.382,0.41,0.47,0.5,0.53,0.59,0.618,0.71,0.83,0.97,1.0)
    else if LinesToShow == "Extremes"
        ArrayOfProjections := array.from(-0.111,0.0,0.111,0.17,0.382,0.5,0.618,0.83,0.89,1.0,1.111)
    else
        ArrayOfProjections := array.from(-0.5,-0.111,0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.111,1.5)

    if StandardRangeStyleStdevs != ""
        TempArray = str.split(StandardRangeStyleStdevs, ",")
        for i = 0 to array.size(TempArray)-1       
            if not na(str.tonumber(array.get(TempArray, i)))
                array.push(ArrayOfProjections, str.tonumber(array.get(TempArray, i)))


    for i = 0 to array.size(ArrayOfProjections)-1
        array.push(ProjectionLinesObject.LineValues, array.get(ArrayOfProjections, i))

    ArrayOfRangeHighLowAnchors := array.from(0.0, 0.25, 0.333, 0.50, 0.666, 0.75, 0.89)


var string Timezone = na
var bool DST = na
// Rgray => got it from stackoverflow
int HourNY = hour(time, "America/New_York")
int HourUTC = hour(time, "UTC")
DST := HourUTC - HourUTC == 5 ? false : true
DST := HourUTC - HourNY == 5 or HourUTC - HourNY == -19 ? false : HourUTC - HourNY == 4 or HourUTC - HourNY == -20 ? true : na
if DST
    Timezone := "UTC-4:00"    
else
    Timezone := "UTC-5:00"

ONE_HOUR = 3600*1000
ONE_DAY = 24*ONE_HOUR
ONE_WEEK = ONE_DAY*7

var float sessionOpenPricePrice = na
var float sessionHighCandlePrice = na
var float sessionLowCandlePrice = na
var float SessionRange = na
var float SessionHighPrice = na
var float SessionLowPrice = na

var int CurrentLowRange = na
var int CurrentHighRange = na

var float CandleHigh = na
var float CandleLow = na

var int PrevLowRange = na



var bool NeedsOffset = false
var int TickerTimeOffset = na
var int TickerHourOffset = na
var int OpeningRangeTime = na
var int ClosingRangeTime = na
var int ClosingRangeTime15Min = na


var string CurrentTicker = Quant.GetTickerNameString(syminfo.ticker)

DAILY_OPEN_TIME = request.security(syminfo.tickerid, "D", time, lookahead = barmerge.lookahead_on)
DAILY_CLOSE_TIME = request.security(syminfo.tickerid, "D", time_close, lookahead = barmerge.lookahead_on)
var int OpeningRange = na
// if CurrentTicker == "CL"
//     OpeningRangeTime := timestamp(Timezone, year, month, dayofmonth, 9, 0, 0)
//     ClosingRangeTime := timestamp(Timezone, year, month, dayofmonth, 16, 15, 0)
// else if CurrentTicker == "NQ" or CurrentTicker == "ES" or CurrentTicker == "YM" or CurrentTicker == "RTY" or CurrentTicker == "BTC" or CurrentTicker == "ETH"
//     OpeningRangeTime := timestamp(Timezone, year, month, dayofmonth, 9, 30, 0)
//     ClosingRangeTime := timestamp(Timezone, year, month, dayofmonth, 16, 15, 0)
// else if CurrentTicker == "SI" or CurrentTicker == "NG" or CurrentTicker == "ZB" or CurrentTicker == "ZN" or CurrentTicker == "ZF" or CurrentTicker == "GC"
//     OpeningRangeTime := timestamp(Timezone, year, month, dayofmonth, 8, 20, 0) 
//     ClosingRangeTime := timestamp(Timezone, year, month, dayofmonth, 16, 15, 0)

if CurrentTicker == "ZW" or CurrentTicker == "ZS" or CurrentTicker == "ZC"
    OpeningRangeTime := timestamp(Timezone, year, month, dayofmonth, 9, 30, 0)
    ClosingRangeTime := timestamp(Timezone, year, month, dayofmonth, 14, 15, 0)
else if CurrentTicker == "HE" or CurrentTicker == "LE" or CurrentTicker == "GF"
    OpeningRangeTime := timestamp(Timezone, year, month, dayofmonth, 9, 30, 0)
    ClosingRangeTime := timestamp(Timezone, year, month, dayofmonth, 14, 0, 0)
else
    OpeningRangeTime := timestamp(Timezone, year, month, dayofmonth, 9, 30, 0)
    ClosingRangeTime := timestamp(Timezone, year, month, dayofmonth, 16, 15, 0)



if hour(DAILY_OPEN_TIME)-18 != 0 and not(syminfo.type == "forex")
    TickerHourOffset := 18-hour(DAILY_OPEN_TIME)
    if syminfo.type == "crypto"
        TickerHourOffset := TickerHourOffset+1
else
    TickerHourOffset := 0
    NeedsOffset := false
TickerTimeOffset := TickerHourOffset*ONE_HOUR




var array<line> ArrayOfLines = array.new<line>()
var array<label> ArrayOfLabels = array.new<label>()





// { START NWOG and NDOG Logic

// START Based on © cryptonnnite
type gap
    float high
    float low
    int start
    int end


getGapData() =>
    gap.new(math.max(close[1], open), math.min(close[1], open), time, time_close)

getDayOfWeekLabel(_dayofweek) =>
    switch _dayofweek
        dayofweek.sunday => "Sun"
        dayofweek.monday => "Mon"
        dayofweek.tuesday => "Tue"
        dayofweek.wednesday => "Wed"
        dayofweek.thursday => "Thu"
        dayofweek.friday => "Fri"
        dayofweek.saturday => "Sat"


bool fiveToSixGap = true
bool showPriceLabels = false

type NwogNdogData
    float CeValue
    float HighValue
    float LowValue
    box Box
    line CeLine
    label Label
    int StartTime
    int EndTime
    box UnmitigatedBox
    bool FreshUnmitigatedBox
    string BoxStartPriceAboveBelow
    float MaxHighLowValue
    bool Mitigated

var array<NwogNdogData> ArrayOfNwogs = array.new<NwogNdogData>()
var array<NwogNdogData> ArrayOfNdogs = array.new<NwogNdogData>()


// var line eventHorizonLine = na
var array<line> ArrayOfEventHorizonLines = array.new<line>()

var float Gap1CeValue = na
var float Gap2CeValue = na
gap weekOpeningGap = request.security(syminfo.tickerid, "1W", getGapData(), lookahead =  barmerge.lookahead_on)
[dayOpeningGap, currentDayTimeClose] = request.security(syminfo.tickerid, "1D", [getGapData(), time_close], lookahead =  barmerge.lookahead_on)
[isNewWeek, hourPreviousBarClose, hourCurrentBarOpen] = request.security(syminfo.tickerid, "240", [Quant.NewCandle("W"), close[1], open], lookahead =  barmerge.lookahead_on)


if timeframe.isintraday and Quant.NewCandle("D") and fiveToSixGap
    dayOpeningGap.high := math.max(close[1], open)
    dayOpeningGap.low := math.min(close[1], open)

if timeframe.multiplier < 60
    if isNewWeek and fiveToSixGap
        weekOpeningGap.high := math.max(hourPreviousBarClose, hourCurrentBarOpen)
        weekOpeningGap.low := math.min(hourPreviousBarClose, hourCurrentBarOpen)
else if (timeframe.isdaily or timeframe.isintraday) and Quant.NewCandle("W") and fiveToSixGap
    weekOpeningGap.high := math.max(close[1], open)
    weekOpeningGap.low := math.min(close[1], open)



if showNWOG and (timeframe.isdaily or timeframe.isintraday) 
    if Quant.NewCandle("W")
        float nwogCePrice = (weekOpeningGap.high + weekOpeningGap.low) / 2
        
        if ShowLabel and array.size(ArrayOfNwogs) > 0
            GapIndex = 2
            string Text = ""
            for i = array.size(ArrayOfNwogs)-1 to 0
                CurrentArtefact = array.get(ArrayOfNwogs, i)
                Text := "NWOG" + str.tostring(GapIndex)
                GapIndex := GapIndex+1
                if ShowLabelDate 
                    Text := str.format_time(CurrentArtefact.StartTime, "dd.MM") + " " + Text                     
                label.set_text(CurrentArtefact.Label, Text)

        
        line CeLine = na

        if showNwogCE
            color CeColor = nwogCEColor
            if ShowUnmitigatedBox
                CeColor := UnmitigatedCeColor
            CeLine := line.new(weekOpeningGap.start, nwogCePrice,weekOpeningGap.end, nwogCePrice, xloc = xloc.bar_time, style = nwogCEStyle, color = CeColor)

        string LabelString = ""

        if ShowLabel
            LabelString := "NWOG1"

            if ShowLabelDate
                LabelString := str.format_time(weekOpeningGap.start, "dd.MM") + " " + LabelString

        LabelGap = label.new(weekOpeningGap.end, nwogCePrice,LabelString, style = label.style_label_left, xloc = xloc.bar_time, color = color.rgb(0, 0, 0, 100), textcolor = LabelColor, size = LabelSize)

        Box = box.new(weekOpeningGap.start, weekOpeningGap.high, weekOpeningGap.end, weekOpeningGap.low, xloc = xloc.bar_time, bgcolor = nwogBg, border_color = nwogBorderColor, border_width = 1)



        box UnmitigatedBox = na
        if ShowUnmitigatedBox
            string BelowAboveString = na

            float MitigationHighLow = na
            string FractalEqDirection = na
            float MitigationLow = na
            float MitigationHigh = na

            string UnmitigatedAllign = text.align_bottom
            if close > nwogCePrice
                BelowAboveString := "Above"
                MitigationHighLow := weekOpeningGap.high
                UnmitigatedAllign := text.align_bottom
            else if close < nwogCePrice
                BelowAboveString := "Below"
                MitigationHighLow := weekOpeningGap.low
                UnmitigatedAllign := text.align_top
            else
                BelowAboveString := "Mitigated"
                UnmitigatedAllign := text.align_top

            string UnmitigatedLabel = ''
            if ShowUnmitigatedBoxLabel
                UnmitigatedLabel := "0%"


            UnmitigatedBox := box.new(weekOpeningGap.start, weekOpeningGap.high, weekOpeningGap.end, weekOpeningGap.low, xloc = xloc.bar_time, bgcolor = UnmitigatedBoxColor, border_color = UnmitigatedBoxBorderColor, border_width = 1, text = UnmitigatedLabel, text_color = UnmitigatedCeColor, text_halign = text.align_right, text_valign = UnmitigatedAllign,text_size = size.small)

        NwogObject = NwogNdogData.new(nwogCePrice,weekOpeningGap.high,weekOpeningGap.low,Box,CeLine,LabelGap,weekOpeningGap.start,weekOpeningGap.end, UnmitigatedBox, true, na, open, false)

        array.push(ArrayOfNwogs, NwogObject)                

                
        
        if eventHorizon and array.size(ArrayOfNwogs) > 1
            box currentNwog = array.last(ArrayOfNwogs).Box
            box previousNwog = array.get(ArrayOfNwogs, array.size(ArrayOfNwogs) - 2).Box

            float currentNwog_high = box.get_top(currentNwog)
            float currentNwog_low = box.get_bottom(currentNwog)
            
            float previousNwog_high = box.get_top(previousNwog)
            float previousNwog_low = box.get_bottom(previousNwog)
            
            float eventHorizonLevel = 0.0

            if currentNwog_high > previousNwog_high and currentNwog_low > previousNwog_high
                eventHorizonLevel := (currentNwog_low + previousNwog_high) / 2
            else if previousNwog_high > currentNwog_high and previousNwog_low > currentNwog_high
                eventHorizonLevel := (previousNwog_low + currentNwog_high) / 2

            array.push(ArrayOfEventHorizonLines, line.new(weekOpeningGap.start, eventHorizonLevel, weekOpeningGap.end, eventHorizonLevel, xloc = xloc.bar_time, style = eventHorizonLineStyle, color = eventHorizonLineColor, width = EventHorizonLineWidth))
            // line.delete(eventHorizonLine[1])
            if array.size(ArrayOfEventHorizonLines) >  array.size(ArrayOfNwogs)-1
                line.delete(array.shift(ArrayOfEventHorizonLines))


if showNDOG and timeframe.isintraday
    if Quant.NewCandle("D") // and dayOpeningGap.high != dayOpeningGap.low
        if (dayofweek != dayofweek.sunday and showNWOG) or not showNWOG
            float ndogCePrice = (dayOpeningGap.high + dayOpeningGap.low) / 2

            if ShowLabel and array.size(ArrayOfNdogs) > 0
                GapIndex = 2
                string Text = ""
                for i = array.size(ArrayOfNdogs)-1 to 0
                    CurrentArtefact = array.get(ArrayOfNdogs, i)
                    Text := "NDOG" + str.tostring(GapIndex)
                    GapIndex := GapIndex+1
                    if ShowLabelDate 
                        Text :=  str.format_time(CurrentArtefact.StartTime, "dd.MM") + " " + Text             
                    label.set_text(CurrentArtefact.Label, Text)


            string LabelString = ""

            if ShowLabel
                LabelString := "NDOG1"

                if ShowLabelDate
                    LabelString := str.format_time(weekOpeningGap.start, "dd.MM") + " " + LabelString        



            line CeLine = na
            if showNdogCE
                color CeColor = ndogCEColor
                if ShowUnmitigatedBox
                    CeColor := UnmitigatedCeColor
                CeLine := line.new(dayOpeningGap.start, ndogCePrice, dayOpeningGap.end, ndogCePrice, xloc = xloc.bar_time, style = ndogCEStyle, color = CeColor)

            LabelGap = label.new(dayOpeningGap.end, ndogCePrice,LabelString, style = label.style_label_left, xloc = xloc.bar_time, color = color.rgb(0, 0, 0, 100), textcolor = ndogLabelColor, size = ndogLabelSize)

            Box = box.new(dayOpeningGap.start, dayOpeningGap.high, dayOpeningGap.end, dayOpeningGap.low, xloc = xloc.bar_time, bgcolor = ndogBg, border_color = ndogBorderColor, border_width = 1)


            box UnmitigatedBox = na
            if ShowUnmitigatedBox
                string BelowAboveString = na

                float MitigationHighLow = na
                string FractalEqDirection = na
                float MitigationLow = na
                float MitigationHigh = na

                string UnmitigatedAllign = text.align_bottom
                if close > ndogCePrice
                    BelowAboveString := "Above"
                    MitigationHighLow := dayOpeningGap.high
                    UnmitigatedAllign := text.align_bottom
                else if close < ndogCePrice
                    BelowAboveString := "Below"
                    MitigationHighLow := dayOpeningGap.low
                    UnmitigatedAllign := text.align_top
                else
                    BelowAboveString := "Mitigated"
                    UnmitigatedAllign := text.align_top

                string UnmitigatedLabel = ''
                if ShowUnmitigatedBoxLabel
                    UnmitigatedLabel := "0%"


                UnmitigatedBox := box.new(dayOpeningGap.start, dayOpeningGap.high, dayOpeningGap.end, dayOpeningGap.low, xloc = xloc.bar_time, bgcolor = UnmitigatedBoxColor, border_color = UnmitigatedBoxBorderColor, border_width = 1, text = UnmitigatedLabel, text_color = UnmitigatedCeColor, text_halign = text.align_right, text_valign = UnmitigatedAllign,text_size = size.small)




            NdogObject = NwogNdogData.new(ndogCePrice,dayOpeningGap.high,dayOpeningGap.low,Box,CeLine,LabelGap,dayOpeningGap.start,dayOpeningGap.end, UnmitigatedBox, true, na, open, false)

            array.push(ArrayOfNdogs, NdogObject)
    // END Based on © cryptonnnite




// } END NWOG and NDOG Logic



// { START RTH Logic

type RthGap
    float ClosePrice
    float OpenPrice
    int StartTime
    int EndTime
    box Box
    line CeLine
    label Label
    float CeValue
    string Direction
    string CloseDay
    box UnmitigatedBox
    bool FreshUnmitigatedBox
    string BoxStartPriceAboveBelow
    float MaxHighLowValue
    bool Mitigated


var array<RthGap> ArrayOfRthGaps = array.new<RthGap>()

var float ClosePrice = na
var int CloseTime = na



// START Table
ShowTable1 = true
TableBackgroundColor1 = color.new(color.black, 0)
TableTextColor1 = color.new(color.white, 0)
TableFrameColor1 = color.new(color.black, 0)
TableBorderColor1 = color.new(color.black, 0)
TableBorderWidth1 = 1
TableFrameWidth1 = 1
TableTextSize1 = size.auto
TablePosition1 = position.middle_center
var Table1 = table.new(columns=15, rows=50, bgcolor=TableBackgroundColor1,frame_color=TableFrameColor1, border_width=TableBorderWidth1, position =  TablePosition1, frame_width = TableFrameWidth1, border_color = TableBorderColor1)
// END Table


var bool RthClosePriceShouldProcess = false
var string CloseDay = na



ModifiedTicker = ticker.modify(syminfo.tickerid, session = session.regular)
[Open15Min,Close15Min,TimeOpen15Min,TimeClose15Min] = request.security(ModifiedTicker,"15", [open,close,time,time_close],lookahead = barmerge.lookahead_on)

if TimeClose15Min == ClosingRangeTime
    ClosePrice := Close15Min
    CloseTime := time
    RthClosePriceShouldProcess := true
    CloseDay := str.format_time(time, "E")

else if TimeOpen15Min == OpeningRangeTime and RthClosePriceShouldProcess and not Quant.IsDay("Sun")
    box Box = na
    line Line = na
    label LabelInt = na
    string Direction = na
    string LabelString = na

    float ValueHigh = na
    float ValueLow = na


    if ShowLabel and array.size(ArrayOfRthGaps) > 0
        GapIndex = 2
        string Text = ""
        for i = array.size(ArrayOfRthGaps)-1 to 0
            CurrentArtefact = array.get(ArrayOfRthGaps, i)
            Text := "RTH" + str.tostring(GapIndex)
            GapIndex := GapIndex+1
            if ShowLabelDate 
                Text := str.format_time(CurrentArtefact.StartTime, "dd.MM") + " " + Text                     
            label.set_text(CurrentArtefact.Label, Text)


    if ClosePrice > Open15Min
        ValueHigh := ClosePrice
        ValueLow := Open15Min
        Direction := "Bear"
    else
        ValueHigh := Open15Min
        ValueLow := ClosePrice
        Direction := "Bull"

    CeValue = ValueLow+(ValueHigh-ValueLow)/2

    if ShowRthGap
        Box :=  box.new(CloseTime, ClosePrice, time, Open15Min, xloc = xloc.bar_time, bgcolor = RthBoxBgColor, border_color = RthBoxBorderColor, border_width = 1)
        if ShowRthCe
            color CeColor = RthBoxCeColor
            if ShowUnmitigatedBox
                CeColor := UnmitigatedCeColor 
            Line := line.new(CloseTime, CeValue, time, CeValue, color = CeColor, style = RthCeStyle, xloc = xloc.bar_time)

        if ShowLabel
            LabelString := "RTH1"
            if ShowLabelDate
                LabelString := str.format_time(time, "dd.MM") + " " + LabelString

            LabelInt := label.new(time, CeValue, LabelString, style = label.style_label_left, xloc = xloc.bar_time, color = color.rgb(0, 0, 0, 100), textcolor = RthLabelColor, size = LabelSize)


        box UnmitigatedBox = na
        if ShowUnmitigatedBox
            string BelowAboveString = na

            float MitigationHighLow = na
            string FractalEqDirection = na
            float MitigationLow = na
            float MitigationHigh = na

            string UnmitigatedAllign = text.align_bottom
            if close > CeValue
                BelowAboveString := "Above"
                MitigationHighLow := weekOpeningGap.high
                UnmitigatedAllign := text.align_bottom
            else if close < CeValue
                BelowAboveString := "Below"
                MitigationHighLow := weekOpeningGap.low
                UnmitigatedAllign := text.align_top
            else
                BelowAboveString := "Mitigated"
                UnmitigatedAllign := text.align_top

            string UnmitigatedLabel = ''
            if ShowUnmitigatedBoxLabel
                UnmitigatedLabel := "0%"


            UnmitigatedBox := box.new(time, ClosePrice, time, Open15Min, xloc = xloc.bar_time, bgcolor = UnmitigatedBoxColor, border_color = UnmitigatedBoxBorderColor, border_width = 1, text = UnmitigatedLabel, text_color = UnmitigatedCeColor, text_halign = text.align_right, text_valign = UnmitigatedAllign,text_size = size.small)





        RthObject = RthGap.new(ClosePrice, Open15Min, time, CloseTime, Box, Line, LabelInt, CeValue, Direction,CloseDay, UnmitigatedBox, true, na, open, false)
        array.push(ArrayOfRthGaps, RthObject)
        RthClosePriceShouldProcess := false

 
// } END RTH Logic




// { START Mitigation Logic 
if ShowUnmitigatedBox
    if array.size(ArrayOfNwogs) > 0
        for i = 0 to array.size(ArrayOfNwogs)-1
            CurrentArtefact = array.get(ArrayOfNwogs, i)
            if not CurrentArtefact.Mitigated
                float RangeClosed = 0.00
                float OpenCloseLow = CurrentArtefact.LowValue
                float OpenCloseHigh = CurrentArtefact.HighValue
                box.set_right(CurrentArtefact.UnmitigatedBox, time)
                if ShowCeLines
                    line.set_x2(CurrentArtefact.CeLine, time)

                FractalHighLow = math.abs(OpenCloseHigh-OpenCloseLow)
                Eq = OpenCloseLow + FractalHighLow/2

                if CurrentArtefact.FreshUnmitigatedBox
                    if close > Eq
                        CurrentArtefact.BoxStartPriceAboveBelow := "Above"
                    else
                        CurrentArtefact.BoxStartPriceAboveBelow := "Below"   

                    CurrentArtefact.FreshUnmitigatedBox := false

                if CurrentArtefact.BoxStartPriceAboveBelow == "Above"
                    CurrentArtefact.MaxHighLowValue := math.min(CurrentArtefact.MaxHighLowValue, low)
                    RangeClosedCalc = OpenCloseHigh-CurrentArtefact.MaxHighLowValue
                    CurrentPercent = (RangeClosedCalc/FractalHighLow)

                    RangeClosed := math.max(RangeClosed, CurrentPercent)
                        
                    if RangeClosed >= 0 and RangeClosed < 1
                        if CalculateMitigation
                            box.set_top(CurrentArtefact.UnmitigatedBox, CurrentArtefact.MaxHighLowValue)
                        if ShowUnmitigatedBoxLabel
                            box.set_text(CurrentArtefact.UnmitigatedBox, str.tostring(1-RangeClosed, "#.##%"))
                        if RangeClosed > 0.5
                            box.set_text_color(CurrentArtefact.UnmitigatedBox, nwogCEColor)
                            if ShowCeLines
                                line.set_color(CurrentArtefact.CeLine, nwogCEColor)


                    else
                        CurrentArtefact.Mitigated := true
                        RangeClosed := 1
                        if DeleteMitigatedBoxes
                            box.delete(CurrentArtefact.UnmitigatedBox)
                            if ShowCeLines
                                line.set_color(CurrentArtefact.CeLine, nwogCEColor)

                        else
                            box.set_top(CurrentArtefact.UnmitigatedBox, CurrentArtefact.LowValue)
                            box.set_text_color(CurrentArtefact.UnmitigatedBox, nwogCEColor)
                            if ShowCeLines
                                line.set_color(CurrentArtefact.CeLine, nwogCEColor)

                            if CalculateMitigation
                                if ShowUnmitigatedBoxLabel
                                    box.set_text(CurrentArtefact.UnmitigatedBox, str.tostring(1-RangeClosed, "#.##%"))                

                else if CurrentArtefact.BoxStartPriceAboveBelow == "Below"
                    CurrentArtefact.MaxHighLowValue := math.max(CurrentArtefact.MaxHighLowValue, high)
                    RangeClosedCalc = CurrentArtefact.MaxHighLowValue-OpenCloseLow
                    CurrentPercent = (RangeClosedCalc/FractalHighLow)

                    RangeClosed := math.max(RangeClosed, CurrentPercent)
                        
                    if RangeClosed >= 0 and RangeClosed < 1
                        if CalculateMitigation
                            box.set_bottom(CurrentArtefact.UnmitigatedBox, CurrentArtefact.MaxHighLowValue)
                        if ShowUnmitigatedBoxLabel 
                            box.set_text(CurrentArtefact.UnmitigatedBox, str.tostring(1-RangeClosed, "#.##%"))
                        if RangeClosed > 0.5
                            box.set_text_color(CurrentArtefact.UnmitigatedBox, nwogCEColor)
                            if ShowCeLines
                                line.set_color(CurrentArtefact.CeLine, nwogCEColor)

                    else
                        CurrentArtefact.Mitigated := true
                        RangeClosed := 1
                        if DeleteMitigatedBoxes
                            box.delete(CurrentArtefact.UnmitigatedBox)
                            if ShowCeLines
                                line.set_color(CurrentArtefact.CeLine, nwogCEColor)
                        else
                            box.set_top(CurrentArtefact.UnmitigatedBox, CurrentArtefact.HighValue)
                            box.set_text_color(CurrentArtefact.UnmitigatedBox, nwogCEColor)
                            if ShowCeLines
                                line.set_color(CurrentArtefact.CeLine, nwogCEColor)

                            if CalculateMitigation
                                if ShowUnmitigatedBoxLabel
                                    box.set_text(CurrentArtefact.UnmitigatedBox, str.tostring(1-RangeClosed, "#.##%"))
           
                box.set_right(CurrentArtefact.UnmitigatedBox, time)
                if ShowCeLines
                    line.set_x2(CurrentArtefact.CeLine, time)

    if array.size(ArrayOfNdogs) > 0
        for i = 0 to array.size(ArrayOfNdogs)-1
            CurrentArtefact = array.get(ArrayOfNdogs, i)
            if not CurrentArtefact.Mitigated
                float RangeClosed = 0.00
                float OpenCloseLow = CurrentArtefact.LowValue
                float OpenCloseHigh = CurrentArtefact.HighValue
                box.set_right(CurrentArtefact.UnmitigatedBox, time)
                if ShowCeLines
                    line.set_x2(CurrentArtefact.CeLine, time)

                FractalHighLow = math.abs(OpenCloseHigh-OpenCloseLow)
                Eq = OpenCloseLow + FractalHighLow/2

                if CurrentArtefact.FreshUnmitigatedBox
                    if close > Eq
                        CurrentArtefact.BoxStartPriceAboveBelow := "Above"
                    else
                        CurrentArtefact.BoxStartPriceAboveBelow := "Below"   

                    CurrentArtefact.FreshUnmitigatedBox := false

                if CurrentArtefact.BoxStartPriceAboveBelow == "Above"
                    CurrentArtefact.MaxHighLowValue := math.min(CurrentArtefact.MaxHighLowValue, low)
                    RangeClosedCalc = OpenCloseHigh-CurrentArtefact.MaxHighLowValue
                    CurrentPercent = (RangeClosedCalc/FractalHighLow)

                    RangeClosed := math.max(RangeClosed, CurrentPercent)
                        
                    if RangeClosed >= 0 and RangeClosed < 1
                        if CalculateMitigation
                            box.set_top(CurrentArtefact.UnmitigatedBox, CurrentArtefact.MaxHighLowValue)
                        if ShowUnmitigatedBoxLabel
                            box.set_text(CurrentArtefact.UnmitigatedBox, str.tostring(1-RangeClosed, "#.##%"))
                        if RangeClosed > 0.5
                            box.set_text_color(CurrentArtefact.UnmitigatedBox, ndogCEColor)
                            if ShowCeLines
                                line.set_color(CurrentArtefact.CeLine, ndogCEColor)

                    else
                        CurrentArtefact.Mitigated := true
                        RangeClosed := 1
                        if DeleteMitigatedBoxes
                            box.delete(CurrentArtefact.UnmitigatedBox)
                            if ShowCeLines
                                line.set_color(CurrentArtefact.CeLine, ndogCEColor)

                        else
                            box.set_top(CurrentArtefact.UnmitigatedBox, CurrentArtefact.LowValue)
                            box.set_text_color(CurrentArtefact.UnmitigatedBox, ndogCEColor)
                            if ShowCeLines
                                line.set_color(CurrentArtefact.CeLine, ndogCEColor)

                            if CalculateMitigation
                                if ShowUnmitigatedBoxLabel
                                    box.set_text(CurrentArtefact.UnmitigatedBox, str.tostring(1-RangeClosed, "#.##%"))

                    
                else if CurrentArtefact.BoxStartPriceAboveBelow == "Below"
                    CurrentArtefact.MaxHighLowValue := math.max(CurrentArtefact.MaxHighLowValue, high)
                    RangeClosedCalc = CurrentArtefact.MaxHighLowValue-OpenCloseLow
                    CurrentPercent = (RangeClosedCalc/FractalHighLow)

                    RangeClosed := math.max(RangeClosed, CurrentPercent)
                        
                    if RangeClosed >= 0 and RangeClosed < 1
                        if CalculateMitigation
                            box.set_bottom(CurrentArtefact.UnmitigatedBox, CurrentArtefact.MaxHighLowValue)
                        if ShowUnmitigatedBoxLabel 
                            box.set_text(CurrentArtefact.UnmitigatedBox, str.tostring(1-RangeClosed, "#.##%"))
                        if RangeClosed > 0.5
                            box.set_text_color(CurrentArtefact.UnmitigatedBox, ndogCEColor)
                            if ShowCeLines
                                line.set_color(CurrentArtefact.CeLine, ndogCEColor)

                    else
                        CurrentArtefact.Mitigated := true
                        RangeClosed := 1
                        if DeleteMitigatedBoxes
                            box.delete(CurrentArtefact.UnmitigatedBox)
                            if ShowCeLines
                                line.set_color(CurrentArtefact.CeLine, ndogCEColor)
                        else
                            box.set_top(CurrentArtefact.UnmitigatedBox, CurrentArtefact.HighValue)
                            box.set_text_color(CurrentArtefact.UnmitigatedBox, ndogCEColor)
                            if ShowCeLines
                                line.set_color(CurrentArtefact.CeLine, ndogCEColor)

                            if CalculateMitigation
                                if ShowUnmitigatedBoxLabel
                                    box.set_text(CurrentArtefact.UnmitigatedBox, str.tostring(1-RangeClosed, "#.##%"))
           

                box.set_right(CurrentArtefact.UnmitigatedBox, time)
                if ShowCeLines
                    line.set_x2(CurrentArtefact.CeLine, time)   



    if array.size(ArrayOfRthGaps) > 0
        for i = 0 to array.size(ArrayOfRthGaps)-1
            CurrentArtefact = array.get(ArrayOfRthGaps, i)

            float HighValue = na
            float LowValue = na

            if CurrentArtefact.ClosePrice > CurrentArtefact.OpenPrice
                HighValue := CurrentArtefact.ClosePrice
                LowValue := CurrentArtefact.OpenPrice
            else
                HighValue := CurrentArtefact.OpenPrice
                LowValue := CurrentArtefact.ClosePrice

            if not CurrentArtefact.Mitigated
                float RangeClosed = 0.00
                float OpenCloseLow = LowValue
                float OpenCloseHigh = HighValue
                box.set_right(CurrentArtefact.UnmitigatedBox, time)
                if ShowCeLines
                    line.set_x2(CurrentArtefact.CeLine, time)

                FractalHighLow = math.abs(OpenCloseHigh-OpenCloseLow)
                Eq = OpenCloseLow + FractalHighLow/2

                if CurrentArtefact.FreshUnmitigatedBox
                    if close > Eq
                        CurrentArtefact.BoxStartPriceAboveBelow := "Above"
                    else
                        CurrentArtefact.BoxStartPriceAboveBelow := "Below"   

                    CurrentArtefact.FreshUnmitigatedBox := false

                if CurrentArtefact.BoxStartPriceAboveBelow == "Above"
                    CurrentArtefact.MaxHighLowValue := math.min(CurrentArtefact.MaxHighLowValue, low)
                    RangeClosedCalc = OpenCloseHigh-CurrentArtefact.MaxHighLowValue
                    CurrentPercent = (RangeClosedCalc/FractalHighLow)

                    RangeClosed := math.max(RangeClosed, CurrentPercent)


                    if RangeClosed >= 0 and RangeClosed < 1
                        if CalculateMitigation
                            box.set_bottom(CurrentArtefact.UnmitigatedBox, CurrentArtefact.MaxHighLowValue)
                        if ShowUnmitigatedBoxLabel
                            box.set_text(CurrentArtefact.UnmitigatedBox, str.tostring(1-RangeClosed, "#.##%"))
                        if RangeClosed > 0.5
                            box.set_text_color(CurrentArtefact.UnmitigatedBox, RthBoxCeColor)
                            if ShowCeLines
                                line.set_color(CurrentArtefact.CeLine, RthBoxCeColor)

                    else
                        CurrentArtefact.Mitigated := true
                        RangeClosed := 1
                        if DeleteMitigatedBoxes
                            box.delete(CurrentArtefact.UnmitigatedBox)
                            if ShowCeLines
                                line.set_color(CurrentArtefact.CeLine, RthBoxCeColor)

                        else
                            box.set_bottom(CurrentArtefact.UnmitigatedBox, LowValue)
                            box.set_text_color(CurrentArtefact.UnmitigatedBox, RthBoxCeColor)
                            if ShowCeLines
                                line.set_color(CurrentArtefact.CeLine, RthBoxCeColor)

                            if CalculateMitigation
                                if ShowUnmitigatedBoxLabel
                                    box.set_text(CurrentArtefact.UnmitigatedBox, str.tostring(1-RangeClosed, "#.##%"))

                    
                else if CurrentArtefact.BoxStartPriceAboveBelow == "Below"
                    CurrentArtefact.MaxHighLowValue := math.max(CurrentArtefact.MaxHighLowValue, high)
                    RangeClosedCalc = CurrentArtefact.MaxHighLowValue-OpenCloseLow
                    CurrentPercent = (RangeClosedCalc/FractalHighLow)

                    RangeClosed := math.max(RangeClosed, CurrentPercent)
                        
                    if RangeClosed >= 0 and RangeClosed < 1
                        if CalculateMitigation
                            box.set_bottom(CurrentArtefact.UnmitigatedBox, CurrentArtefact.MaxHighLowValue)
                        if ShowUnmitigatedBoxLabel 
                            box.set_text(CurrentArtefact.UnmitigatedBox, str.tostring(1-RangeClosed, "#.##%"))
                        if RangeClosed > 0.5
                            box.set_text_color(CurrentArtefact.UnmitigatedBox, RthBoxCeColor)
                            if ShowCeLines
                                line.set_color(CurrentArtefact.CeLine, RthBoxCeColor)

                    else
                        CurrentArtefact.Mitigated := true
                        RangeClosed := 1
                        if DeleteMitigatedBoxes
                            box.delete(CurrentArtefact.UnmitigatedBox)
                            if ShowCeLines
                                line.set_color(CurrentArtefact.CeLine, RthBoxCeColor)
                        else
                            box.set_bottom(CurrentArtefact.UnmitigatedBox, HighValue)
                            box.set_text_color(CurrentArtefact.UnmitigatedBox, RthBoxCeColor)
                            if ShowCeLines
                                line.set_color(CurrentArtefact.CeLine, RthBoxCeColor)

                            if CalculateMitigation
                                if ShowUnmitigatedBoxLabel
                                    box.set_text(CurrentArtefact.UnmitigatedBox, str.tostring(1-RangeClosed, "#.##%"))
           

                box.set_right(CurrentArtefact.UnmitigatedBox, time)
                if ShowCeLines
                    line.set_x2(CurrentArtefact.CeLine, time)


// } END Mitigation Logic 




// { START Advanced Gap Theory

var float HighCloseOfSession = na
var float LowCloseOfSession = na

var ShouldProcessGap2Select = false

if Gap1Select == Gap2Select
    ShouldProcessGap2Select := false
else
    ShouldProcessGap2Select := true

var int StartTime1 = na
var int EndTime1 = na
var int StartTime2 = na
var int EndTime2 = na

if str.startswith(Gap1Select, "NWOG") and array.size(ArrayOfNwogs) > 0
    Substring = str.split(Gap1Select, "G")
    ArrayInt = Quant.toInteger(array.get(Substring,1))
    if array.size(ArrayOfNwogs) >= ArrayInt
        if not ShouldProcessGap2Select
            CurrentArtefact = array.get(ArrayOfNwogs, array.size(ArrayOfNwogs)-ArrayInt)
            Gap1CeValue := CurrentArtefact.HighValue
            Gap2CeValue := CurrentArtefact.LowValue
            StartTime1 := CurrentArtefact.StartTime
            EndTime1 := CurrentArtefact.EndTime
            StartTime2 := CurrentArtefact.StartTime
            EndTime2 := CurrentArtefact.EndTime
        else
            CurrentArtefact = array.get(ArrayOfNwogs, array.size(ArrayOfNwogs)-ArrayInt)
            Gap1CeValue := CurrentArtefact.CeValue
            StartTime1 := CurrentArtefact.StartTime
            EndTime1 := CurrentArtefact.EndTime

else if str.startswith(Gap1Select, "NDOG") and array.size(ArrayOfNdogs) > 0
    Substring = str.split(Gap1Select, "G")
    ArrayInt = Quant.toInteger(array.get(Substring,1))
    if array.size(ArrayOfNdogs) >= ArrayInt
        if not ShouldProcessGap2Select
            CurrentArtefact = array.get(ArrayOfNdogs, array.size(ArrayOfNdogs)-ArrayInt)
            Gap1CeValue := CurrentArtefact.HighValue
            Gap2CeValue := CurrentArtefact.LowValue
            StartTime1 := CurrentArtefact.StartTime
            EndTime1 := CurrentArtefact.EndTime
            StartTime2 := CurrentArtefact.StartTime
            EndTime2 := CurrentArtefact.EndTime      
        else
            CurrentArtefact = array.get(ArrayOfNdogs, array.size(ArrayOfNdogs)-ArrayInt)

            Gap1CeValue := CurrentArtefact.CeValue
            StartTime1 := CurrentArtefact.StartTime
            EndTime1 := CurrentArtefact.EndTime

else if str.startswith(Gap1Select, "RTH") and array.size(ArrayOfRthGaps) > 0
    Substring = str.split(Gap1Select, "H")
    ArrayInt = Quant.toInteger(array.get(Substring,1))
    if array.size(ArrayOfRthGaps) > ArrayInt
        if not ShouldProcessGap2Select
            CurrentArtefact = array.get(ArrayOfRthGaps, array.size(ArrayOfRthGaps)-ArrayInt)
            Gap1CeValue := CurrentArtefact.ClosePrice
            Gap2CeValue := CurrentArtefact.OpenPrice
            StartTime1 := CurrentArtefact.StartTime
            EndTime1 := CurrentArtefact.EndTime
            StartTime2 := CurrentArtefact.StartTime
            EndTime2 := CurrentArtefact.EndTime  
        else
            CurrentArtefact = array.get(ArrayOfRthGaps, array.size(ArrayOfRthGaps)-ArrayInt)
            Gap1CeValue := CurrentArtefact.CeValue
            StartTime1 := CurrentArtefact.StartTime
            EndTime1 := CurrentArtefact.EndTime

if str.startswith(Gap2Select, "NWOG") and array.size(ArrayOfNwogs) > 0 and ShouldProcessGap2Select
    Substring = str.split(Gap2Select, "G")
    ArrayInt = Quant.toInteger(array.get(Substring,1))
    if array.size(ArrayOfNwogs) > ArrayInt
        CurrentArtefact = array.get(ArrayOfNwogs, array.size(ArrayOfNwogs)-ArrayInt)
        Gap2CeValue := CurrentArtefact.CeValue
        StartTime2 := CurrentArtefact.StartTime
        EndTime2 := CurrentArtefact.EndTime    

else if str.startswith(Gap2Select, "NDOG") and array.size(ArrayOfNdogs) > 0 and ShouldProcessGap2Select
    Substring = str.split(Gap2Select, "G")
    ArrayInt = Quant.toInteger(array.get(Substring,1))
    if array.size(ArrayOfNdogs) > ArrayInt
        CurrentArtefact = array.get(ArrayOfNdogs, array.size(ArrayOfNdogs)-ArrayInt)
        Gap2CeValue := CurrentArtefact.CeValue
        StartTime2 := CurrentArtefact.StartTime
        EndTime2 := CurrentArtefact.EndTime    


else if str.startswith(Gap2Select, "RTH") and array.size(ArrayOfRthGaps) > 0 and ShouldProcessGap2Select
    Substring = str.split(Gap2Select, "H")
    ArrayInt = Quant.toInteger(array.get(Substring,1))
    if array.size(ArrayOfRthGaps) > ArrayInt
        CurrentArtefact = array.get(ArrayOfRthGaps, array.size(ArrayOfRthGaps)-ArrayInt)
        Gap2CeValue := CurrentArtefact.CeValue
        StartTime2 := CurrentArtefact.StartTime
        EndTime2 := CurrentArtefact.EndTime  





if StartTime1 > StartTime2
    ProjectionLinesObject.StartTimeMin := StartTime2
    ProjectionLinesObject.StartTimeMax := StartTime1
else
    ProjectionLinesObject.StartTimeMin := StartTime1
    ProjectionLinesObject.StartTimeMax := StartTime2

if EndTime1 > EndTime2
    ProjectionLinesObject.EndTimeMax := EndTime1
    ProjectionLinesObject.EndTimeMin := EndTime2
else
    ProjectionLinesObject.EndTimeMax := EndTime2
    ProjectionLinesObject.EndTimeMin := EndTime1



var float AnchorBullFloat = na
var float AnchorBearFloat = na

if ManualConfiguration
    AnchorBullFloat := switch BullAnchor
        "0.0" => 0
        "0.25" => 0.333333333333333333333333333333  
        "0.333" => 0.5  
        "0.50" => 1   
        "0.666" => 2   
        "0.75" => 3  
        "0.89" => 8
    AnchorBearFloat := switch BearAnchor
        "0.0" => 0
        "0.25" => 0.333333333333333333333333333333  
        "0.333" => 0.5  
        "0.50" => 1   
        "0.666" => 2   
        "0.75" => 3  
        "0.89" => 8

    if Gap2CeValue > Gap1CeValue
        ProjectionLinesObject.InitialRangeLow := Gap1CeValue
        ProjectionLinesObject.InitialRangeHigh := Gap2CeValue

    else
        ProjectionLinesObject.InitialRangeLow := Gap2CeValue
        ProjectionLinesObject.InitialRangeHigh := Gap1CeValue

    ProjectionLinesObject.InitialRange := ProjectionLinesObject.InitialRangeHigh-ProjectionLinesObject.InitialRangeLow

    ProjectionLinesObject.RangeHigh := ProjectionLinesObject.InitialRangeHigh+(ProjectionLinesObject.InitialRange*AnchorBullFloat)
    ProjectionLinesObject.RangeLow := ProjectionLinesObject.InitialRangeLow-(ProjectionLinesObject.InitialRange*AnchorBearFloat)
    ProjectionLinesObject.RangeValue := ProjectionLinesObject.RangeHigh-ProjectionLinesObject.RangeLow

    ProjectionLinesObject.RangeHighChanged := true

else
    if time >= ProjectionLinesObject.StartTimeMax and time < ProjectionLinesObject.StartTimeMax+Quant.GetTimeframeInMilliSeconds(timeframe.period)
        
        if Gap2CeValue > Gap1CeValue
            ProjectionLinesObject.InitialRangeLow := Gap1CeValue
            ProjectionLinesObject.InitialRangeHigh := Gap2CeValue
            ProjectionLinesObject.RangeLow := ProjectionLinesObject.InitialRangeLow
            ProjectionLinesObject.RangeHigh := ProjectionLinesObject.InitialRangeHigh       
        else
            ProjectionLinesObject.InitialRangeLow := Gap2CeValue
            ProjectionLinesObject.InitialRangeHigh := Gap1CeValue
            ProjectionLinesObject.RangeLow := ProjectionLinesObject.InitialRangeLow
            ProjectionLinesObject.RangeHigh := ProjectionLinesObject.InitialRangeHigh   

        ProjectionLinesObject.RangeHighChanged := true
        ProjectionLinesObject.InitialRange := ProjectionLinesObject.InitialRangeHigh-ProjectionLinesObject.InitialRangeLow
        ProjectionLinesObject.RangeValue := ProjectionLinesObject.InitialRange
        ProjectionLinesObject.RangeHigh := ProjectionLinesObject.RangeLow+(ProjectionLinesObject.RangeValue*1.111)
        ProjectionLinesObject.RangeLow := ProjectionLinesObject.RangeHigh-(ProjectionLinesObject.RangeValue*1.111)
        ProjectionLinesObject.RangeHighIndex := 0 
        ProjectionLinesObject.RangeLowIndex := 0

        HighCloseOfSession := open
        LowCloseOfSession := open

    else
        HighCloseOfSession := math.max(HighCloseOfSession, close)
        LowCloseOfSession := math.min(LowCloseOfSession, close)

        ArrayOfAnchorValues = array.from(0.333333333333333333333333333333, 0.5, 1, 2, 3, 8) 

        for i = 0 to array.size(ArrayOfAnchorValues)-1
            CurrentValue = array.get(ArrayOfAnchorValues, i)
            if HighCloseOfSession > ProjectionLinesObject.RangeLow+(ProjectionLinesObject.RangeValue*1.111)
                ProjectionLinesObject.RangeHigh := ProjectionLinesObject.InitialRangeHigh+(ProjectionLinesObject.InitialRange*CurrentValue)
                ProjectionLinesObject.RangeHighChanged := true
                ProjectionLinesObject.RangeValue := ProjectionLinesObject.RangeHigh-ProjectionLinesObject.RangeLow
            if LowCloseOfSession < ProjectionLinesObject.RangeHigh-(ProjectionLinesObject.RangeValue*1.111)
                ProjectionLinesObject.RangeLow := ProjectionLinesObject.InitialRangeLow-(ProjectionLinesObject.InitialRange*CurrentValue)
                ProjectionLinesObject.RangeLowChanged := true
                ProjectionLinesObject.RangeValue := ProjectionLinesObject.RangeHigh-ProjectionLinesObject.RangeLow

    


if ShowProjectionLines and (ProjectionLinesObject.RangeHighChanged or ProjectionLinesObject.RangeLowChanged)
    for i = 0 to array.size(ProjectionLinesObject.LineValues)-1
        CurrentLineValue = array.get(ProjectionLinesObject.LineValues, i)
        StartTimeMin = ProjectionLinesObject.StartTimeMin
        RangeLow = ProjectionLinesObject.RangeLow
        RangeValue = ProjectionLinesObject.RangeValue
        Color = ProjectionLinesObject.Color

        string LabelProj = ""
        if ShowProjectionLabels
            LabelProj := str.tostring(CurrentLineValue)

        int LineEnd = time

        if not ExtendProjectionLinesInRealtime
            LineEnd := ProjectionLinesObject.EndTimeMax

        Line = line.new(StartTimeMin,RangeLow+(RangeValue*CurrentLineValue), LineEnd, RangeLow+(RangeValue*CurrentLineValue),color = Color, style = line.style_solid, width = 1, xloc = xloc.bar_time)
        LabelInt = label.new(LineEnd, RangeLow+(RangeValue*CurrentLineValue), LabelProj, style = label.style_label_left, xloc = xloc.bar_time, color =color.new(color.green, 100), textcolor = Color, size =size.small, textalign = text.align_right)
        array.push(ProjectionLinesObject.Lines, LineWithLabel.new(Line,LabelInt))

        if array.size(ProjectionLinesObject.Lines) > array.size(ProjectionLinesObject.LineValues)
            DeleteArtefact = array.shift(ProjectionLinesObject.Lines)
            line.delete(DeleteArtefact.Line)
            label.delete(DeleteArtefact.Label)

    ProjectionLinesObject.RangeHighChanged := false
    ProjectionLinesObject.RangeLowChanged := false
    ProjectionLinesObject.FirstRangeDrawn := true 








// { START CleanUp
if array.size(ArrayOfNwogs) > nwogsAmount
    DeleteArtefact = array.shift(ArrayOfNwogs)
    box.delete(DeleteArtefact.Box)
    label.delete(DeleteArtefact.Label)
    if showNwogCE
        line.delete(DeleteArtefact.CeLine)
    if ShowUnmitigatedBox
        box.delete(DeleteArtefact.UnmitigatedBox)

if array.size(ArrayOfNdogs) > ndogsAmount
    DeleteArtefact = array.shift(ArrayOfNdogs)
    box.delete(DeleteArtefact.Box)
    label.delete(DeleteArtefact.Label)
    if showNdogCE
        line.delete(DeleteArtefact.CeLine)
    if ShowUnmitigatedBox
        box.delete(DeleteArtefact.UnmitigatedBox)

if array.size(ArrayOfRthGaps) > RthAmount
    DeleteArtefact = array.shift(ArrayOfRthGaps)
    box.delete(DeleteArtefact.Box)
    line.delete(DeleteArtefact.CeLine)
    label.delete(DeleteArtefact.Label)
    if ShowUnmitigatedBox
        box.delete(DeleteArtefact.UnmitigatedBox)


if DeleteMitigatedNwogs
    if array.size(ArrayOfNwogs) > 0
        array<int> ArrayOfIndexes = array.new<int>()
        for i = 0 to array.size(ArrayOfNwogs)-1
            CurrentArtefact = array.get(ArrayOfNwogs, i)
            if CurrentArtefact.Mitigated
                array.push(ArrayOfIndexes, i)
                box.delete(CurrentArtefact.Box)    
                line.delete(CurrentArtefact.CeLine)
                label.delete(CurrentArtefact.Label)
        int CountDeleted = 0
        if array.size(ArrayOfIndexes) > 0
            for i = 0 to array.size(ArrayOfIndexes)-1
                CurrentIndex = array.get(ArrayOfIndexes, i)      
                array.remove(ArrayOfNwogs, CurrentIndex-CountDeleted)
                CountDeleted := CountDeleted+1  

if DeleteMitigatedNdogs
    if array.size(ArrayOfNdogs) > 0
        array<int> ArrayOfIndexes = array.new<int>()
        for i = 0 to array.size(ArrayOfNdogs)-1
            CurrentArtefact = array.get(ArrayOfNdogs, i)
            if CurrentArtefact.Mitigated
                array.push(ArrayOfIndexes, i)
                box.delete(CurrentArtefact.Box)    
                line.delete(CurrentArtefact.CeLine)
                label.delete(CurrentArtefact.Label)
        int CountDeleted = 0
        if array.size(ArrayOfIndexes) > 0
            for i = 0 to array.size(ArrayOfIndexes)-1
                CurrentIndex = array.get(ArrayOfIndexes, i)      
                array.remove(ArrayOfNdogs, CurrentIndex-CountDeleted)
                CountDeleted := CountDeleted+1  

if DeleteMitigatedRTHs
    if array.size(ArrayOfRthGaps) > 0
        array<int> ArrayOfIndexes = array.new<int>()
        for i = 0 to array.size(ArrayOfRthGaps)-1
            CurrentArtefact = array.get(ArrayOfRthGaps, i)
            if CurrentArtefact.Mitigated
                array.push(ArrayOfIndexes, i)
                box.delete(CurrentArtefact.Box)    
                line.delete(CurrentArtefact.CeLine)
                label.delete(CurrentArtefact.Label)
        int CountDeleted = 0
        if array.size(ArrayOfIndexes) > 0
            for i = 0 to array.size(ArrayOfIndexes)-1
                CurrentIndex = array.get(ArrayOfIndexes, i)      
                array.remove(ArrayOfRthGaps, CurrentIndex-CountDeleted)
                CountDeleted := CountDeleted+1  

// } END CleanUp


// { START Extend Lines and Boxes
if extendAllNwogs and array.size(ArrayOfNwogs) > 0
    for i = 0 to array.size(ArrayOfNwogs)-1 
        // currentDayTimeClose
        box.set_right(array.get(ArrayOfNwogs, i).Box, currentDayTimeClose)
        label.set_x(array.get(ArrayOfNwogs, i).Label, currentDayTimeClose)

        if showNwogCE
            line.set_x2(array.get(ArrayOfNwogs, i).CeLine, currentDayTimeClose)

        // if eventHorizon and array.size(ArrayOfEventHorizonLines) > 0
        //     CurrentEventHorizon = array.get(ArrayOfEventHorizonLines, i-1)
        //     line.set_x2(CurrentEventHorizon, currentDayTimeClose)

if array.size(ArrayOfNwogs) > 0 and ExtendNwogsInRealtime
    for i = 0 to array.size(ArrayOfNwogs)-1
        CurrentArtefact = array.get(ArrayOfNwogs, i)
        box.set_right(CurrentArtefact.Box, time)
        label.set_x(CurrentArtefact.Label, time)
        if showNwogCE //and not (ShowUnmitigatedBox or not(CurrentArtefact.Mitigated))
            line.set_x2(CurrentArtefact.CeLine, time)
        
        // if eventHorizon and array.size(ArrayOfEventHorizonLines) > 0
        //     CurrentEventHorizon = array.get(ArrayOfEventHorizonLines, i-1)
        //     line.set_x2(CurrentEventHorizon, time)

if array.size(ArrayOfNwogs) > 0 and not ExtendNwogsInRealtime and not extendAllNwogs and not DeleteMitigatedNwogs and showNwogCE
    for i = 0 to array.size(ArrayOfNwogs)-1
        CurrentArtefact = array.get(ArrayOfNwogs, i)
        if CurrentArtefact.Mitigated
            line.set_x2(CurrentArtefact.CeLine, CurrentArtefact.EndTime)



if extendAllNdogs and array.size(ArrayOfNdogs) > 0
    for i = 0 to array.size(ArrayOfNdogs)-1 
        currentDayTimeClose
        box.set_right(array.get(ArrayOfNdogs, i).Box, currentDayTimeClose)
        label.set_x(array.get(ArrayOfNdogs, i).Label, currentDayTimeClose)

        if showNwogCE
            line.set_x2(array.get(ArrayOfNdogs, i).CeLine, currentDayTimeClose)

if array.size(ArrayOfNdogs) > 0 and ExtendNdogsInRealtime
    for i = 0 to array.size(ArrayOfNdogs)-1
        CurrentArtefact = array.get(ArrayOfNdogs, i)
        box.set_right(CurrentArtefact.Box, time)
        label.set_x(CurrentArtefact.Label, time)
        if showNdogCE
            line.set_x2(CurrentArtefact.CeLine, time)

if array.size(ArrayOfNdogs) > 0 and not ExtendNdogsInRealtime and not extendAllNdogs and not DeleteMitigatedNdogs and showNwogCE
    for i = 0 to array.size(ArrayOfNdogs)-1
        CurrentArtefact = array.get(ArrayOfNdogs, i)
        if CurrentArtefact.Mitigated
            line.set_x2(CurrentArtefact.CeLine, CurrentArtefact.EndTime)


if array.size(ArrayOfRthGaps) > 0
    for i = 0 to array.size(ArrayOfRthGaps)-1
        CurrentArtefact = array.get(ArrayOfRthGaps, i)
        if ExtendRthGapToNextDay
            int ExtendTime = currentDayTimeClose
            // if CurrentArtefact.CloseDay == "Fri"
            //     ExtendTime := CurrentArtefact.EndTime+3*ONE_DAY
            // else
            //     ExtendTime := CurrentArtefact.EndTime+ONE_DAY
            box.set_right(CurrentArtefact.Box, ExtendTime)
            line.set_x2(CurrentArtefact.CeLine, ExtendTime)
            label.set_x(CurrentArtefact.Label, ExtendTime)
        if RthGapStartAtOpening
            // int ExtendTime = na
            // if CurrentArtefact.CloseDay == "Thu"
            //     ExtendTime := CurrentArtefact.StartTime+3*ONE_DAY
            // else
            //     ExtendTime := CurrentArtefact.StartTime+ONE_DAY
            box.set_left(CurrentArtefact.Box, CurrentArtefact.StartTime)
            line.set_x1(CurrentArtefact.CeLine, CurrentArtefact.StartTime)
            // box.set_right(CurrentArtefact.Box, ExtendTime)
            // line.set_x2(CurrentArtefact.CeLine, ExtendTime)
            // label.set_x(CurrentArtefact.Label, ExtendTime)
        if ExtendRthGapsInRealtime
            box.set_right(CurrentArtefact.Box, time)
            line.set_x2(CurrentArtefact.CeLine, time)
            label.set_x(CurrentArtefact.Label, time)


        if not ExtendRthGapsInRealtime and not DeleteMitigatedRTHs and ShowRthCe and CurrentArtefact.Mitigated 
            if CurrentArtefact.Mitigated and ExtendRthsType == "Open"
                line.set_x2(CurrentArtefact.CeLine, CurrentArtefact.StartTime)


if ExtendProjectionLinesInRealtime and array.size(ProjectionLinesObject.Lines) > 0
    ArrayOfLineLabels = ProjectionLinesObject.Lines
    for i = 0 to array.size(ArrayOfLineLabels)-1
        CurrentArtefact = array.get(ArrayOfLineLabels, i)
        line.set_x2(CurrentArtefact.Line, time)
        label.set_x(CurrentArtefact.Label, time)

// } END Extend Lines and Boxes